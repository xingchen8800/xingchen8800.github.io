---
title: 提高组第十五天（最小生成树）
date: 2024-11-13 22:04:25
tags: 
    - CSP提高组
    - C++
excerpt: Prim算法和Kruskal

categories:
    - [CSP,CSP-S,课程]
    - [算法,图,最小生成树]
---

# 概念

## 生成树

对于一个无向连通图 $G$ 的子图 $g$，若 $g$ 是一棵包含 $G$ 的所有顶点的 __树__，称 $g$ 为 $G$ 的 __生成树__。

## 生成树的权

对于一个无向连通图 $G$ 的生成树 $g$，其边权之和为 __生成树的权__。即：$\sum_{i}{w_i} (w_i \in g)$

## 最小生成树

对于一个无向连通图 $G$，其权最小的生成树，叫做 $G$ 的 __最小生成树__

# $Kruskal$ 算法

## 思路

$Kruskal$ 算法的主要思路就是对边贪心：最短的边一定在最小生成树上。

1. 对图的所有边按 __权值__ 进行升序排序；
2. 当一条边要被加入到最小生成树中时，当且仅当其连接的两个点中，有一个 __不在__ 既选的边集中；
3. 所有点都被加入到边集中，算法结束，边集即为 __最小生成树__。

## 实现

我们通过 [__并查集__](/2024/CSP-S/8/) 来记录点的连通情况。

```c++
#include <bits/stdc++.h>
using namespace std;

//边结构体
const int N = 5001, M = 200001;
struct Edge {
    int u, v, w, nxt;
} edge[M];
bool Cmp(Edge a, Edge b) { return a.w < b.w; }  //按边权升序排列

//并查集
int fa[N];
int Find(int x) {
    return x == fa[x] ? x : fa[x] = Find(fa[x]);
}
void Merge(int x, int y) {
    int fx = Find(x);
    int fy = Find(y);
    fa[fx] = fy;
}

int n, m;
int main() {
    cin >> n >> m;
    for(int i = 1; i <= m; i++) {
        cin >> edge[i].u >> edge[i].v >> edge[i].w;
    }
    sort(edge + 1, edge + m + 1, Cmp);

    for(int i = 1; i <= n; i++) {
        fa[i] = i;          //让每个点构成单点集合
    }
    int edgeCnt = 0, wSum = 0;
    for(int i = 1; i <= m; i++) {
        if(Find(edge[i].u) != Find(edge[i].v)) {//两点不连通
            edgeCnt++, wSum += edge[i].w;       //累加
            Merge(edge[i].u, edge[i].v);        //合并（连通了）
        }
        if(edgeCnt == n - 1) break;             //终止条件
    }
    if(edgeCnt == n - 1) cout << wSum << endl;
    else cout << "orz" << endl;
    return 0;
}

```

# $Prim$ 算法

## 思路

$Prim$ 算法的主要思路是对邻接点贪心：离既有边集最近的点一定在最小生成树上。

$Prim$ 算法需要两个数组：`dis[]`和`vis[]`，分别记录节点到既有边集的距离和节点是否在既有边集中。

1. 随便选一个点，放入在既有边集中，将它的`dis[]`设为 $0$，`vis[]`设为 $true$，更新其邻接点的`dis[]`为邻接边权；
2. 将一个点放入边集中，当且仅当其的`dis[]`值在为被加入既有边集的点的`dis[]`中 __最小__；
3. 当`vis[]` 均为 $true$ 时，算法结束。

## 实现

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 5001, M = 200001, INF = 0x3f3f3f3f;
int g[N][N];
int n, m, ans = 0;

int dis[N]; bool vis[N];
void Prim() {
    memset(dis, 0x3f, sizeof dis);
    memset(vis, 0, sizeof vis);
    dis[1] = 0;
    for(int i = 1; i <= n; i++) {
        int k, minn = INF;  //找出一个k点，使其到既有边集的距离最近
        for(int j = 1; j <= n; j++) {
            if(!vis[j] && dis[j] < minn) {
                k = j;
                minn = dis[j];
            }
        }
        vis[k] = 1;         //标记
        ans += minn;        //权值累加
        for(int j = 1; j <= n; j++) {
            if(!vis[j] && dis[j] > g[k][j]) {
                dis[j] = g[k][j];       //更新dis[j]
            }
        }
    }
}

int main() {
    cin >> n >> m;
    memset(g, 0x3f, sizeof g);  //用邻接矩阵别忘了初始化
    for(int i = 1; i <= n; i++) g[i][i] = 0;
    for(int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g[u][v] = g[v][u] = w;
    }
    Prim();
    cout << ans << endl;
    return 0;
}
```

$Prim$ 算法和 $Dijsktra$ 类似，可以使用堆代替`dis[]`进行优化：
```c++
#include <bits/stdc++.h>
using namespace std;

#define INF 0x3f3f3f3f
const int N = 5001, M = 200001;

struct Edge {
    int v, w;   //i-->v,权值:w
};
vector<Edge> g[N];  //邻接表存图

int n, m;

struct Cmp {
    bool operator()(Edge a, Edge b) {
        return a.w > b.w;
    }
};

int vis[N];
int Prim() {
    memset(vis, 0, sizeof vis);
    priority_queue<Edge, vector<Edge>, Cmp> q;
    int cnt = 0, ans = 0;
    q.push({1, 0}); //第一个点，距离为0
    while(!q.empty()) {
        auto k = q.top(); q.pop();
        if(vis[k.v]) continue;      //已在既有图集中
        
        vis[k.v] = 1;               //标记
        ans += k.w;                 //累加权值
        cnt++;
        
        for(auto i : g[k.v]) {//遍历邻边
            if(!vis[i.v]) {         //遍历邻接点
                q.push({i.v, i.w});
            }
        }
    }
    if(cnt == n) return ans;
    else return -1;
}

int main() {
    cin >> n >> m;
    for(int i = 1; i <= m; i++) {
        int u, v, w;
        cin >> u >> v >> w;
        g[u].push_back({v, w});
        g[v].push_back({u, w});
    }
    int ans = Prim();
    if(ans == -1) cout << "orz";
    else cout << ans << endl;
    return 0;
}
```

# 例题

## 描述

在迷宫中，人们可以往北部，西部，东部和南部移动脚步。一个人从起点出发，希望迷宫里所有的人都能联系起来，并且联系的成本最低。注意：不需要两两联系，通过别人联系即可。

第一行包含两个整数 $x,y (1≤x，y≤50)$ 。然后，跟随 $y$ 行，每行 $x$ 个字符。对于每个角色，空格 ` ` 代表开放空间，标记 `＃` 代表障碍墙，大写字母 `A` 代表人，大写字母 `S` 代表搜索的开始。迷宫的周长总是关闭的，也就是说，没有办法从 `S` 的坐标中走出来。迷宫中至多有 $100$ 个人，每个人都可以到达。

## 输出：
输出一行包含成功搜索迷宫的最小成本。

## 样例输入 1 
```
7 7
#####
#AAA###
#    A#
# S ###
#     #
#AAA###
#####
```

## 样例输出 1 
```
11
```

## 题解

题目简述：找到从`S`开始，到达每个人的最小移动步数。

显然是用最小生成树做。即：将每个人 $A_i$ 和起点`S`进行编号，通过跑最小生成树的方式求得最小成本。

但是，这道题需要我们自己建图。我们考虑用 $bfs$ 分别从每个人开始搜索，获得其到达其他人（包含`S`）的路径长度，将人与人之间的网抽象成图。

```c++
#include <bits/stdc++.h>
using namespace std;

#define INF 0x3f3f3f3f
const int N = 101;

int n, m;
char mp[55][55];
int node[55][55], edge[55][55], cnt = 0;
int dx[4] = {1, -1, 0, 0}, dy[4] = {0, 0, 1, -1};

void bfs(int i, int j) {
	bool _vis[55][55] = {}; int g[N][N] = {};   //g在这里起记录(i,j)-->(xx,yy)距离的作用
    queue<pair<int, int> > q;
    q.push({i, j});
    _vis[i][j] = true;
    while(!q.empty()) {
        auto p = q.front(); q.pop();
        int x = p.first, y = p.second;
        if(node[x][y]) {
            edge[node[i][j]][node[x][y]] = g[x][y];
        }
        for(int i = 0; i < 4; i++) {
            int xx = x + dx[i];
            int yy = y + dy[i];
            if(_vis[xx][yy]) continue;
            if(xx < 0 || xx >= n) continue;
            if(yy < 0 || yy >= m) continue;
            if(mp[xx][yy] == '#') continue;;
            q.push({xx, yy});
            _vis[xx][yy] = true;
            g[xx][yy] = g[x][y] + 1;
        }
    }
}

int Prim() {
	int dis[N]; 
    bool vis[N] = {};
    int ans = 0;
    memset(dis, 0x3f, sizeof dis);
    dis[1] = 0;
    for(int i = 1; i <= cnt; i++) {
        int k, minn = INF;  //找出一个k点，使其到既有边集的距离最近
        for(int j = 1; j <= cnt; j++) {
            if(!vis[j] && dis[j] < minn) {
                k = j;
                minn = dis[j];
            }
        }
        vis[k] = 1;         //标记
        ans += minn;        //权值累加
        for(int j = 1; j <= cnt; j++) {
            if(!vis[j] && dis[j] > edge[k][j]) {
                dis[j] = edge[k][j];       //更新dis[j]
            }
        }
    }
    return ans;
}

int main() {
    cin >> n >> m; getchar(); //吞掉回车
    for(int i = 0; i < n; i++) {
        cin.getline(mp[i], 55);
    }
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
            if(mp[i][j] == 'A' || mp[i][j] == 'S') {
                node[i][j] = ++cnt;
            }
        }
    }
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < m; j++) {
            if(node[i][j]) {
                bfs(i, j);
            }
        }
    }
    cout << Prim();
    return 0;
}
```
