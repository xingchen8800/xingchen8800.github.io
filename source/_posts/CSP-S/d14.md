---
title: 提高组第十四天（Bellman-Ford算法和SPFA优化）
date: 2024-08-28 13:43:27
tags: 
    - C++
    - CSP提高组
categories:
    - [CSP,CSP-S,课程]
    - [算法,图,最短路径]
---

# Bellman-Ford算法
Bellman-Ford算法（*贝尔曼•福特算法*），是一种单源最短路径算法(*Single Source Shortest Path Alogrithm*)，可以处理带负环（有环且环中有边为负权）的图，其主要操作就是 __松弛__。对于$\mathbf{G}(V E)$，与Folyed和Dijkstra算法一样，核心思路就是 __找中间点让两点之间的路径更短__（*即松弛*），由于每个点最多被其他节点都松弛一次，所以最多松弛$V - 1$次。判断负环也很简单，当有负环时，可以通过不断走负环让最短路径的长度更短（甚至自己到自己为负）。所以再跑一遍松弛看看有没有$V - 1$次没有松弛完的情况。

 ![(图1)利用负环不断松弛](/images/d14-1.png)

背景：图中为$n$个点，$m$条边，源点为$s$

1. 初始化：建立`dis[]`数组，`dis[i]`表示从源点($s$)到$i$的最短路径长度，令`dis[s]`为0。
2. 松弛：进行$n-1$轮*松弛*（，多了就有负环），每轮遍历每个点分别作为中间点`mid`，遍历`mid`的邻接边取其终点`to`，看看经过`mid`的路径（`source-->...-->mid-->to`）是否比原路径（`source-->...-->to`）更短，更新`dis[to]`（*松弛*）
3. 判断负环：遍历每个节点和它们的邻边，看看再做一次松弛是否能让路径更短，能就说明有负环。

{% folding 实现 %}
使用[邻接表](/2024/图的存储/)存储。
```c++
const int maxn = 100001;
struct Edge_t {
    int from, to, weight;   //起始节点，终点节点，权值
    Edge(int u, int v, int w) {
        from = u;
        to = v;
        weight = w;
    }
}
vector<Edge_t> edges[maxn];    //e[i]存储第i个节点链接的所有边
void AddEdge(int u, int v, int w) {
    //存当前边
    edges[u].push_back(Edge_t(u, v, w));
}

//核心
int dis[maxn];
bool BellmanFord(int source) {
    memset(dis, 0x3f, sizeof dis);
    dis[source] = 0;

    //松弛  
    for(int i = 1; i <= n - 1; i++) {   //n-1次
        for(int from = 1; from <= n; from++) {      //遍历点作为中间点
            for(auto edge : edges[from]) {          //遍历中间点邻边
                int to = edge.to;
                if(dis[from] + edge.weight < dis[to]) dis[to] = dis[from] + edge.weight;    //松弛
            }
        }
    }

    //判断负环
    for(int from = 1; from <= n; from++) {
        for(auto edge : edges[from]) {          //遍历中间点邻边
            int to = edge.to;
            if(dis[from] + edge.weight < dis[to]) return false;
        }
    }
    return true;
}
```
{% endfolding %}

# SPFA(Shortest Path Fast Alogrithm) 单源最短路径快速算法
SPFA是对Bellman-Ford算法的优化，SPFA使用了BFS+队列进行优化，减少了不必要的访问。其主要将$n-1$次松弛变成了队列访问。BFS过程：

1. 让源点入队
2. BFS：不断取队首元素，遍历其邻边，对邻接点进行松弛。
3. 如果邻接点不在队列，就让邻接点入队，并更新其松弛次数。

<video controls src="/videos/SPFA动态演示.mp4" title="SPFA动态过程"></video>

注：采用链式前向星存储
```c++
int dis[maxn];
bool vis[maxn];
int cnt[maxn];
bool SPFA(int source) {
    memset(dis, 0x3f, sizeof dis);
    memset(vis, false, sizeof vis);
    memset(cnt, 0, sizeof cnt);

    queue<int> Q;   //队列
    Q.push(source); //源点入队
    dis[source] = 0;
    vis[source] = true; //标记
    while(Q.size()) {
        int from = Q.front();
        Q.pop();
        vis[from] = false;  //出队
        for(int i = head[from]; i; i = edges[i].next) {    //遍历邻边
            if(dis[edges[i].from] + edges[i].weight < dis[edges[i].to]) { 
                dis[edges[i].to] = dis[edges[i].from] + edges[i].weight;    //松弛

                if(!vis[edges[i].to]) { //不在队列
                    Q.push(edges[i].to);    //入队
                    vis[edges[i].to] = true;//标记
                    cnt[edges[i].to]++;
                    if(cnt[edges[i].to] > n) return false;
                }
            }
        }
    }
    return true;
}
```

# DFS优化Bellman-Ford算法
```c++
int dis[maxn];
bool vis[maxn];
bool flag = false;  //是否有负环
void Dfs(int u) {
    if(flag) return;
    vis[u] = 1;             //标记
    for(int i = head[u]; i; i = edges[i].next) { //遍历邻边
        int v = edges[i].v, w = edges[i].w;
        if(dis[u] + w < dis[v]) {    //松弛
            dis[v] = dis[u] + w;
            if(vis[v]) {    //二次访问，成负环
                flag = true;//标记
                return 0;
            } else dfs(v);  //递归
        }
    }
    vis[u] = 0;             //回溯
}

//in main:
    dis[s] = 0;
    dfs(s);
```

# 习题 - 最优贸易

## 描述

C 国有 $n$ 个大城市和 $m$ 条道路，每条道路连接这 $n$ 个城市中的某两个城市。任意两个城市之间最多只有一条道路直接相连。这 $m$ 条道路中有一部分为单向通行的道路，一部分为双向通行的道路，双向通行的道路在统计条数时也计为 $1$ 条。

C 国幅员辽阔，各地的资源分布情况各不相同，这就导致了同一种商品在不同城市的价格不一定相同。但是，同一种商品在同一个城市的买入价和卖出价始终是相同的。

商人阿龙来到 C 国旅游。当他得知同一种商品在不同城市的价格可能会不同这一信息之后，便决定在旅游的同时，利用商品在不同城市中的差价赚回一点旅费。设 C 国 $n$ 个城市的标号从 $1 \sim n$，阿龙决定从 $1$ 号城市出发，并最终在 $n$ 号城市结束自己的旅行。在旅游的过程中，任何城市可以重复经过多次，但不要求经过所有 $n$ 个城市。阿龙通过这样的贸易方式赚取旅费：他会选择一个经过的城市买入他最喜欢的商品――水晶球，并在之后经过的另一个城市卖出这个水晶球，用赚取的差价当做旅费。由于阿龙主要是来 C 国旅游，他决定这个贸易只进行最多一次，当然，在赚不到差价的情况下他就无需进行贸易。

假设 C 国有 $5$ 个大城市，城市的编号和道路连接情况如下图，单向箭头表示这条道路为单向通行，双向箭头表示这条道路为双向通行。

![示意图](/images/d14-2.png)

假设 $1 \sim n$ 号城市的水晶球价格分别为 $4,3,5,6,1$。

阿龙可以选择如下一条线路：$1→2→3→5$，并在 $2$ 号城市以 $3$ 的价格买入水晶球，在 $3$ 号城市以 $5$ 的价格卖出水晶球，赚取的旅费数为 $2$。

阿龙也可以选择如下一条线路：$1→4→5→4→5$，并在第 $1$ 次到达 $5$ 号城市时以 $1$ 的价格买入水晶球，在第 $2$ 次到达 $4$ 号城市时以 $6$ 的价格卖出水晶球，赚取的旅费数为 $5$。

现在给出 $n$ 个城市的水晶球价格，$m$ 条道路的信息（每条道路所连接的两个城市的编号以及该条道路的通行情况）。请你告诉阿龙，他最多能赚取多少旅费。

## 输入描述

第一行包含 $2$ 个正整数 $n$ 和 $m$，中间用一个空格隔开，分别表示城市的数目和道路的数目。

第二行 $n$ 个正整数，每两个整数之间用一个空格隔开，按标号顺序分别表示这 $n$ 个城市的商品价格。

接下来 $m$ 行，每行有 3 个正整数 $x,y,z$，每两个整数之间用一个空格隔开。如果 $z=1$，表示这条道路是城市 $x$ 到城市 $y$ 之间的单向道路；如果 $z=2$，表示这条道路为城市 $x$ 和城市 $y$ 之间的双向道路。

## 输出描述

一个整数，表示最多能赚取的旅费。如果没有进行贸易，则输出 $0$。

## 样例输入 #1 
```
5 5 
4 3 5 6 1 
1 2 1 
1 4 1 
2 3 2 
3 5 1 
4 5 2
```

## 样例输出 #1 
```
5
```

## 提示

### 数据范围与提示

输入数据保证 $1$ 号城市可以到达 $n$ 号城市。

对于 $10\%$ 的数据，$1≤n≤6$。

对于 $30\%$ 的数据，$1≤n≤100$。

对于 $50\%$ 的数据，不存在一条旅游路线，可以从一个城市出发，再回到这个城市。

对于 $100\%$ 的数据，$1≤n≤100000，1≤m≤500000，1≤x,y≤n，1≤z≤2$，$1 \leq $ 各城市的编号 ≤n。

水晶球价格 $≤100$。

## 题解

对于一道最短路径题，首先想想建模