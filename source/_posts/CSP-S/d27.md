---
title: 提高组27(Tarjan找割边/点)
date: 2024-12-13 20:01:00
tags:
---

## 无向图中的概念

1. $\boldsymbol{\large{连通图}}$：无向图中 __任意__ 两点是连通的，则称这个无向图是 __连通的__，也称这个无向图为 __连通图__。
2. $\boldsymbol{\large{割点}}$： 无向连通图中，去掉一个结点（及其邻边），使原来的图不再是连通图，则称该结点为 __割点__。
3. $\boldsymbol{\large{割边（桥）}}$：无向连通图中，去掉一条边，使原来的图不再是连通图，则称该边为 __割边（或桥）__
4. $\boldsymbol{\large{搜索树}}$：无向图 ${G}$ 中，从任意结点开始深搜，每个结点访问 __一次__，遍历的边集叫做 ${G}$ 的一棵 __搜索树__。

{% notel blue fa-link 割边与割点的关系 %}

1. 有割点不一定有桥，有桥一定存在割点。
2. 桥一定是割点的邻边。

{% endnotel %}

## $Tarjan$ 算法

{% note yellow fa-warning %}
注意：下面所有的 __父结点__ 和 __祖先结点__ 都是针对搜索树而言的。
{% endnote %}

### 割点的判断

若对于一个结点 $u$，如果其子节点可以不通过 $u$ 访问到 $u$ 的祖先节点，则去掉结点 $u$ 不影响图的连通性，即 __$\boldsymbol{u}$ 不是割点。__

相反，如果 $u$ 存在一个子节点，其必须通过 $u$ 才能到达 $u$ 的祖先结点，那么去掉 $u$ 后必定破坏了图的连通性，即 __$\boldsymbol{u}$ 是割点__。

![割点判断图](/images/CSP-S/d27/1.png)

如图所示：

- 图中的一堆节点与 $2$ 和 $4$ 分别有连边，那么无论去掉 $2$ 还是 $4$，一堆节点中的任一结点仍然可以到达图中的其他结点。
- 相反，另一堆结点只跟 $4$ 相连，如果去掉 $4$，那么 $另一堆结点 \to 4$ 就断了，另一堆结点中的所有结点都无法与 $4$ 的祖先结点相连。

### 找割边

我们可以使用两个数组 $dfn$ 和 $low$ 来辅助判断割点。

- $dfn_i$ 表示 $i$ 结点的时间戳（时间戳是形象的说法，更准确地，代表了 $dfs$ 序）。
- $low_i$ 表示 $i$ 结点不通过父结点能访问的最小时间戳。

$low$ 数组更像是假装某个点的父结点被去掉了，看看它能不能访问到搜索树上的父结点的祖宗，当然越低越好。对于一个结点 $u$，如果它的某个邻接点 $v$（不含父结点）被搜索过了，它就到达了父结点的祖先结点，$low_u$ 显然应该更新为原值和 $dfn_v$ 的最小值；如果没被搜索过，则需要继续递归求得 $v$ 的 $low$ 和 $dfn$，然后将 $low_u$ 更新为原值和 $low_v$ 的最小值，这是因为若 $v$ 能不经过 $u$ 走到 $u$ 的祖先结点，那么 $u$ 显然能经过 $v$ 访问其祖先节点，反之亦然。

这样，我们就可以在回溯的过程中判断割边了：对于一条无向边 $u \to v$，若 $\boldsymbol{dfn_u < low_v}$，那么这条边是割边。很显然，如果 $v$ 不通过 $u$ 能到达的最小时间戳比 $u$ 本身还大，即连 $u$ 都访问不到，谈何访问 $u$ 的祖先？

```c++

int dfn[N], low[N], num = 0;
void Tarjan(int u, int fa) {
    dfn[u] = low[u] = ++num;    //时间戳
    //遍历邻边
    for(int i = h[u]; i; i = ed[i].nxt) {
        int v = ed[i].v;
        if(!dfn[v]) {
            //若某次搜索到了没有被搜索过的点
            Tarjan(v, u);                   //进行搜索，获取dfn[v]和low[v]
            //进入回溯
            low[u] = min(low[u], low[v]);   //如果v可以走到祖先结点，那么u可以通过v到达祖先结点
            if(dfn[u] < low[v]) {
                cout << u << "-->" << v << endl;
            }
        } else if(v != fa) {
            //若在某次搜索中碰到了之前搜过的点（且非父结点）
            //那么显然找到了一条不经过父结点却能走到其祖先结点的路径
            //要将low[u]的值更新
            low[u] = min(dfn[v], low[u]);
        }
    }
}
```
