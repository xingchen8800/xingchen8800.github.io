---
title: 提高组第十九天(树上差分)
date: 2024-12-04 11:54:58
excerpt: 树上差分，即把差分数组的原理运用到树上。由于树上两点间的路径是唯一的，我们可以直接维护差分，查询只需要通过DFS累加即可。
tags:
    - C++
    - CSP提高组
categories:
    - [数据结构,图,树]
---

## 点的差分

### 引入

#### 描述

$N$ 个城市之间，有 $N-1$ 条道路。某一段时间内，共有 $m$ 辆货车出发。对于一辆货车 $i$， 它从城市 $a_i$ 出发，到城市 $b_i$ ，货车不会绕道，走城市 $a_i$ 到城市 $b_i$ 的最短路径。起点和终点，以及运输中经过的城市，都会记录 $1$ 次，表明货车经过该城市。

问：在 $m$ 次运输中，$n$ 个城市里，在 __所有城市经过的货车次数__ 中，最大值是多少。

#### 输入描述

- 第一行两个正整数 $N$ 和 $m$，表示 $N$ 个城市间有 $N-1$ 条道路，编号从 $1$ 到 $N$。某个时段内有 $m$ 辆货车出发。
- 接下来 $N$ 行，每行两个正整数 $x,y$，表示从城市 $x$ 到城市 $y$ 有一条道路。
- 接下来 $m$ 行，每行两个正整数 $a_i$ 与 $b_i$，表示第 $i$ 辆火车从 $a_i$ 到 $b_i$。

#### 输出描述

一行，一个正整数，表示在所有城市经过的货车次数中，最大值是多少。

#### 样例输入 #1

```
5 10
3 4
1 5
4 2
5 4
5 4
5 4
3 5
4 3
4 3
1 3
3 5
5 4
1 5
3 4
```

#### 样例输出 #1

```
9
```

#### 提示

**数据范围**

- $2 \leq N \leq 5 \times 10^4$
- $1 \leq m \leq 10^5$
- $1 \leq x,y \leq N$

### 介绍

对于在树上的节点计数统计问题，我们可以通过 __树上差分__ 来处理。

相信大家对差分数组一定不陌生。差分数组就是一种可以 $\bf{O} {(1)}$ 处理区间修改， $\bf{O} {(n)}$ 单点查询的数据结构，数组中的每一个元素表示源元素与其前一个元素的差。对于区间修改，我们只需要：

```c++
//[l,r] 区间加上 k
d[l] += k;
d[r + 1] -= k;
//[l,r] 区间减去 k
d[l] -= k;
d[r + 1] += k;
```

那么我们能否把差分数组拓展到树上呢？

![例图](/images/CSP-S/d19/1.png)

由于树上两点间的路径是 __唯一__ 的，所以假设以 $a_u$ 存储节点 $u$ 被记录的次数，那么可以用数组 $d$ 来作数组 $a$ 的差分数组（注意：原本的差分数组以下标为线，这里的差分数组以树的边为线；原本的差分数组查询从下标 $0$ 开始作前缀和，这里的差分数组查询从叶子节点开始作前缀和）。当有一条 $u \to v$ 的路径上的点的记录要 $+k$，我们可以让 $d_u += k, d_{v的父节点} -= k$（注：树是无向图，但 $u$ 和 $v$ 不可以调换，一定要保证 $dep_u > dep_v$）。

例如对于例图，橙色的数字就相当于是 $a$ 数组，深红色数字就相当于是 $d$ 数组。$2 \to 5$ 就要把 $d_5 += 1, d_{2的父节点(1)} -= 1$。

```c++
//u -> v（注意，u比v的深度深）
d[u]++, d[jump[v][0]]--;
```

那么要怎么查询某个点的记录次数呢？前面有提到：“这里的差分数组查询从叶子节点开始作前缀和”，树上差分需要 $dfs$ 查询每个节点的记录次数，$dfs$ 过程如下：

1. 后序遍历到叶子节点
2. 从叶子节点回溯，再回溯的过程中不断累加差分数组的值
3. 对于每个节点，它的记录次数就是当前累加到的值

```c++
//fa -> u
void GetValue(int u, int fa) {
    for(int i = h[u]; i; i = l[i].nxt) {    //遍历邻接点
        int v = l[i].v;
        if(v == fa) continue;   //不走回头路
        GetValue(v, u);         //先获取v的记录值
        d[u] += d[v];           //前缀和累加
    }
}
```

### 解决问题

![图 2](/images/CSP-S/d19/2.png)

现在再看引题，会发现就是通过 $LCA$ 找 $a_i \to b_i$ 的具体路径，然后把路径上拆成两份。如图 $2$，把 $2 \to 3$ 的路径看作是 $2 \to 4(2与3的LCA)$ 与  $3 \to 4$ 两段，但是 $4$ 被算了两次，所以 $3 \to 4$ 变为 $4 \to 4$，对于每一段分别进行区间修改：

```c++
//更新u,v间路径记录值
int lca = LCA(u, v);
d[u] += k, d[lca] -= k;
d[v] += k, d[jump[lca][0]] -= k;
```

然后，这道题的代码就呼之欲出了：

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 500001, M = 500001;
int d[N];

struct Edge {
    int u, v, w, nxt;
} l[M << 2];
int h[N], cnt = 0;
void Link(int u, int v, int w) {
    l[++cnt] = {u, v, w, h[u]}; h[u] = cnt;
}

int n, m, s;   //n点、m次询问

//深搜求dep
int dep[N], jump[N][31];
void Dfs(int u, int fa) {
    dep[u] = dep[fa] + 1;   //记录深度
    jump[u][0] = fa;        //初始化jump数组
    for(int i = h[u], v; i; i = l[i].nxt) {
        v = l[i].v; 
        if(v == fa) continue;   //不能原路返回
        Dfs(v, u);
    }
}
//递推求jump
void GetJump() {
    for(int i = 1; i <= 30; i++) {
        for(int j = 1; j <= n; j++) {
            jump[j][i] = jump[jump[j][i-1]][i-1];
        }
    }
}

//倍增求lca
int LCA(int u, int v) {
    if(dep[u] < dep[v]) swap(u, v); //保证u在v下   
    //将u上跳到v的高度
    for(int i = 20; i >= 0; i--) {
        if(dep[u] - (1 << i) >= dep[v]) {
            u = jump[u][i];
        }
    }
    if(u == v) return u;    //特判
    //跳到lca下
    for(int i = 20; i >= 0; i--) {
        if(jump[u][i] != jump[v][i]) {
            u = jump[u][i];
            v = jump[v][i];
        }
    }
    return jump[u][0];      //u或v的父节点是lca
}

void GetValue(int u, int fa) {
    for(int i = h[u]; i; i = l[i].nxt) {
        int v = l[i].v;
        if(v == fa) continue;   //不走回头路
        GetValue(v, u);         //先获取v的记录值
        d[u] += d[v];           //累加到u的记录值上
    }
}

int main() {
    cin >> n >> m;
    for(int i = 1, u, v; i < n; i++) {   //树有n-1条边
        cin >> u >> v;
        Link(u, v, 1); Link(v, u, 1);
    }
    Dfs(1, 0);  //0号节点其实不存在，只是虚拟的
    GetJump();
    while(m--) {
        int u, v; cin >> u >> v;
        //u -> lca -> v
        int lca = LCA(u, v);
        d[u]++, d[jump[lca][0]]--;
        d[v]++, d[lca]--;
    }
    GetValue(1, 0);
    int maxVal = 0;
    for(int i = 1; i <= n; i++)  maxVal = max(maxVal, d[i]);
    cout << maxVal << endl;
    return 0;
}
```

## 边的差分

### 描述

小 $Z$ 有一个 $n$ 个结点，$n-1$ 条边建立的树。他现在添加 $m$ 条 __无向__ 边。

小 $Z$ 想知道：在 $n-1$ 条边中切断一条树边，新加的 $m$ 条边中也切断一条边。切割后，能够使这个 __无向__ 图不再连通的切割方案数。

注：即使只切断一条树边就可以使图不连通，也需要再切断 $m$ 中的一条边。

由于方案数太多了，小 $Z$ 要请你通过编程解决。

### 输入描述

- 第一行包含两个整数 $n$ 和 $m$；
- 之后 $n-1$ 行，每行包括两个整数 $a$ 和 $b$，表示 $a$ 和 $b$ 之间有一条主要边；
- 之后 $m$ 行以同样的格式给出附加边。

### 输出描述

输出方案数。

### 样例输入 1 

```
4 1
1 2
2 3
1 4
3 4
```

### 样例输出 1 

```
3
```

### 提示

**数据范围与提示**：

$2≤n≤50,000，1≤m≤100,000$

### 题解

由于处理加了 $m$ 条边后的情况较为复杂，我们先不考虑加了 $m$ 条边的情况。

先给出一个结论：对于一个结点，如果连接它与父结点的边切断后能使树不再连通，当且仅当这个点到根节点 __有且仅有一条__ 路径。

![样例图](/images/CSP-S/d19/3.png)

假设有一条新边 $u \to v$，显然所有在 $u \to LCA(u,v)$ 和 $v \to LCA(u,v)$ 上的结点到根结点的方案都应该 $+1$。

例如样例图中，原本所有的边到根结点的路径都只有一条，加入了红色边 $3 \to 4$ 后，$3$ 可以通过 $3 \to 4 \to 1$ 走到 $1$；$4$ 可以通过 $4 \to 3 \to 2 \to 1$ 走到 $1$；$2$ 可以通过 $2 \to 3 \to 4 \to 1$ 走到 $1$。即 $2,3,4$ 都能通过新的无向边 $3 \to 4$ 增加一条到 $1$ 的路径，即：$3 \to 1$ 和 $4 \to 1$ 上的所有点到根节点 $1$ 的路径 $+1$。

我们可以通过一个数组 $a$ 来记录每个结点 $u$ 到根节点的路径条数 $a_u + 1$（注意，$a_u = 0$ 表示到根结点有一条路径）。当 $a_u$：

- $=0$ 时，到根结点只有一条路径，可以割掉 $m$ 条边中的任意一条，显然有 $m$ 种方案。
- $=1$ 时，只有两条到根结点的路径，只能割掉 $m$ 条边中与 $u$ 连的那条和 $u$ 往根结点的邻接边，显然只有 $1$ 种方案。
- $\ge 2$ 时，到根结点的路径不止两条，无法通过割掉任意一条树中原有的边和任意一条新边来使图不连通。

此时，当我们要连接 $u \to v$ 时，就是把 $a_{[u, lca(u,v)]}$ 和 $a_{[v, lca(v,u)]}$ 都 $+1$。

这不，又是区间修改，再次通过差分数组优化：建立一个差分数组 $d$，此时只需要将 $d_u, d_v$ 都 $+1$，$d_{lca(u,v)} -2$（即不包含 $lca(u,v)$，只计算 $u \to lca(u,v)的子结点$，$v \to lca(u,v)的子节点$） 即可。

```c++
d[u]++, d[v]++;
d[LCA(u,v)] -= 2;
```

完整代码：

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 500001, M = 500001;
int d[N];

struct Edge {
    int u, v, w, nxt;
} l[M << 2];
int h[N], cnt = 0;
void Link(int u, int v, int w) {
    l[++cnt] = {u, v, w, h[u]}; h[u] = cnt;
}

int n, m, s;   //n点、m次询问

//深搜求dep
int dep[N], jump[N][31];
void Dfs(int u, int fa) {
    dep[u] = dep[fa] + 1;   //记录深度
    jump[u][0] = fa;        //初始化jump数组
    for(int i = h[u], v; i; i = l[i].nxt) {
        v = l[i].v; 
        if(v == fa) continue;   //不能原路返回
        Dfs(v, u);
    }
}
//递推求jump
void GetJump() {
    for(int i = 1; i <= 30; i++) {
        for(int j = 1; j <= n; j++) {
            jump[j][i] = jump[jump[j][i-1]][i-1];
        }
    }
}

//倍增求lca
int LCA(int u, int v) {
    if(dep[u] < dep[v]) swap(u, v); //保证u在v下   
    //将u上跳到v的高度
    for(int i = 20; i >= 0; i--) {
        if(dep[u] - (1 << i) >= dep[v]) {
            u = jump[u][i];
        }
    }
    if(u == v) return u;    //特判
    //跳到lca下
    for(int i = 20; i >= 0; i--) {
        if(jump[u][i] != jump[v][i]) {
            u = jump[u][i];
            v = jump[v][i];
        }
    }
    return jump[u][0];      //u或v的父节点是lca
}

void GetValue(int u, int fa) {
    for(int i = h[u]; i; i = l[i].nxt) {
        int v = l[i].v;
        if(v == fa) continue;   //不走回头路
        GetValue(v, u);         //先获取v的记录值
        d[u] += d[v];           //累加到u的记录值上
    }
}

int main() {
    cin >> n >> m;
    for(int i = 1, u, v; i < n; i++) {   //树有n-1条边
        cin >> u >> v;
        Link(u, v, 1); Link(v, u, 1);
    }
    Dfs(1, 0);  //0号节点其实不存在，只是虚拟的
    GetJump();
    for(int i = 1; i <= m; i++) {
        int u, v; cin >> u >> v;
        int lca = LCA(u, v);
        d[u]++, d[v]++;
        d[lca] -= 2;
    }
    GetValue(1, 0);
    int ans = 0;
    for(int i = 2; i <= n; i++) {
        if(d[i] == 0) ans += m;
        else if(d[i] == 1) ans++;
    }
    cout << ans << endl;
    return 0;
}
```