---
title: 提高第十天（树状数组）
date: 2024-08-17 15:49:33
categories:
    - [CSP,CSP-S,课程]
    - [数据结构,图,树]
excerpt: 使用树状数组进行单值修改、区间查询。
tags: 
    - C++
    - CSP提高组
---

{% note green fa-link %}
代码请移步 {% btn 这里::https://github.com/xingchen8800/CSP/tree/main/S/10-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84 %}
{% endnote %}

# 树状数组

## 作用

__单值__ 修改，__区间__ 查询。

与差分数组、线段树的对比：

 | 名称 | 修改 | 查询 |
 |:-:|-|-|
 |差分数组|区间($\mathbf{O}(1)$)|单值($\mathbf{O}(n)$)|
 |__→树状数组__|区间|区间|
 |线段树|区间（拓展性强）|区间（拓展性强）|

## 原理

树状数组的叶子节点`i`表示原数组中$[\mathbf{lowbit}(i), i]$的数据之和。

{% notel red fa-bolt `lowbit()`的解析 %}
`lowbit()`是取`x`的二进制中最低位`1`的函数，例：`lowbit(14) = 2;` //13的二进制是1110，最低位是11[1]0，所以结果是2 (10)

`lowbit()`的源码：
```c++
int lowbit(int x) {
    return x & (-x);    //wtf
}
```

在二进制中，`-x`的含义是取`x`的 __补码__，而`x`的补码是`x`的反码与`1`的和，`x`的反码将`x`中的`1`与`0`反转，则`x`的反码加上`1`后进位的那一位恰恰与`x`的那一位是相同的（进位操作使二进制的相邻两位反转），这是 __唯一一个__ `-x`与`x`的区别！所以`x & (-x)`得到的就是`x`的反码加上`1`后进位的那一位，即`x`的二进制中最低位的`1`

例子：

一个数的二进制为`1110010[1]0`，反码为`0001101[0]1`，补码就为`0001101[1]0`，其中在做反码+1操作时最后的`01`发生反转成为`10`。
{% endnotel %}

树状数组的示意图：
![图10-1](/images/d10-1.png)

- `lowbit(1) = 1`, $c_1 = a_1$
- `lowbit(2) = 2`, $c_2 = a_1 + a_2$
- `lowbit(3) = 1`, $c_3 = a_3$
- `lowbit(4) = 4`, $c_4 = a_1 + a_2 + a_3 + a_4$
- `lowbit(5) = 1`, $c_5 = a_5$
- `lowbit(6) = 2`, $c_6 = a_5 + a_6$
- `lowbit(7) = 1`, $c_7 = a_7$
- `lowbit(8) = 8`, $c_8 = a_1 + a_2 + a_3 + a_4 + a_5 + a_6 + a_7 + a_8$
- `lowbit(9) = 1`, $c_9 = 9$

## 操作

### 单值修改

由树状数组的原理：

>树状数组的叶子节点`i`表示原数组中$[\mathbf{lowbit}(i), i]$的数据之和。

可知当原数组的一个值被修改时，其在树状数组中的所有父节点都要变化。

那么怎么找父节点呢？很简单，对于一个叶子节点`c[i]`，有一个节点`c[i + lowbit(i)]`为其父节点

### 区间查询

由树状数组的原理：

>树状数组的叶子节点`i`表示原数组中$[\mathbf{lowbit}(i), i]$的数据之和。

~~注意到~~，要求一个区间$[1,x]$的和，就递归地将`c[x]`与`c[x - lowbit(x)]`累加并令`x`为`x - lowbit(x)`。

但是怎样求区间$[L,R]$的和呢？这里要用到前缀和的知识，$[L,R]=[1,R]-[1,L-1]$

## 实现

### 单值修改：
```c++
const int N = 100001;
int a[N];   //原数组，最多N个数据
int c[N];
int n;  //n个数据

void Update(int x, int k) {
    for(int i = x; i <= n; i += lowbit(i)) c[i] += k;
}
```

### 区间查询：
```c++
int Sum(int l, int r) {
    if(l == 1) {
        int result = 0;
        for(int i = r; i >= 1; i -= lowbit(i)) result += c[i];  //累加
        return result;
    } else return Sum(1, r) - Sum(1, l - 1);    //前缀和
}
```
