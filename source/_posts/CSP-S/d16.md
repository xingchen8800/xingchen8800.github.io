---
title: 提高组第十六天(最小生成树练习)
date: 2024-11-15 20:13:31
excerpt: 巩固最小生成树知识，提高建图思维
tags:
    - CSP提高组
    - C++
categories:
    - [CSP,S,课程]
    - [算法,图,最小生成树]
---

{% notel red fa-lightblub 前置思想 %}
在最小生成树的实际运用中，有些题目需要建立 __虚拟点__，一般定义为 $0$ 号点。
{% endnotel %}

# T1. [猜球](https://www.luogu.com.cn/problem/P5994)

## 题目描述

魔术师的桌子上有 $n$ 个杯子排成一行，编号为 $1,2,…,n$，其中某些杯子底下藏有一个小球，如果你准确地猜出是哪些杯子，你就可以获得奖品。

花费 $c_{ij}$ 元，魔术师就会告诉你杯子 $i,i+1,…,j$ 底下藏有球的总数的奇偶性。

采取最优的询问策略，你至少需要花费多少元，才能保证猜出哪些杯子底下藏着球？

### 输入格式

第一行一个整数 $n$。

第 $i+1$ 行（$1\le i\le n$）有 $n+1-i$ 个整数，表示每一种询问所需的花费。

其中 $c_{ij}$（对区间 $[i,j]$ 进行询问的费用，$1\le i\le j\le n$）为第 $i+1$ 行第 $j+1-i$ 个数。

### 输出格式

输出一个整数，表示最少花费。

## 样例 #1

### 样例输入 #1

```
5
1 2 3 4 5
4 3 2 1
3 4 5
2 1
5
```

### 样例输出 #1

```
7
```

## 提示

对于 $100\%$ 的数据，$1\le n\le 2\times 10^3$，$1\le c_{ij}\le 10^9$。

## 题解

若知道 $[l,r_1]$ 和 $[l,r_2]$ 的奇偶性，则知道 $[r_1 + 1, r_2]$ 的奇偶性。抽象成图，就变成了若 $l \rightarrow r_1$ 且 $l \rightarrow r_2$，则 $r_1 + 1 \rightarrow r_2$。考虑把 $r_1 + 1$ 变成 $r_1$，就要改变边的定义：$[l-1, r]$ 相当于 $l \rightarrow r$。此时，若 $l \rightarrow r_1$ 且 $l \rightarrow r_2$，则 $r_1 \rightarrow r_2$。

再和题意联系，由于我们需要知道每个杯子中的情况，所以我们应当使所有杯子间相互连接。我们只需要将 $c_{l,r}$ 作为 $l-1 \rightarrow r$ 的权值建图，跑一次最小生成树求最小代价。

```c++
#include <bits/stdc++.h>
using namespace std;
const long long N = 2e3 + 1;
#define INF 0x3f3f3f3f

long long g[N][N];
long long n, c[N][N];

long long dis[N]; bool vis[N];
long long Prim() {
    long long ans = 0;
    memset(dis, 0x3f, sizeof dis);
    memset(vis, 0, sizeof vis);
    dis[1] = 0;
    for(long long i = 0; i <= n; i++) {
        long long k, minn = INF;  //找出一个k点，使其到既有边集的距离最近
        for(long long j = 0; j <= n; j++) {
            if(!vis[j] && dis[j] < minn) {
                k = j;
                minn = dis[j];
            }
        }
        vis[k] = 1;         //标记
        ans += minn;        //权值累加
        for(long long j = 0; j <= n; j++) {
            if(!vis[j] && dis[j] > g[k][j]) {
                dis[j] = g[k][j];       //更新dis[j]
            }
        }
    }
    return ans;
}

int main() {
    cin >> n;
    memset(g, 0x3f, sizeof g);
    for(long long i = 1; i <= n; i++) {
        for(long long j = i; j <= n; j++) {
            cin >> c[i][j];
            g[i-1][j] = g[j][i-1] = c[i][j];    //i-1 --> j 连双向边
        }
    }
    cout << Prim();
    return 0;
}
```

# T2. 积水深度

## 描述

有 $n×m$ 个矩阵方块组成的棋盘，每个矩阵方块高低不一，可能比水平面高，也可能比水平面低。如果一个方块比上下左右四个方块都要低，是可以存贮水的。不考虑四个斜方向漏水的可能。

棋盘外面存不住水，存水高度可以视为 $0$。现在往棋盘上浇水，问每个矩阵方块中水的高度是多少。

### 输入描述

 $n+1$ 行，第一行两个整数，表示 $n,m$。接下来的 $n$ 行输入矩阵方块组成的棋盘。

### 输出描述

$n$ 行 $m$ 列，输出每个矩阵方块中水的高度。

## 样例输入 1 

```
3 3
4 4 0
2 1 3
3 3 -1
```

## 样例输出 1 

```
0 0 0 
0 1 0
0 0 1
```

## 题解

<!--
可以发现，每个点 $i$ 能储存的水量就相当于从四面到点的连线上值最小的点与 $i$ 的高度差（因为 __水桶效应__ ）。例如对于点 $(3,3)$，从四面的连边分别是 $0 \rightarrow$ $\mathbf{2}$ $\rightarrow 1$（左）、$0 \rightarrow 4 \rightarrow 1$（上）、$0 \rightarrow 3 \rightarrow 1$（右）、$0 \rightarrow 3 \rightarrow 1$（下）。其中，__加粗__ 的 $\mathbf{2}$ 值最小，能储水 $\mathbf{2}-1=1$。

对于每个点都是要找一条在四条“十”字形边中 __包含最高高度为最低高度__ 的路径上的高度最大值。那么，这刚好符合最小生成树解决的问题类型。我们对上图建抽象图，每条边都连接相邻的两点，边权为两点中更高的一点的高度，如下图所示。

![抽象图](/images/CSP-S/d16/2.png)


![最小生成树](/images/CSP-S/d16/4.png)

跑完最小生成树后，剩下的边都是保证图连通的情况下 __权值最小的__，所以只要求从 __虚拟点__ 到当前点的路径中的权值最大值，求其与当前点的高度差，既是答案。

总结一下建图思路：建一个 __虚拟点__，向外圈的所有点连边，每个点向上下左右（如有）连边，边权值为 $max(h_i,h_j)$。

!-->


问题简述：我们需要计算一个由 $n \times m$ 个矩阵方块组成的棋盘中，每个方块能够存储的水的高度。每个方块的高度可能高于或低于水平面。只有当一个方块的高度低于其上下左右四个方块时，它才能存储水。

![](https://cdn.luogu.com.cn/upload/image_hosting/13w07m1a.png)

### 方块储水的分析

每个方块 $i$ 能够存储的水量等于从四个方向到达该方块的路径中，最低高度的方块与 $i$ 的高度差。这个现象被称为 **水桶效应**。例如，对于点 $(3,3)$，从四个方向的路径分别是：

- 左边：$0 \rightarrow \mathbf{2} \rightarrow 1$
- 上边：$0 \rightarrow 4 \rightarrow 1$
- 右边：$0 \rightarrow 3 \rightarrow 1$
- 下边：$0 \rightarrow 3 \rightarrow 1$

在这些路径中，**加粗** 的 $\mathbf{2}$ 是最低的，因此该点能够存储的水量为 $\mathbf{2} - 1 = 1$。

### 建图思路

为了找到每个点的水存储量，我们可以将问题转化为图论问题。我们需要构建一个图，其中每个点与其相邻的四个点相连，边的权值为这两个点中较高的高度。这样，我们就可以使用最小生成树（MST）来解决这个问题。

### 图的构建

1. **连接边**：每个点与其上下左右相邻的点相连，边的权值为这两个点中较高的高度（这样做把高度转换为边权，跑完最小生成树后直接求解；取较高的高度是因为跑完MST后要取最大值）。

    ![](https://cdn.luogu.com.cn/upload/image_hosting/96eiq2fr.png)

2. **虚拟点**：然而，由于外圈浅色的 $0$ 都向实际外圈的点连边，所以把一圈 $0$ 简化为一个 $0$，用一个 $0$ 向外圈的点连边即可。

    我们引入一个虚拟点，连接到棋盘的外圈。这个虚拟点的高度为 $0$，表示外部的水位。
    
    ![化简后（其实原来右 $4$ 条权值为 $0$ 的边，化简后变成 $2$ 条，没什么实质影响）](https://cdn.luogu.com.cn/upload/image_hosting/k6mc1psc.png)


### 最小生成树

通过构建最小生成树，我们可以确保图的连通性，并且边的权值是最小的。完成最小生成树后，我们只需计算从虚拟点到每个点的路径中，权值最大的边。这个最大值减去当前点的高度，就是该点能够存储的水的高度（因为虚拟点相当于最外圈的水平面，往内走，最终每个点能存的水量就是从外往内的权值最大的边的边权，即周围最高的一圈“墙”）。

![](https://cdn.luogu.com.cn/upload/image_hosting/qg5fm0ef.png)

### 总结

1. **构建虚拟点**，连接到外圈的所有点。
2. **连接相邻点**，边权为 $max(h_i, h_j)$。
3. **使用最小生成树**，计算每个点的水存储量。

{% note red fa-star %}
__难点__：1.建图思路；2.计算储水量的思路。
{% endnote %}

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1001, M = 1001;

int n, m, a[N][M], node[N][M];
int cnt = 0;   //点数
int tot = 0;   //l的索引
int mv[4][2] = {{0,1},{0,-1},{1,0},{-1,0}};

//链式前向星
struct Edge {
    int u, v, w, nxt;
} l[N*M*2], l1[N*M*2];  
//l1存储最小生成树用，l记录边
int h[N*M], tot1 = 0;   //l1的索引

//求最小生成树时的初次建图
void Link(int u, int v, int w) {
    l[++tot] = {u, v, w };  //最小生成树没有邻接边的遍历需要
}

//最小生成树存图
bool Cmp(Edge a, Edge b) {  //最小生成树的排序
    return a.w < b.w;
}
void AddEdge(int u, int v, int w) {
    l1[++tot1] = {u, v, w, h[u]}; h[u] = tot1;
}

//并查集
int fa[N*N];
int Find(int x) { return x == fa[x] ? x : fa[x] = Find(fa[x]); }
void Merge(int x, int y) { fa[Find(x)] = Find(y); }

//Kruskal
int Kruskal() {
    sort(l + 1, l + tot + 1, Cmp);
    int nodeCnt = 0, wSum = 0;
    for(int i = 1; i <= tot; i++) {
        if(Find(l[i].u) != Find(l[i].v)) {//两点不连通
            nodeCnt++, wSum += l[i].w;       //累加
            Merge(l[i].u, l[i].v);        //合并（连通了）
            //存最小生成树
            AddEdge(l[i].u, l[i].v, l[i].w);
            AddEdge(l[i].v, l[i].u, l[i].w);
        }
        if(nodeCnt == cnt - 1) {
            break;             //终止条件
        }
    }
    return wSum;
}

//深搜计算水深
int height[N] = {};
void Dfs(int u, int father) {
    for(int i = h[u]; i; i = l1[i].nxt) {
        int v = l1[i].v;
        if(v == father) continue;   //又通过反向边返回了
        height[v] = max(height[u], l1[i].w); //计算权值最大的边
        Dfs(v, u);
    }
}

int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++) {
            cin >> a[i][j];
            node[i][j] = ++cnt; //给点编号
            fa[cnt] = cnt;      //并查集初始化
        }
    }
    //将虚拟点(cnt+1)与外围点连边
    for(int i = 1; i <= m; i++) {       //每列第一行
        Link(cnt + 1, node[1][i], max(0, a[1][i]));
        Link(cnt + 1, node[n][i], max(0, a[n][i]));
    }
    for(int i = 1; i <= n; i++) {       //每行第一列
        Link(cnt + 1, node[i][1], max(0, a[i][1]));
        Link(cnt + 1, node[i][m], max(0, a[i][m]));
    }

    //每个点向四周连边
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++) {
            for(int k = 0; k < 4; k++) {
                int x = i + mv[k][0];
                int y = j + mv[k][1];
                if(x < 1 || x > n) continue;
                if(y < 1 || y > m) continue;
                Link(node[i][j], node[x][y], max(a[i][j], a[x][y]));
            }
        }
    }
    Kruskal();
    //遍历最小生成树，找到每个节点的路径最大值
    Dfs(cnt + 1, cnt + 1);  //从虚拟节点开始找
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++) {
            if(height[node[i][j]] <= a[i][j]) { //不能存水
                cout << "0 ";
            } else cout << height[node[i][j]] - a[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
```