---
title: 提高第三天（深搜与回溯）
date: 2024-05-21 13:13:25
categories: 
  - [CSP,CSP-S,课程]
  - [算法,搜索,深搜]
tags:
---

# 知识点-回溯算法
## 原因
```
1.无论么型的题目，只要能够建立对应的数学模型，我们就可以使用对应的算法模板去求解。
动态规划-01背包问题
2.并不是所有的问题都有数学模型，即便有了模型，但是也没有现成的算法可以使用，在此情况下往往需要校举：所有的情况，从中查找问题的解。
枚举：暴力枚举法
```
## 介绍
```
回溯：回测法是搜索算法的一种控制策略，它从初始状态出发，根据题目给出的条件、规则，按照深度优先搜索的顺序扩展所有可能的结果，从中找出问题的解，
常用题型：计数型问题 复杂枚举问题
```
## 伪代码
```c++
void function(当前状态){
    if(当前状态是否是边界) {
        对查找到的结果做处理
        return; //回溯1
    }
    for(下一步所有可能的情况) {
        计算出子状态
        if(子状态满足约束条件&&子状态满足最优性要求){
            标记
            function(子状态)
            清空标记 //回溯2
        }
    }
```

# 习题1-全排列 [基础] [搜索/回溯]
## 题目描述
求1~N的全排列
## 输入
一行，一个正整数N
## 输出
多行，每行一个1~N的排列方式
## 样例
### 样例输入 #1
```
3
```
### 样例输出 #1
```
123
132
213
231
312
321
```

## 题解
### 思路
写一个搜索函数
```c++
void dfs(int x);    //x表示当前填充第x位
```
然后套模板，填充时枚举每一个没有被填充过的数，填充进去后搜索下一位，然后回溯回来再尝试下一个数，填完了就输出
### AC代码
```c++
#include <iostream>
using namespace std;
int n, a[10], b[10];    //b表示是否被使用过，a表示一种排列方式
void dfs(int x) {   //当前填充第x位
    if(x == n + 1) {    //填完了，输出
        for(int i = 1; i <= n; i++){ 
            cout << a[i];
        }
        cout << endl;
        return; //回溯1
    }
    for(int i = 1; i <= n; i++) {   //枚举下一步可能的情况
        if(!b[i]) {
            a[x] = i;   //填数
            b[i] = 1;   //标记
            dfs(x + 1); //搜索下一位         
            //回溯
            a[x] = 0;
            b[i] = 0;   
        }
    }
}

int main() {
    cin >> n;
    dfs(1); //从第一位开始填
    return 0;
}
```

# 习题1变式-全排列升级版

## 题目描述

求1~N的全排列

## 输入

一行，一个正整数N

## 输出

见样例

## 样例

### 样例输入 #1
```
3
```

### 样例输出 #1
```
1
12
123
13
132
2
21
213
23
231
3
31
312
32
321
```

## 题解

### 思路
写一个搜索函数
```c++
void dfs(int x);    //x表示当前填充第x位
```
然后套模板，填充时枚举每一个没有被填充过的数，填充进去后搜索下一位，然后回溯回来再尝试下一个数，每填充一个输出填充过的所有位数

### AC代码
```c++
#include <iostream>
using namespace std;
int n, a[10], b[10];    //b表示是否被使用过，a表示一种排列方式
void dfs(int x) {   //当前填充第x位
    if(x > 1) {    //填过一位就输出
        for(int i = 1; i < x; i++){ 
            cout << a[i];
        }
        cout << endl;
    }
    for(int i = 1; i <= n; i++) {   //枚举下一步可能的情况
        if(!b[i]) {
            a[x] = i;   //填数
            b[i] = 1;   //标记
            dfs(x + 1); //搜索下一位         
            //回溯
            a[x] = 0;
            b[i] = 0;   
        }
    }
}

int main() {
    cin >> n;
    dfs(1); //从第一位开始填
    return 0;
}
```

# 习题1变式2-全排列(填数版)

## 题目描述

有N个数，求N个数的全排列，并且去重

## 输入

第一行，一个正整数N
第二行，N个正整数

## 输出

多行，每行一个N个数的排列方式

## 样例

### 样例输入 #1
```
3
1 1 2
```

### 样例输出 #1
```
1 1 2
1 2 1
2 1 1
```

## 题解

### 思路
还是套模板，设计一个函数
```c++
void dfs(int x);    //填第x个数
```
函数中，将枚举1~n变为枚举数组的下标i，同时判断[x, i)中有没有和i相等的数，如果有，不交换，否则交换（使第i个数在递归过程中一位位地交换，实现了去重）。

### AC代码
```c++
#include <iostream>
using namespace std;

int n, a[10]/*n个数*/;

//判断第x个数和第y个数是否需要交换，要求[x,y)中没有与第y个数字相等的数字
bool isSwap(int x, int y) {
    for(int i = x; i < y; i++) 
        if(a[i] == a[y]) return false;
    return true;
}
void dfs(int x) {
    if(x == n - 1) {
        for(int i = 0; i < n; i++) {
            cout << a[i] << " ";
        }
        cout << endl;
        return ;
    }
    for(int i = x; i < n; i++) {
        if(isSwap(x, i)) {
            swap(a[x], a[i]);
            dfs(x + 1);
            swap(a[x], a[i]);
        }
    }
}

int main() {
    cin >> n;
    for(int i = 0; i < n; i++) cin >> a[i];
    dfs(0);
    return 0;
}
```

# 习题2-因式分解

## 题目描述

对于一个正整数N，求所有的因子相乘的情况。（从大到小）

## 样例

### 样例输入 #1
```
4
```
### 样例输出 #1
```
4=4*1
4=2*2*1
```

## 题解
写一个函数
```c++
void dfs(int x);    //x被分解
```
当x=1时(即1被分解)，就输出；
其他情况时，枚举所有因数，然后将x除以因数后的数继续分解，知道x=1为止，然后回溯
### 思路

### AC代码
```c++
#include <iostream>
using namespace std;

int a[101], n, sum = 1;

void dfs(int x) {   //x被分解
    if(x) { //只有因数1了
        a[sum] = 1;
        cout << n << "=";
        for(int i = 1; i < sum; i++) cout << a[i] << "*";   //输出
        cout << a[sum] << endl;
        return ;        //回溯1
    } 
    for(int i = x; i > 1; i--) {
        if(x % i == 0) {    //i是x的因子
            a[sum] = i; //存储
            sum++;  
            dfs(x / i); //将x / i作为下一个被分解的数
            //回溯2
            a[sum] = 0;
            sum--;
        }
    }
}
int main() {
    cin >> n;
    dfs(n);
    return 0;
}
```

# 习题3-数的划分

## 描述
将正整数n分成k份，且每份不为空，每个方案互不相同。问有多少种不同分法。

## 提示

一、n = 7, k = 3时: 1,1,5; 1,5,1; 5,1,1.三种情况被认为是相同的

二、6 < n <=200, 2 <= k <= 6

## 样例

### 样例输入 #1
```
7 3
```

### 样例输出 #1
```
4
```
## 题解
### AC代码
```c++
#include <iostream>
using namespace std;

int n, k, ans;

void dfs(int start, int s, int t) { //最小值为start，将s分为t份
    if(t == 1) {    //分完了
        ans++;
        return;
    }
    for(int i = start; i <= s / t; i++) {   //枚举所有的可能（同时去重）
        dfs(i, s - i, t - 1);   //再搜一位
        //不需要回溯
    }
}

int main() {
    cin >> n >> k;
    dfs(1, n, k);   //最小值是1，将n分为k份
    cout << ans;
    return 0;
}
```

