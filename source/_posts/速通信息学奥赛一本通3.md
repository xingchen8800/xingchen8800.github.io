---
title: 速通信息学奥赛一本通（三）
date: 2024-10-19 10:30:12
tags: 
    - CSP入门组
    - C++
---

# 贪心算法

{% note blue fa-lightbulb%}
__提示__： 贪心算法的习题部分采用《算法竞赛》中的习题。
{% endnote %}

## [1455. An Easy Problem](http://noi.openjudge.cn/ch0406/1455/)

### 描述
众所周知，存储在计算机中的数据是二进制形式的。我们现在讨论的问题是关于正整及其二进制形式的。

给定一个正整数 $i$，您的任务是找出一个大于 $i$ 的最小值 $j$，并且 $j$ 的二进制形式与 $i$ 的二进制形式相同数量的`1`。

例如，如果给出 $78$ ，我们可以写出它的二进制形式`1001110`。这种二进制形式有 $4$ 个`1`，大于`1001110`且还包含 $4$ 个`1`的最小值是 `1010011`，即 $83$ ，因此您应该输出`83`。
### 输入

每行一个正整数 $i (1 \leq i \leq 1000000)$.

当 $i = 0$ 时，代表输入结束。

### 输出

每行一个正整数 $j$，如题意所示。

### 样例输入
```
1
2
3
4
78
0
```

### 样例输出
```
2
4
5
8
83
```

### 题解
{% folding green::答案%}
思路：枚举，直到二进制中 `1` 的数量与原数相等

[点我下载C++文件](https://xingchen8800.github.io/cppcode/速通信息学奥赛一本通3/1455.cpp "下载")

```c++
#include <bits/stdc++.h>
using namespace std;

int getOneNum(int x) {      //获取x中1的数量
	int num = 0;            
	while(x) {
		num += (x % 2 == 1);//拆分成二进制数
		x /= 2;
	}
	return num;
}

int main() {
	int i;

    while(cin >> i && i != 0) {
        int num = getOneNum(i++);
        for(;getOneNum(i) != num; i++);
        cout << i << endl; 
	}
	return 0;
}
```
{% endfolding %}

## [hdu2037. 今年暑假不AC](https://acm.hdu.edu.cn/showproblem.php?pid=2037)

### 问题描述

> “今年暑假不AC？”
>
> “是的。”
>
> “那你干什么呢？”
>
> “看世界杯呀，笨蛋！”
> 
> “@#$%^&*%...”

确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。

作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）
 
### 输入格式
输入数据包含多个测试实例，每个测试实例的第一行只有一个整数 $n(n \leq 100)$，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据 $T_{i_s},T_{i_e} (1 \leq i \leq n)$，分别表示第 $i$ 个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。$n=0$ 表示输入结束，不做处理。
 
### 输出格式
对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。
 
### 输入样例
```
12
1 3
3 4
0 7
3 8
15 19
15 20
10 15
8 18
6 12
5 10
4 14
2 9
0
``` 

### 输出样例
```
5
```

### 题解

{% folding green::答案 %}
由于要选最多的节目，所以考虑将右端点从小到大排序（前一个为后一个空出尽可能大的区间），然后模拟：


- 当上一个的结束时间在这个节目之前，可以看的节目加一
- 否则这个节目不能看

[点我下载C++文件](https://xingchen8800.github.io/cppcode/速通信息学奥赛一本通3/hdu2037.cpp "下载")

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>
using namespace std;

vector< pair<int, int> > line;

bool cmp(pair<int, int>& a, pair<int, int>& b) {
    return a.second < b.second;
}

int main() {
    int n;
    while (cin >> n && n != 0) {
        line.clear();
        for (int i = 1; i <= n; i++) {
            int x, y;
            cin >> x >> y;
            line.push_back({x, y});	
        }
        
        sort(line.begin(), line.end(), cmp);
        
        int x = line.begin()->second, sum = 1;    // x记录上个节目的结束时间
        for (auto i : line) {
            if (x <= i.first) {  // 当上一个的结束时间在这个节目之前，可以看的节目加一
                sum++;
                x = i.second; 
            }
        }
        cout << sum << endl;
    }
    return 0;
}
```
{% endfolding %}

## [hdu1338. 比赛预测](https://acm.hdu.edu.cn/showproblem.php?pid=1338) 

### 问题描述
假设有 $M$ 个人（包括你），在玩一个特殊的纸牌游戏。开始时，每个玩家都会收到 $N$ 张牌。一张牌的点是一个正整数，最多是 $N \cdot M$。而且没有两张牌具有相同的点。在一轮比赛中，每个玩家选择一张牌与其他人的牌进行比较。牌点最大的玩家赢得该轮，然后下一轮开始。 $N$ 轮后，当每位玩家的所有牌都被选中时，赢得最多回合的玩家就是游戏的赢家。

根据你在开始时收到的牌，编写一个程序来告诉你在整个游戏中你至少可以赢得的最大回合数。
 
### 输入
输入由多个测试用例组成。每种情况的第一行包含两个整数 $m (2 \leq m \leq 20)$ 和 $n (1 \leq n \leq 50)$，分别代表玩家人数和每个玩家在游戏开始时收到的牌数。后面是一行 $n$ 个正整数，代表您开始时收到的牌的点数。然后，空行将两个样例分隔开来。

输入由带有两个 $0$ 的行终止。
 
### 输出
对于每个测试用例，输出一行，该行由测试用例编号和您在游戏中至少赢得的回合数组成。
 

### 输入样例
```
2 5
1 7 2 10 9

6 11
62 63 54 66 65 61 57 56 50 53 48

0 0
```

### 输出样例
```
Case 1: 2
Case 2: 4
```

### 题解

{% folding green::答案 %}

这道题目可以使用贪心算法来解决。我们的目标是 __最大化自己赢得的回合数__。以下是解题思路：

1. 首先，我们需要记录自己拥有的牌。
2. 然后，从最大的点数开始，依次向下遍历所有可能的点数。
3. 对于每个点数，我们有两种情况：
   - 如果这个点数的牌是我们的，我们就看是否能赢得这一轮。
   - 如果这个点数的牌是对手的，我们就记录下来，因为它可能会在之后的某一轮击败我们的牌。

具体实现如下：

[点我下载C++文件](https://xingchen8800.github.io/cppcode/速通信息学奥赛一本通3/hdu1338.cpp "下载")

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

int card[1001];
bool isMine[1001] = {false};

int main() {
    int caseCnt = 0, m, n;
    while(cin >> m >> n) {
        memset(isMine, false, sizeof isMine);
        if(m == 0 && n == 0) break;
        caseCnt++;
        for(int i = 1; i <= n; i++) {
            scanf("%d", &card[i]);
            isMine[card[i]] = true;
        }
        int winCnt = 0, biggerCard = 0;
        for(int i = n * m; i >= 1; i--) {
            if(isMine[i]) {
                if(biggerCard == 0) winCnt++;   //别人没有比“我”当前卡牌大的卡，“我”赢
                else biggerCard--;              //用别人的比“我”当前卡牌大的卡打“我”的卡 
            } else biggerCard++;    //是别人的卡
        }
        printf("Case %d: %d\n", caseCnt, winCnt);
    }
    return 0;
}
```
{% endfolding %}