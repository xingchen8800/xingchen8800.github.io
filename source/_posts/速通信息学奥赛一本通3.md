---
title: 速通信息学奥赛一本通（三）
date: 2024-10-19 10:30:12
tags: 
    - CSP入门组
    - C++
---

# 贪心算法

{% note blue fa-lightbulb%}
__提示__： 贪心算法的习题部分采用《算法竞赛》中的习题。
{% endnote %}

## [1455. An Easy Problem](http://noi.openjudge.cn/ch0406/1455/)

### 描述
众所周知，存储在计算机中的数据是二进制形式的。我们现在讨论的问题是关于正整及其二进制形式的。

给定一个正整数 $i$，您的任务是找出一个大于 $i$ 的最小值 $j$，并且 $j$ 的二进制形式与 $i$ 的二进制形式相同数量的`1`。

例如，如果给出 $78$ ，我们可以写出它的二进制形式`1001110`。这种二进制形式有 $4$ 个`1`，大于`1001110`且还包含 $4$ 个`1`的最小值是 `1010011`，即 $83$ ，因此您应该输出`83`。
### 输入

每行一个正整数 $i (1 \leq i \leq 1000000)$.

当 $i = 0$ 时，代表输入结束。

### 输出

每行一个正整数 $j$，如题意所示。

### 样例输入
```
1
2
3
4
78
0
```

### 样例输出
```
2
4
5
8
83
```

### 题解
{% folding green::答案%}
思路：枚举，直到二进制中 `1` 的数量与原数相等

[点我下载C++文件](/cppcode/速通信息学奥赛一本通3/1455.cpp "下载")

```c++
#include <bits/stdc++.h>
using namespace std;

int getOneNum(int x) {      //获取x中1的数量
	int num = 0;            
	while(x) {
		num += (x % 2 == 1);//拆分成二进制数
		x /= 2;
	}
	return num;
}

int main() {
	int i;

    while(cin >> i && i != 0) {
        int num = getOneNum(i++);
        for(;getOneNum(i) != num; i++);
        cout << i << endl; 
	}
	return 0;
}
```
{% endfolding %}

## [hdu2037. 今年暑假不AC](https://acm.hdu.edu.cn/showproblem.php?pid=2037)

### 问题描述

> “今年暑假不AC？”
>
> “是的。”
>
> “那你干什么呢？”
>
> “看世界杯呀，笨蛋！”
> 
> “@#$%^&*%...”

确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。

作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目）
 
### 输入格式
输入数据包含多个测试实例，每个测试实例的第一行只有一个整数 $n(n \leq 100)$，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据 $T_{i_s},T_{i_e} (1 \leq i \leq n)$，分别表示第 $i$ 个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。$n=0$ 表示输入结束，不做处理。
 
### 输出格式
对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。
 
### 输入样例
```
12
1 3
3 4
0 7
3 8
15 19
15 20
10 15
8 18
6 12
5 10
4 14
2 9
0
``` 

### 输出样例
```
5
```

### 题解

{% folding green::答案 %}
由于要选最多的节目，所以考虑将右端点从小到大排序（前一个为后一个空出尽可能大的区间），然后模拟：


- 当上一个的结束时间在这个节目之前，可以看的节目加一
- 否则这个节目不能看

[点我下载C++文件](/cppcode/速通信息学奥赛一本通3/hdu2037.cpp "下载")

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <utility>
using namespace std;

vector< pair<int, int> > line;

bool cmp(pair<int, int>& a, pair<int, int>& b) {
    return a.second < b.second;
}

int main() {
    int n;
    while (cin >> n && n != 0) {
        line.clear();
        for (int i = 1; i <= n; i++) {
            int x, y;
            cin >> x >> y;
            line.push_back({x, y});	
        }
        
        sort(line.begin(), line.end(), cmp);
        
        int x = line.begin()->second, sum = 1;    // x记录上个节目的结束时间
        for (auto i : line) {
            if (x <= i.first) {  // 当上一个的结束时间在这个节目之前，可以看的节目加一
                sum++;
                x = i.second; 
            }
        }
        cout << sum << endl;
    }
    return 0;
}
```
{% endfolding %}

## [hdu1338. 比赛预测](https://acm.hdu.edu.cn/showproblem.php?pid=1338) 

### 问题描述
假设有 $M$ 个人（包括你），在玩一个特殊的纸牌游戏。开始时，每个玩家都会收到 $N$ 张牌。一张牌的点是一个正整数，最多是 $N \cdot M$。而且没有两张牌具有相同的点。在一轮比赛中，每个玩家选择一张牌与其他人的牌进行比较。牌点最大的玩家赢得该轮，然后下一轮开始。 $N$ 轮后，当每位玩家的所有牌都被选中时，赢得最多回合的玩家就是游戏的赢家。

根据你在开始时收到的牌，编写一个程序来告诉你在整个游戏中你至少可以赢得的最大回合数。
 
### 输入
输入由多个测试用例组成。每种情况的第一行包含两个整数 $m (2 \leq m \leq 20)$ 和 $n (1 \leq n \leq 50)$，分别代表玩家人数和每个玩家在游戏开始时收到的牌数。后面是一行 $n$ 个正整数，代表您开始时收到的牌的点数。然后，空行将两个样例分隔开来。

输入由带有两个 $0$ 的行终止。
 
### 输出
对于每个测试用例，输出一行，该行由测试用例编号和您在游戏中至少赢得的回合数组成。
 

### 输入样例
```
2 5
1 7 2 10 9

6 11
62 63 54 66 65 61 57 56 50 53 48

0 0
```

### 输出样例
```
Case 1: 2
Case 2: 4
```

### 题解

{% folding green::答案 %}

这道题目可以使用贪心算法来解决。我们的目标是 __最大化自己赢得的回合数__。以下是解题思路：

1. 首先，我们需要记录自己拥有的牌。
2. 然后，从最大的点数开始，依次向下遍历所有可能的点数。
3. 对于每个点数，我们有两种情况：
   - 如果这个点数的牌是我们的，我们就看是否能赢得这一轮。
   - 如果这个点数的牌是对手的，我们就记录下来，因为它可能会在之后的某一轮击败我们的牌。

具体实现如下：

[点我下载C++文件](/cppcode/速通信息学奥赛一本通3/hdu1338.cpp "下载")

```c++
#include <iostream>
#include <cstdio>
#include <cstring>
using namespace std;

int card[1001];
bool isMine[1001] = {false};

int main() {
    int caseCnt = 0, m, n;
    while(cin >> m >> n) {
        memset(isMine, false, sizeof isMine);
        if(m == 0 && n == 0) break;
        caseCnt++;
        for(int i = 1; i <= n; i++) {
            scanf("%d", &card[i]);
            isMine[card[i]] = true;
        }
        int winCnt = 0, biggerCard = 0;
        for(int i = n * m; i >= 1; i--) {
            if(isMine[i]) {
                if(biggerCard == 0) winCnt++;   //别人没有比“我”当前卡牌大的卡，“我”赢
                else biggerCard--;              //用别人的比“我”当前卡牌大的卡打“我”的卡 
            } else biggerCard++;    //是别人的卡
        }
        printf("Case %d: %d\n", caseCnt, winCnt);
    }
    return 0;
}
```
{% endfolding %}

## [hdu1789. Doing Homework again](https://acm.hdu.edu.cn/showproblem.php?pid=1789)

### 题目描述
Ignatius刚刚从第30届ASM/ICPC返校。现在他有很多功课要做。每个老师都给他规定了交作业的期限。如果伊格内修斯在截止日期后交作业，老师将降低他期末考试的成绩。现在我们假设给每个人做每个作业总是需要一天的时间。所以Ignatius希望你帮助他安排好做作业的顺序，以尽量减少减少分数。
 
### 输入描述
输入包含多个测试用例。输入的第一行是一个单一的整数 $T$，即测试用例的数量。$T$ 个测试用例如下：

每个测试案例都以正整数 $N（1 \leq N \leq 1000)$ 开始，表示作业数量。随后 $2$ 行。第一行包含 $N$ 个数字，表示科目的截止日期，下一行包含 $N$ 个数字，表示降低的分数。
 
### 输出描述
对于每个测试用例，你应该输出一行，包含一个整数，表示最小的期末考试扣分。 

### 输入样例
```
3
3
3 3 3
10 5 1
3
1 3 1
6 2 3
7
1 4 6 4 2 4 3
3 2 1 7 6 5 4
``` 

### 输出样例
```
0
3
5 
```
 
### 题解

我们肯定希望从扣分高的、结束时间早的开始做，这样才能使扣得分最少。所以，我们要对每个作业进行排序，排序规则为：

- 分数相同的，结束日期考前的排在前面
- 否则分数高得排在前面。

这样，模拟一下做作业（注意：做每个作业的时候尽可能拖迟完成，才能为结束时间更早的作业留出空位）即可。

```c++
#include <bits/stdc++.h>
using namespace std;

struct Node {
    int dat, scr;
} hmwk[1001];
bool isUsed[1001] = {false}; 
int t, n;

int main() {
    cin >> t;
    while(t--) {
        cin >> n;
        for(int i = 1; i <= n; i++) cin >> hmwk[i].dat;
        for(int i = 1; i <= n; i++) cin >> hmwk[i].scr;
        sort(hmwk + 1, hmwk + 1 + n, [=](Node &a, Node &b) {
            if(a.scr == b.scr) return a.dat < b.dat;
            return a.scr > b.scr;
        });     //贪心：排序
        memset(isUsed, false, sizeof isUsed);
        int scr = 0;                //扣分
        for(int i = 1; i <= n; i++) {
            int j;
            for(j = hmwk[i].dat; j > 0; j--) {  //贪心：从结束日期开始，找到离结束日期最近的空闲天做掉i
                if(!isUsed[j]) {isUsed[j] = true; break;}
            }
            if(!j) scr += hmwk[i].scr;  //没有空闲的，只能扣分
        }
        cout << scr << endl;
    }
    return 0;
}
```

## [hdu4310. Hero](https://acm.hdu.edu.cn/showproblem.php?pid=4310)

### 问题描述

在与神一样的对手和猪一样的队员一起玩DotA时，你不得不面对一个尴尬的局面：你的队友都被杀了，你不得不与 1vN 战斗。

游戏中的英雄有两个关键属性，生命值 （$\mathsf{HP}$） 和每次射击伤害 （$\mathsf{DPS}$）。你的英雄有几乎无限的 $\mathsf{HP}$，但只有 $1 \mathsf{DPS}$。

为了简化问题，我们假设游戏是回合制的，但不是实时的。在每个回合中，你可以选择一个敌方英雄进行攻击，他的 $\mathsf{HP}$ 会减少 $1$。同时，所有活着的敌方英雄都会攻击你，你的 $\mathsf{HP}$ 会减少他们的 $\mathsf{DPS}$ 之和。如果一个英雄的生命值等于（或低于）零，他将在这一轮后死亡，并且在接下来的轮次中无法攻击你。

虽然你的英雄不败，但你想选择最好的策略，以最小的 $\mathsf{HP}$ 损失杀死所有敌方英雄。
 

### 输入格式
每个测试用例的第一行包含敌方英雄的数量  $N (1 \leq N \leq 20)$。然后是 $N$ 行，每行包含两个整数 $\mathsf{DPS}_i$ 和 $\mathsf{HP}_i$，它们是每个英雄的 $\mathsf{DPS}$ 和 $\mathsf{HP}$。$（1 \leq \mathsf{DPS_i}，\mathsf{HP}_i \leq 1000）$
 

### 输出格式
每次测试输出一行，表示最小 $\mathsf{HP}$ 损失。
 
### 样例输入
```
1
10 2
2
100 1
1 100
``` 

### 样例输出
```
20
201
```

### 题解

我们要扣的血最少，就要先打 __伤害高、血量低__ 的，让其对“我”的伤害 __最小化__。

```c++
#include <bits/stdc++.h>
using namespace std;

struct Hero {
    int dps, hp;
    double t;
};
vector<Hero> hero;

int main() {
    int n;
    while(cin >> n) {
        hero.clear();
        for(int i = 1; i <= n; i++) {
            int dps, hp;
            cin >> dps >> hp;
            hero.push_back({dps, hp, dps * 1.0 / hp});
        }
        sort(hero.begin(), hero.end(), [=](Hero &a, Hero &b) {
            return a.t > b.t;
        });
        int hp = 0, d = 0;
        for(vector<Hero>::iterator i = hero.begin(); i != hero.end(); i++) {
            d = d+ i->hp;          //打死i要hp天
            hp = hp + i->dps * d;    //i存活了d天
        }
        cout << hp << endl;
    }
    return 0;
}
```

## 亚伦森

### 问题描述
最近，Peter 看到了方程式 $x_0+2x_1+4x_2+\ldots+2^mx_m=n$。他想找到解($x_0,x_1,x_2,\ldots,x_m)$ 之和 （$\sum_{i=0}^m{x_i}$）的最小值，并且$x_i (0≤i≤m)$ 为非负数。
 

### 输入格式
有多个测试用例。输入的第一行包含一个整数 $T (1≤T≤105)$，指示测试用例的数量。对于每个测试用例：

第一个包含两个整数 $n$ 和 $m$ $(0≤n，m≤109)$。
 

### 输出
对于每个测试用例，输出 $\sum_{i=0}^m{x_i}$ 的最小值。
 

### 样例输入
```
10
1 2
3 2
5 2
10 2
10 3
10 4
13 5
20 4
11 11
12 3
``` 

### 样例输出
```
1
2
2
3
2
2
3
2
3
2
```

# [动态规划（Dynamic Programming）](/2024/CSP-J%EF%BC%9A%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/)