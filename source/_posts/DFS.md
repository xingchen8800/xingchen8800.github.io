---
title: DFS
date: 2024-05-24 19:41:30
tags:
categories:
- 普及组
- 搜索
    - 深搜
---

# T1. [烤鸡](https://www.luogu.com.cn/problem/P2089)

## 题目背景

猪猪 Hanke 得到了一只鸡。

## 题目描述

猪猪 Hanke 特别喜欢吃烤鸡（本是同畜牲，相煎何太急！）Hanke 吃鸡很特别，为什么特别呢？因为他有 $10$ 种配料（芥末、孜然等），每种配料可以放 $1$ 到 $3$ 克，任意烤鸡的美味程度为所有配料质量之和。

现在， Hanke 想要知道，如果给你一个美味程度 $n$ ，请输出这 $10$ 种配料的所有搭配方案。

## 输入格式

一个正整数 $n$，表示美味程度。

## 输出格式

第一行，方案总数。

第二行至结束，$10$ 个数，表示每种配料所放的质量，按字典序排列。

如果没有符合要求的方法，就只要在第一行输出一个 $0$。

## 样例 #1

### 样例输入 #1

```
11
```

### 样例输出 #1

```
10
1 1 1 1 1 1 1 1 1 2 
1 1 1 1 1 1 1 1 2 1 
1 1 1 1 1 1 1 2 1 1 
1 1 1 1 1 1 2 1 1 1 
1 1 1 1 1 2 1 1 1 1 
1 1 1 1 2 1 1 1 1 1 
1 1 1 2 1 1 1 1 1 1 
1 1 2 1 1 1 1 1 1 1 
1 2 1 1 1 1 1 1 1 1 
2 1 1 1 1 1 1 1 1 1
```

## 提示

对于 $100\%$ 的数据，$n \leq 5000$。

## 题解
### 思路
 __本质上就是个限大小的全排列！！！__
由题意知：枚举每种调料的克数(1~3)即可。写一个形如如下的dfs搜索函数
```c++
void dfs(int x, int sum);   //x是当前的调料名称，sum表示当前已经有多少克调料
```
当sum满足sum = n的条件时：存储当前的排列

当sum大于n时，直接回溯即可（剪枝操作）

其他情况：枚举1~3克的克数放到第x位上即可

### AC代码
```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 21;
int n;  //美味程度
int arr[N]; //存方案
int ans = 0;//方案数
int fa[59055][N];   //方案明细

void dfs(int x, int sum) {
    if(sum > n) return ;    //剪枝操作
    if(x > 10) {    //填满了
        if(sum == n) {  //符合条件，存储
            ans++;
            for(int i = 1; i <= n; i++) {
                fa[ans][i] = arr[i];
            }
        }
        return; //回溯
    }
    for(int i = 1; i <= 3; i++) {
        arr[x] = i; //假设存储
        dfs(x + 1, sum + i);    //下一步
        arr[x] = 0; //回溯
    }
}

int main() {
    cin >> n;
    dfs(1, 0);  //从第一位，0美味程度开始dfs
    //输出
    cout << ans << endl;
    for(int i = 1; i <= ans; i++) {
        for(int j = 1; j <= 10; j++) {
            cout << fa[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
```