---
title: DFS
date: 2024-05-24 19:41:30
tags:
categories:
- 普及组
- [搜索,深搜]
---

# T1. [烤鸡](https://www.luogu.com.cn/problem/P2089)

## 题目背景

猪猪 Hanke 得到了一只鸡。

## 题目描述

猪猪 Hanke 特别喜欢吃烤鸡（本是同畜牲，相煎何太急！）Hanke 吃鸡很特别，为什么特别呢？因为他有 $10$ 种配料（芥末、孜然等），每种配料可以放 $1$ 到 $3$ 克，任意烤鸡的美味程度为所有配料质量之和。

现在， Hanke 想要知道，如果给你一个美味程度 $n$ ，请输出这 $10$ 种配料的所有搭配方案。

## 输入格式

一个正整数 $n$，表示美味程度。

## 输出格式

第一行，方案总数。

第二行至结束，$10$ 个数，表示每种配料所放的质量，按字典序排列。

如果没有符合要求的方法，就只要在第一行输出一个 $0$。

## 样例 #1

### 样例输入 #1

```
11
```

### 样例输出 #1

```
10
1 1 1 1 1 1 1 1 1 2 
1 1 1 1 1 1 1 1 2 1 
1 1 1 1 1 1 1 2 1 1 
1 1 1 1 1 1 2 1 1 1 
1 1 1 1 1 2 1 1 1 1 
1 1 1 1 2 1 1 1 1 1 
1 1 1 2 1 1 1 1 1 1 
1 1 2 1 1 1 1 1 1 1 
1 2 1 1 1 1 1 1 1 1 
2 1 1 1 1 1 1 1 1 1
```

## 提示

对于 $100\%$ 的数据，$n \leq 5000$。

## 题解
### 思路
 __本质上就是个限大小的全排列！！！__
由题意知：枚举每种调料的克数(1~3)即可。写一个形如如下的dfs搜索函数
```c++
void dfs(int x, int sum);   //x是当前的调料名称，sum表示当前已经有多少克调料
```
当sum满足sum = n的条件时：存储当前的排列

当sum大于n时，直接回溯即可（剪枝操作）

其他情况：枚举1~3克的克数放到第x位上即可

### AC代码
```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 21;
int n;  //美味程度
int arr[N]; //存方案
int ans = 0;//方案数
int fa[59055][N];   //方案明细

void dfs(int x, int sum) {
    if(sum > n) return ;    //剪枝操作
    if(x > 10) {    //填满了
        if(sum == n) {  //符合条件，存储
            ans++;
            for(int i = 1; i <= n; i++) {
                fa[ans][i] = arr[i];
            }
        }
        return; //回溯
    }
    for(int i = 1; i <= 3; i++) {
        arr[x] = i; //假设存储
        dfs(x + 1, sum + i);    //下一步
        arr[x] = 0; //回溯
    }
}

int main() {
    cin >> n;
    dfs(1, 0);  //从第一位，0美味程度开始dfs
    //输出
    cout << ans << endl;
    for(int i = 1; i <= ans; i++) {
        for(int j = 1; j <= 10; j++) {
            cout << fa[i][j] << " ";
        }
        cout << endl;
    }
    return 0;
}
```

# T2. [[NOIP2004 普及组] 火星人](https://www.luogu.com.cn/problem/P1088)

## 题目描述

人类终于登上了火星的土地并且见到了神秘的火星人。人类和火星人都无法理解对方的语言，但是我们的科学家发明了一种用数字交流的方法。这种交流方法是这样的，首先，火星人把一个非常大的数字告诉人类科学家，科学家破解这个数字的含义后，再把一个很小的数字加到这个大数上面，把结果告诉火星人，作为人类的回答。

火星人用一种非常简单的方式来表示数字――掰手指。火星人只有一只手，但这只手上有成千上万的手指，这些手指排成一列，分别编号为 $1,2,3,\cdots$。火星人的任意两根手指都能随意交换位置，他们就是通过这方法计数的。

一个火星人用一个人类的手演示了如何用手指计数。如果把五根手指――拇指、食指、中指、无名指和小指分别编号为 $1,2,3,4$ 和 $5$，当它们按正常顺序排列时，形成了 $5$ 位数 $12345$，当你交换无名指和小指的位置时，会形成 $5$ 位数 $12354$，当你把五个手指的顺序完全颠倒时，会形成 $54321$，在所有能够形成的 $120$ 个 $5$ 位数中，$12345$ 最小，它表示 $1$；$12354$ 第二小，它表示 $2$；$54321$ 最大，它表示 $120$。下表展示了只有 $3$ 根手指时能够形成的 $6$ 个 $3$ 位数和它们代表的数字：


| 三进制数 | 代表的数字 |
|:-:|:-:|
| $123$ | $1$ |
| $132$ | $2$ |
| $213$ | $3$ |
| $231$ | $4$ |
| $312$ | $5$ |
| $321$ | $6$ |

现在你有幸成为了第一个和火星人交流的地球人。一个火星人会让你看他的手指，科学家会告诉你要加上去的很小的数。你的任务是，把火星人用手指表示的数与科学家告诉你的数相加，并根据相加的结果改变火星人手指的排列顺序。输入数据保证这个结果不会超出火星人手指能表示的范围。

## 输入格式

共三行。  
第一行一个正整数 $N$，表示火星人手指的数目（$1 \le N \le 10000$）。  
第二行是一个正整数 $M$，表示要加上去的小整数（$1  \le  M  \le  100$）。  
下一行是 $1$ 到 $N$ 这 $N$ 个整数的一个排列，用空格隔开，表示火星人手指的排列顺序。

## 输出格式

$N$ 个整数，表示改变后的火星人手指的排列顺序。每两个相邻的数中间用一个空格分开，不能有多余的空格。

## 样例 #1

### 样例输入 #1

```
5
3
1 2 3 4 5
```

### 样例输出 #1

```
1 2 4 5 3
```

## 提示

对于 $30\%$ 的数据，$N \le 15$。

对于 $60\%$ 的数据，$N \le 50$。

对于 $100\%$ 的数据，$N \le 10000$。

noip2004 普及组第 4 题

## 题解

### 解题思路
 __全排列，还是TMD全排列__
从火星人给的手指顺序为起始数据，按字典序不重复地dfs即可，依据如下：
```
123->1
132->2:
    从123回溯到12,枚举得'3',得13
    dfs下一位(1,3不可用)得'2'
    即132为2
213->3:
    从132回溯到13,从13回溯到1,枚举得2,即为"2"
    枚举下一位为1,得21，
    枚举下一位(1,2不可用)得'3'
    即213为3
...
```
所以写dfs函数:
```c++
//  次序   大退？ 标记使用 手指数 偏移量 存储
int flag, flagx, s[10001], n, m, a[10001];
void dfs(int step) {    //填完了step - 1位，正在填step位
    if(flagx == 1)  return; //得到了，大退
    if(step > n) {  //填完了n位(step表示已经填完了step - 1位)
        flag++; //标记表示的火星数
        if(flag == m + 1) { //是第m+1个排列(因为初始时flag = 1)，即结束力（喜
            for(int i = 1; i <= n; i++) cout << a[i] << " ";
            cout << endl;
            flagx = 1;  //大退，启动！
        }
        return;
    }
    for(int i = 1; i <= n; i++) { //字典序枚举第step个数
        if(!flag) i = a[step];  //第一次搜索，以火星人的初始排列为准则
        if(!s[i]) { //s[i]没被标记，可以使用
            //1、标记
            s[i] = 1;
            //2、存储
            a[step] = i;
            //3、继续搜下一位
            dfs(step + 1);
            //4、回溯(解除标记)
            s[i] = 0;
        }
    }
}
```

### AC代码
```c++
#include <bits/stdc++.h> 
using namespace std;

//  次序   大退？ 标记使用 手指数 偏移量 存储
int flag, flagx, s[10001], n, m, a[10001];
void dfs(int step) {    //填完了step - 1位，正在填step位
    if(flagx == 1)  return; //得到了，大退
    if(step > n) {  //填完了n位(step表示已经填完了step - 1位)
        flag++; //标记表示的火星数
        if(flag == m + 1) { //是第m+1个排列(因为初始时flag = 1)，即结束力（喜
            for(int i = 1; i <= n; i++) cout << a[i] << " ";
            cout << endl;
            flagx = 1;  //大退，启动！
        }
        return; //可以换成exit(0);
    }
    for(int i = 1; i <= n; i++) { //字典序枚举第step个数
        if(!flag) i = a[step];  //第一次搜索，以火星人的初始排列为准则
        if(!s[i]) { //s[i]没被标记，可以使用
            //1、标记
            s[i] = 1;
            //2、存储
            a[step] = i;
            //3、继续搜下一位
            dfs(step + 1);
            //4、回溯(解除标记)
            s[i] = 0;
        }
    }
}

int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> a[i];
    dfs(1);
    return 0;
}
```

### STL解法+知识点
有个STL函数叫做next_permutation，它的作用是数组的下一个全排列方式。
```c++
//#include <algorithm>
template<class Iterator>
  bool next_permutation (Iterator first, Iterator last);

template<class Iterator, class Compare>
  bool next_permutation (Iterator first, Iterator last, Compare comp);
```
上面的题还可以：
```c++
#include <bits/stdc++.h>
using namespace std;

int n, m;
int a[10010];

int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> a[i];
    for(int i = 1; i <= m; i++) next_permutation(a + 1, a + n + 1);
    for(int i = 1; i <= n; i++) cout << a[i] << " ";
    return 0; //秒了
}
```

# T3. [[NOIP2008 提高组] 火柴棒等式](https://www.luogu.com.cn/problem/P1149)

## 题目描述

给你 $n$ 根火柴棍，你可以拼出多少个形如 $A+B=C$ 的等式？等式中的 $A$、$B$、$C$ 是用火柴棍拼出的整数（若该数非零，则最高位不能是 $0$）。用火柴棍拼数字 $0\sim9$ 的拼法如图所示：

![](https://cdn.luogu.com.cn/upload/image_hosting/p5hsawt2.png)

注意：

1. 加号与等号各自需要两根火柴棍；
2. 如果 $A\neq B$，则 $A+B=C$ 与 $B+A=C$ 视为不同的等式（$A,B,C\geq0$）；
3. $n$ 根火柴棍必须全部用上。

## 输入格式

一个整数 $n(1 \leq n\leq 24)$。

## 输出格式

一个整数，能拼成的不同等式的数目。

## 样例 #1

### 样例输入 #1

```
14
```

### 样例输出 #1

```
2
```

## 样例 #2

### 样例输入 #2

```
18
```

### 样例输出 #2

```
9
```

## 提示

【输入输出样例 1 解释】

$2$ 个等式为 $0+1=1$ 和 $1+0=1$。

【输入输出样例 2 解释】

$9$ 个等式为

$0+4=4$、$0+11=11$、$1+10=11$、$2+2=4$、$2+7=9$、$4+0=4$、$7+2=9$、$10+1=11$、$11+0=11$。

noip2008 提高第二题

## 题解

### 解题思路
```
题目的要求:
A + B = C
A、B、C的火柴数之和为(n - 4)
```
搜索即可：
```c++

```