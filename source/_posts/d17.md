---
title: 提高组第十七天(最近公共祖先LCA)
date: 2024-11-15 22:53:16
tags: 
    - CSP提高组
    - C++
categories:
    - [CSP,S,课程]
    - [算法,图,树]
---

# $LCA$ 的定义

$LCA$，即：$L$ owest $C$ ommon $A$ ncestor，最近公共祖先

对于树中的两个点 $i,j$，求一个点 $x$，使 $x$ 既是 $i$ 的祖先，也是 $j$ 的祖先，且 $dis_{i,x} + dis_{j,x}$ 最小。

![图1](https://cdn.luogu.com.cn/upload/image_hosting/7rh0kgon.png)

如图1：两个红色点的LCA是紫色点

![图2](https://cdn.luogu.com.cn/upload/image_hosting/7cg1kte8.png)

如图2：两个红色点的LCA是紫色点

# $LCA$ 的查找

[题面](https://www.luogu.com.cn/problem/P3379)

$LCA$ 的查找有很多种算法，如：$Tarjan$ 算法(离线)、倍增算法(在线)、$ST$ 算法等等。

我们今天主要研究倍增算法。

## 实现上跳

我们考虑用一个数组 `jump[][]` 来存储上跳数据，`jump[i][j]` 表示点 $i$ 上跳 $2^j$ 所到达的点的编号。

- 初始时，我们令 `jump[i][0]` 为其父节点。
- 然后，我们考虑 `jump[][]` 数组的递推关系：

    由于 $2^{i-1}+2^{i-1}=2^{i-1}\times2^{1}=2^i$，推出：
    $$
    jump[j][i]=jump[jump[j][i-1]][i-1]
    $$
    即：上跳 $2^{i}$ 步相当于先上跳 $2^{i-1}$ 步，再上跳 $2^{i-1}$ 步。

## 初始化`dep[]`

我们可以通过 $dfs$ 的方式计算 `dep[]`。

## 确定上跳规则

倍增算法主要运用的 __二进制拆数__ 的思想，把 $1$ 步 $1$ 步地上跳变为跳一次 $2^i (i≥0)$ 步。这样，跳 $n$ 步可以组合成跳 $\leq log_2n$ 次 $2^i$ 步。

根据 $LCA$ 的定义，两个相同高度的节点同时从小到大上跳一定步数，若到达的点相同，就说明找到了 $LCA$。

怎样确定这个 “一定步数” 究竟是多少步呢？

![$LCA$ 查找图例](https://cdn.luogu.com.cn/upload/image_hosting/tlvjkrky.png)

如图，我们需要查找两个 $\color{green}{绿色}$ 点的 $LCA$。由于是二进制构造，所以我们让 $i$ 从大到小循环。本图中，$i$ 最大可以取到 $2$，$2^2=4$。上跳 $4$ 步后发现两点都落在了 $\color{teal}{蓝色}$ 点上（如下图）。

![图2](https://cdn.luogu.com.cn/upload/image_hosting/zwl0r64s.png)

但是，我们在算法中 __不能__ 直接确定 $\color{teal}{蓝色}$ 点是否为 $LCA$，所以我们暂时放弃上跳。转而尝试上跳 $2^1=2$ 步到 $\color{orange}{橙色}$ 点（如下图）。

![图3](https://cdn.luogu.com.cn/upload/image_hosting/ee9rc7m0.png)

此时，求两个 $\color{green}{绿色}$ 点的 $LCA$ 就相当于求两个 $\color{orange}{橙色}$ 点的 $LCA$，即 $LCA$ 必然在 $\color{orange}{橙色}$ 点之上，所以继续上跳。

我们再上跳 $2^0 = 1$ 步到 $\color{purple}{紫色}$ 点上。此时循环结束，不能再上跳，观察发现，两个 $\color{purple}{紫色}$ 点的父节点就是所求的 $LCA$。

![图4](https://cdn.luogu.com.cn/upload/image_hosting/38czh2cw.png)

{% note green fa-lightbulb %}
__总结__：其实根本就不需要知道应该上跳多少步，只需要在确保两个上跳后 __不重合__ 的前提下，不断让两个点上跳即可。最总到达的点的父节点就是所求的 $LCA$。
{% endnote %}

## 代码实现
```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 500000, M = 500000;

struct Edge {
    int u, v, w, nxt;
} l[M << 2];
int h[N], cnt = 0;
void Link(int u, int v, int w) {
    l[++cnt] = {u, v, w, h[u]}; h[u] = cnt;
}

int n, m, s;   //n点、m次询问

//深搜求dep
int dep[N], jump[N][21];
void Dfs(int u, int fa) {
    dep[u] = dep[fa] + 1;   //记录深度
    jump[u][0] = fa;        //初始化jump数组
    for(int i = h[u], v; i; i = l[i].nxt) {
        v = l[i].v; 
        if(v == fa) continue;   //不能原路返回
        Dfs(v, u);
    }
}
//递推求jump
void GetJump() {
    for(int i = 1; i <= 20; i++) {
        for(int j = 1; j <= n; j++) {
            jump[j][i] = jump[jump[j][i-1]][i-1];
        }
    }
}

//倍增求lca
int LCA(int u, int v) {
    if(dep[u] < dep[v]) swap(u, v); //保证u在v下   
    //将u上跳到v的高度
    for(int i = 20; i >= 0; i--) {
        if(dep[u] - (1 << i) >= dep[v]) {
            u = jump[u][i];
        }
    }
    if(u == v) return u;    //特判
    //跳到lca下
    for(int i = 20; i >= 0; i--) {
        if(jump[u][i] != jump[v][i]) {
            u = jump[u][i];
            v = jump[v][i];
        }
    }
    return jump[u][0];      //u或v的父节点是lca
}

int main() {
    cin >> n >> m >> s;
    for(int i = 1, u, v; i < n; i++) {   //树有n-1条边
        cin >> u >> v;
        Link(u, v, 1); Link(v, u, 1);
    }
    Dfs(s, 0);  //0号节点其实不存在，只是虚拟的
    GetJump();
    for(int i = 1, u, v; i <= m; i++) {
        cin >> u >> v;
        cout << LCA(u, v) << endl;
    }
    return 0;
}
```

# $LCA$ 的运用

## 问题一

{% note default fa-book %}
__问题描述__：求树中两节点的最短距离。
{% endnote %}

分析一下，两节点的最短距离就是它们到它们的 $LCA$ 的距离和。

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1001, M = 1001;

struct Edge {
    int u, v, w, nxt;
} l[M << 2];
int h[N], cnt = 0;
void Link(int u, int v, int w) {
    l[++cnt] = {u, v, w, h[u]}; h[u] = cnt;
}

int n, m;   //n点、m次询问

//深搜求dep和dis
int dep[N], jump[N][31], dis[N];
void Dfs(int u, int fa) {
    dep[u] = dep[fa] + 1;   //记录深度
    jump[u][0] = fa;        //初始化jump数组
    for(int i = h[u], v, w; i; i = l[i].nxt) {
        v = l[i].v; w = l[i].w;
        if(v == fa) continue;   //不能原路返回
        dis[v] = dis[u] + w;
        Dfs(v, u);
    }
}
//递推求jump
void GetJump() {
    for(int i = 1; i <= 30; i++) {
        for(int j = 1; j <= n; j++) {
            jump[j][i] = jump[jump[j][i-1]][i-1];
        }
    }
}

//倍增求lca
int LCA(int u, int v) {
    if(dep[u] < dep[v]) swap(u, v); //保证u在v下   
    //将u上跳到v的高度
    for(int i = 30; i >= 0; i--) {
        if(dep[u] - (1 << i) >= dep[v]) {
            u = jump[u][i];
        }
    }
    if(u == v) return u;    //特判
    //跳到lca下
    for(int i = 30; i >= 0; i--) {
        if(jump[u][i] != jump[v][i]) {
            u = jump[u][i];
            v = jump[v][i];
        }
    }
    return jump[u][0];      //u或v的父节点是lca
}

int main() {
    cin >> n >> m;
    for(int i = 1, u, v, w; i < n; i++) {   //树有n-1条边
        cin >> u >> v >> w;
        Link(u, v, w); Link(v, u, w);
    }
    Dfs(1, 0);  //0号节点其实不存在，只是虚拟的
    GetJump();
    for(int i = 1, u, v; i <= m; i++) {
        cin >> u >> v;
        int a = LCA(u, v);
        cout << dis[u] - dis[a] + dis[v] - dis[a] << endl;  //计算距离
    }
    return 0;
}
```

## 问题二、移民火星

### 描述

$2099$ 年，机器人率先入驻火星，收集数据，为人类移民火星打下前站。在有些已经命名的地址例如平乐、西柏坡、文家市、窑店、古绛、胡襄、周庄、郑集、齐都、天柱山、马集等，建立的基站，一些未命名的地址也建立的基站。

目前，火星上总共有 $n$ 个基站，只要机器人能相互到达即可，可以将这些基站视为单独的点。共有 $n−1$ 条道路连接。现在，需要找连接一组三个基站的最短路径。

### 输入描述

- 第 $1$ 行一个整数 $n$，表示 $n$ 个城市区域（$1≤n≤50000$），城市编号为 $0 \sim n−1$。
- 然后输入 $n−1$ 行数据，每行是 $u,v,w$，表示 $u$ 区域到 $v$ 区域的道路长度 $w$。
- 输入一个整数 $k$，表示有 $k$ 组测试数据，每组包括 $3$ 个整数，代表 $3$ 个区域。

### 输出描述

$k$ 行数据，表示 3 个区域之间的距离。

### 样例输入 #1 
```
5
0 1 5
0 2 6
1 3 1
1 4 1
2
0 1 2
2 0 3
```

### 样例输出 #1 
```
11
12
```

### 样例解释 #1

![样例 #1 图](https://cdn.luogu.com.cn/upload/image_hosting/ekpttpei.png)

连接 $0,1,2$ 的边的权值和是 $5+6=11$ ；连接 $2,0,3$ 的边的权值和是 $6+5+1=12$。

### 提示

**数据范围与提示**

- 输入数据均为`long int(32bit)`的正整数。
- 对于 $100\%$ 的数据，$1≤k≤n≤50000$。

### 题解

分析一下，$n$ 个点，$n-1$ 条边，这不是树吗？问题一下子就简单多了。

我们知道，树上两点间的最短路径是它们到 $LCA$ 的距离和，那么如何推广到三点呢？

![图1](/images/CSP-S/d17/8.png)

可以发现，若要求 $\color{purple}{紫色}$ 点、$\color{orange}{橙色}$ 点 和 $\color{green}{绿色}$ 点的最短路径。先两两求它们的最短路径，如下图所示。

![图2](https://cdn.luogu.com.cn/upload/image_hosting/shdognpo.png)

不难看出，每条被走过的边都被走过了两次。所以我们只需要求三点两两间的最短路径的和与 $2$ 的商即可。

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 50001, M = 50001;

struct Edge {
    int u, v, w, nxt;
} l[M << 2];
int h[N], cnt = 0;
void Link(int u, int v, int w) {
    l[++cnt] = {u, v, w, h[u]}; h[u] = cnt;
}

int n, m;   //n点、m次询问

//深搜求dep和dis
int dep[N], jump[N][31], dis[N];
void Dfs(int u, int fa) {
    dep[u] = dep[fa] + 1;   //记录深度
    jump[u][0] = fa;        //初始化jump数组
    for(int i = h[u], v, w; i; i = l[i].nxt) {
        v = l[i].v; w = l[i].w;
        if(v == fa) continue;   //不能原路返回
        dis[v] = dis[u] + w;
        Dfs(v, u);
    }
}
//递推求jump
void GetJump() {
    for(int i = 1; i <= 30; i++) {
        for(int j = 1; j <= n; j++) {
            jump[j][i] = jump[jump[j][i-1]][i-1];
        }
    }
}

//倍增求lca
int LCA(int u, int v) {
    if(dep[u] < dep[v]) swap(u, v); //保证u在v下   
    //将u上跳到v的高度
    for(int i = 30; i >= 0; i--) {
        if(dep[u] - (1 << i) >= dep[v]) {
            u = jump[u][i];
        }
    }
    if(u == v) return u;    //特判
    //跳到lca下
    for(int i = 30; i >= 0; i--) {
        if(jump[u][i] != jump[v][i]) {
            u = jump[u][i];
            v = jump[v][i];
        }
    }
    return jump[u][0];      //u或v的父节点是lca
}

//求两点间的距离
int GetDis(int u, int v) {
        int a = LCA(u, v);
        return dis[u] - dis[a] + dis[v] - dis[a];
}

int main() {
    cin >> n;
    for(int i = 1, u, v, w; i < n; i++) {   //树有n-1条边
        cin >> u >> v >> w;
        Link(u + 1, v + 1, w); Link(v + 1, u + 1, w);   //城市编号向后偏移，空出0号虚拟节点
    }
    Dfs(1, 0);  //0号节点其实不存在，只是虚拟的
    GetJump();
    cin >> m;
    for(int i = 1, u, v, w; i <= m; i++) {
        cin >> u >> v >> w;
        u++, v++, w++;
        int dis1 = GetDis(u, v);
        int dis2 = GetDis(v, w);
        int dis3 = GetDis(u, w);
        cout << (dis1 + dis2 + dis3) / 2 << endl;
    }
    return 0;
}
```
