---
title: 队列
categories:
  - [《算法竞赛》,第一章]
  - [数据结构,队列]
date: 2024-05-31 00:15:41
tags: 
    - C++
    - CSP入门组
excerpt: 队列是一种先进先出的数据结构，它就像是在排队，先到先排到。
---

队列是一种先进先出的数据结构，它就像是在排队，先到先排到。在 $STL$ 中，队列声明格式为`std::queue<T>`，例如：`queue<int>`是存储`int`类型元素的队列。

还有很多种队列拓展了队列的使用场景，例如：双端队列，即`std::deque<T>`，它可以在两端进行入队和出队；优先队列，它并不是先进先出，而是最大（小）的先出。

## 队列的实际应用

### [[NOIP2010 提高组] 机器翻译](https://www.luogu.com.cn/problem/P1540)

#### 题目背景

NOIP2010 提高组 T1

#### 题目描述

小晨的电脑上安装了一个机器翻译软件，他经常用这个软件来翻译英语文章。

这个翻译软件的原理很简单，它只是从头到尾，依次将每个英文单词用对应的中文含义来替换。对于每个英文单词，软件会先在内存中查找这个单词的中文含义，如果内存中有，软件就会用它进行翻译；如果内存中没有，软件就会在外存中的词典内查找，查出单词的中文含义然后翻译，并将这个单词和译义放入内存，以备后续的查找和翻译。

假设内存中有 $M$ 个单元，每单元能存放一个单词和译义。每当软件将一个新单词存入内存前，如果当前内存中已存入的单词数不超过 $M-1$，软件会将新单词存入一个未使用的内存单元；若内存中已存入 $M$ 个单词，软件会清空最早进入内存的那个单词，腾出单元来，存放新单词。

假设一篇英语文章的长度为 $N$ 个单词。给定这篇待译文章，翻译软件需要去外存查找多少次词典？假设在翻译开始前，内存中没有任何单词。

#### 输入格式

共 $2$ 行。每行中两个数之间用一个空格隔开。

第一行为两个正整数 $M,N$，代表内存容量和文章的长度。

第二行为 $N$ 个非负整数，按照文章的顺序，每个数（大小不超过 $1000$）代表一个英文单词。文章中两个单词是同一个单词，当且仅当它们对应的非负整数相同。

#### 输出格式

一个整数，为软件需要查词典的次数。

#### 样例 #1

##### 样例输入 #1

```
3 7
1 2 1 5 4 4 1
```

##### 样例输出 #1

```
5
```

#### 提示

##### 样例解释

整个查字典过程如下：每行表示一个单词的翻译，冒号前为本次翻译后的内存状况：

1. `1`：查找单词 1 并调入内存。
2. `1 2`：查找单词 2 并调入内存。
3. `1 2`：在内存中找到单词 1。
4. `1 2 5`：查找单词 5 并调入内存。
5. `2 5 4`：查找单词 4 并调入内存替代单词 1。
6. `2 5 4`：在内存中找到单词 4。
7. `5 4 1`：查找单词 1 并调入内存替代单词 2。

共计查了 $5$ 次词典。

##### 数据范围

- 对于 $10\%$ 的数据有 $M=1$，$N \leq 5$；
- 对于 $100\%$ 的数据有 $1 \leq M \leq 100$，$1 \leq N \leq 1000$。

#### 思路

用队列模拟，有的单词不管，没有的单词入队后判断队伍长度，越界就出开头的。对于每个单词，我们考虑使用哈希表存储在队情况。

#### 代码

```c++
#include <iostream>
#include <queue>
using namespace std;

int Hash[1001] = {0};
queue<int> mem;
int m, n, cnt = 0, word;

int main() {
    cin >> m >> n;
    while(n--) {
        cin >> word;
        if(!Hash[word]) {
            ++cnt;  //新单词，查一次
            mem.push(word); //入队
            Hash[word] = 1; //记到内存中
            while(mem.size() > m) {     //内存超限了
                Hash[mem.front()] = 0;  //删除单词
                mem.pop();              //队首出队
            }
        }
    }
    cout << cnt;
    return 0;
}
``` 

## 单调队列

{% notel green fa-link 知识链接 %}

- 单调队列可以看作是一种做题方法，即维护一个队列，队列维护一个区间，使其中的元素单调，对于入队元素打破单调性的情况，则将队尾出队，直到元素入队后仍保持单调性为止。当队列所维护的区间长度超出最大区间长度时，让队首出队。
- 单调队列一般用于 __区间求最值问题__，一般维护队首为最值。
- 由于需要元素从队尾出队，我们需要使用双端队列。

模板代码：

```c++
deque<int> q;
//遍历或者其他操作
    //1.维护队列单调性
    while(!q.empty() && /*比较队尾与当前元素*/) q.pop_back();
    //2.新元素入队
    q.push_back(/*某个元素*/);
    //3.维护队列长度
    while(!q.empty() && /*当前元素所代表的右端点*/ - q.front() + 1 > /*限制长度*/) q.pop_front();
    //4.计算答案
```

{% endnotel %}

### T2. [【模板】单调队列](https://www.luogu.com.cn/problem/P1886)

#### 题目描述

有一个长为 $n$ 的序列 $a$，以及一个大小为 $k$ 的窗口。现在这个从左边开始向右滑动，每次滑动一个单位，求出每次滑动后窗口中的最大值和最小值。

例如，对于序列 $[1,3,-1,-3,5,3,6,7]$ 以及 $k = 3$，有如下过程：

$$\def\arraystretch{1.2}
\begin{array}{|c|c|c|}\hline
\textsf{窗口位置} & \textsf{最小值} & \textsf{最大值} \\ \hline
\verb![1   3  -1] -3   5   3   6   7 ! & -1 & 3 \\ \hline
\verb! 1  [3  -1  -3]  5   3   6   7 ! & -3 & 3 \\ \hline
\verb! 1   3 [-1  -3   5]  3   6   7 ! & -3 & 5 \\ \hline
\verb! 1   3  -1 [-3   5   3]  6   7 ! & -3 & 5 \\ \hline
\verb! 1   3  -1  -3  [5   3   6]  7 ! & 3 & 6 \\ \hline
\verb! 1   3  -1  -3   5  [3   6   7]! & 3 & 7 \\ \hline
\end{array}
$$

#### 输入格式

输入一共有两行，第一行有两个正整数 $n,k$。

第二行 $n$ 个整数，表示序列 $a$

#### 输出格式

输出共两行，第一行为每次窗口滑动的最小值

第二行为每次窗口滑动的最大值

#### 样例 #1

##### 样例输入 #1

```
8 3
1 3 -1 -3 5 3 6 7
```

##### 样例输出 #1

```
-1 -3 -3 -3 3 3
3 3 5 5 6 7
```

#### 提示

【数据范围】    

对于 $50\%$ 的数据，$1 \le n \le 10^5$；  

对于 $100\%$ 的数据，$1\le k \le n \le 10^6$，$a_i \in [-2^{31},2^{31})$。

#### 思路

分析一下题意：对于一个区间 $[l, l+k] (l+k \leq n)$，求其中的最大值和最小值。

由于是区间最值问题，我们考虑维护一个单调队列，队列维护的区间长度限制为 $k$。第一次循环求区间最小值，第二次循环求区间最大值。

循环遍历的逻辑:

- 对于每个下标 $i$ 及其值 $a_i$，尝试将 $a_i$ 插入单调队列中。假设要求区间最小值，对于队列中现有的队尾 $a_j$，若 $a_j>a_i$，则 $a_j$ 不仅不是当前区间的最小值，更不会是以后区间的最小值，所以让 $a_j$ 出队。最后将 $a_i$ 入队。

```c++
while(!q.empty() && a[q.back()] > a[i]) q.pop_back();
q.push_back(i);
```

- 我们还要维护区间的长度。已知当前区间的左边界为`q.front()`，右边界为 $i$，则区间内有 $i-q.front()+1$ 个元素。当元素数大于 $k$ 时，说明长了，应当将队首弹出（注意：是区间长度，不是元素个数）。

```c++
while(!q.empty() && i - q.front() + 1 > k) q.pop_front();
```

- 一切妥当后，我们输出答案，即队首（仅有区间长度 $\ge k$ 时才输出）。

```c++
if(i >= k)
    cout << a[q.front()] << " ";
```

### 代码

```c++
#include <iostream>
#include <queue>
using namespace std;

const int N = 10000001;
int a[N] = {0};
deque<int> q;       //双端队列
int n, m;

int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; i++) cin >> a[i];
    for(int i = 1; i <= n; i++) {
        while(!q.empty() && a[q.back()] > a[i]) q.pop_back();  //去尾（破坏了单调性，应当确保队尾最大）
        q.push_back(i);
        if(i >= m) {
            while(!q.empty() && a[q.front()] <= i - m) q.pop_front();  //删头（头不在窗口中）
            cout << a[q.front()] << " ";
        }
    }
    cout << endl;
    while(!q.empty()) q.pop_front();
    for(int i = 1; i <= n; i++) {
        while(!q.empty() && a[q.back()] < a[i]) q.pop_back();  //去尾（破坏了单调性）
        q.push_back(i);
        if(i >= m) {
            while(!q.empty() && a[q.front()] <= i - m) q.pop_back();  //删头（头不在窗口中）
            cout << a[q.front()] << " ";
        }
    }

    return 0;
}
```

### T3. Max Sum(hdu 1003)

#### 问题描述

给定一个序列 a[1], a[2], a[3], ..., a[n]，你的任务是计算子序列的最大和。例如，给定 (6, -1, 5, 4, -7)，这个序列的最大和是 6 + (-1) + 5 + 4 = 14。

#### 输入

输入的第一行包含一个整数 T(1<=T<=20)，表示测试用例的数量。接下来的 T 行，每行以一个数字 N(1<=N<=100000) 开始，然后是 N 个整数（所有整数都在 -1000 到 1000 之间）。

#### 输出

对于每个测试用例，你应该输出两行。第一行是 "Case #:"，# 表示测试用例的编号。第二行包含三个整数，序列中的最大和，子序列的起始位置，子序列的结束位置。如果有多个结果，输出第一个。两个案例之间输出一个空行。

#### 样例输入 #1

```
2
5 6 -1 5 4 -7
7 0 6 -1 1 -6 7 -5
```

#### 样例输出 #1 

```
Case 1:
14 1 4

Case 2:
7 1 6
```

#### 题解

动态规划，以dp[i]表示从0到i的最大子序列和。状态转移方程为:dp[i] = max(dp[i - 1] + dp[i], dp[i])，意思是如果上一个数和最大的子序列中加入了第i个数，如果结果更大就确定加入，否则当前的一个数是整个序列的最大子序列和。

##### 代码

```c++
#include <iostream>
using namespace std;

int dp[100001];
int t, n;

int main() {
    cin >> t;
    while(t--) {
        cin >> n;
        for(int i = 1; i <= n; i++) cin >> dp[i];
        int s, e, p, max = dp[1];
        s = e = p = 1;
        //dp
        for(int i = 2; i <= n; i++) {
            if(dp[i - 1] + dp[i] >= dp[i]) dp[i] = dp[i - 1] + dp[i];
            else p = i;
            if(dp[i] > max) max = dp[i], s = p, e = i;    //(p, i)是和最大的子序列
        }
        cout << max << " " << s << " " << e << endl;
        cout << endl;
    }
}
```

### T4. $m$ 长度最大子段和

{% notel defualt fa-book 题目描述 %}
限制子序列的长度 $m$ ，找出一段长度不超过 $m$ 的子序列，使它的子序列和最大。
{% endnotel %}

#### 题解

首先求前缀和，找出 $i,k$，使得 $s_i-s_{k-1}$ 最大 $(i - k \leq m)$

用单调队列例题“滑动窗口”的思想：我们维护一个单调队列，使得队首元素最小且队列维护的区间长度不超过 $m+1$（$+1$ 的原因后面解释），计算队尾减队首的最大值。

为什么和单调队列扯上关系呢？对于一个 $s_i$，若它比队列前面所有的 $s_j$ 都要小，那么后面无论取什么 $s_{i'}$，都有 $s_{i'} - s_i > s_{i'} - s_j$，即子段和最大化。所以用单调队列维护当前不超长区间中 $s_i$ 的最小值。

这里有一个小问题需要解决：假如当只选第一个数构成子序列时子序列和最大，而队列为空，该怎么办？为了让队列不为空，我们加入一个虚拟左端点 $0$，使 $s_0=0$，这样就可以先让 $0$ 号点入队，直接计算即可。但是这样做会使原本的区间长度 $+1$，所以维护长度时的判断条件从`i-q.front()+1>k`变为`i-q.front()>k`。

#### 代码
```c++
#include <iostream>
#include <queue>
using namespace std;
const int N = 10001;
deque<int> st;
int a[N], s[N] = {0}, n, m;

int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
        s[i] = s[i - 1] + a[i];
    }
    int ans = -1e8;
    st.push_back(0);
    for(int i = 1; i <= n; i++) {   //每个s[i]依次入队
        while(!st.empty() && st.front() < i - m) st.pop_front();    //长度超过m，删除头
        if(st.empty()) ans = s[1]; else ans = max(ans, s[i] - s[st.front()]);
        while(!st.empty() && s[st.back()] >= s[i]) st.pop_back();   //维护单调队列，使得s[i'] - s[k]最大
        st.push_back(i);
    }
    cout << ans;
    return 0;
}
```