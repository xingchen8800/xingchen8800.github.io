---
title: 提高第七天（栈和表达式）
date: 2024-08-12 21:53:32
categories:
    - [CSP,CSP-S,课程]
    - [算法,字符串]
    - [数据结构,线性表,栈]
excerpt: 本篇主要探讨中缀、前缀、后缀表达式的相互转换以及运算，同时介绍单调栈的应用。
tags: 
    - C++
    - CSP提高组
---

{% note green fa-link %}
代码请移步 {% btn 这里::https://github.com/xingchen8800/CSP/tree/main/S/7 %}
{% endnote %}

# I.表达式

## 理论部分

### 中缀表达式

{% notel default fa-link 知识链接🔗 %}
中缀表达式就是我们平时使用的表达式，即`数` `运算符` `数`，例：`1` `+` `1`

当有多个运算符时，可以按照运算优先级，将优先计算的子表达式当作一个`数`（类似于加括号），不断套娃，如：`3` `*` `2` `+` `5`

1. 最优先的是乘法`3` `*` `2`，则将`3` `*` `2`看成`3*2(=6)`这个整体，即：`3*2(=6)` `+` `5`
2. 最优先的是只有加法`6` `+` `5`，则直接计算得`11`
{% endnotel %}

### 前缀表达式

{% notel default fa-link 知识链接🔗 %}
前缀表达式就是`运算符` `数` `数`，例：`+` `1` `1`

在将中缀表达式转换为前缀表达式时，需要按照中缀表达式的运算方法，如：将`3` `*` `2` `+` `5`转化为前缀表达式：

1. 最优先的是乘法`3` `*` `2`，则将`3` `*` `2`看成`3*2(=6)`这个整体，此时的中缀表达式为：`3*2(=6)` `+` `5`， 前缀表达式为：`*3 2(=6)`；
2. 最优先的是只有加法`3*2(=6)` `+` `5`，则此时的前缀表达式为：`+` `5` `*3 2(=6)`，则转化完毕，前缀表达式是：`+` `5` `*` `3` `2`。

__计算__：
1. 每次找最后一个运算符，取它后面的两个数作运算
2. 将运算结果替换那个运算符和两个数的组合
3. 不断重复，直到只剩下一个数
{% endnotel %}

### 后缀表达式

{% notel default fa-link 知识链接🔗 %}
后缀表达式就是`数` `数` `运算符`，例：`1` `1` `+`

在将中缀表达式转换为后缀表达式时，也需要按照中缀表达式的运算方法，并且和转前缀表达式的过程类似，如：将`3` `*` `2` `+` `5`转化为后缀表达式：
1. 最优先的是乘法`3` `*` `2`，则将`3` `*` `2`看成`3*2(=6)`这个整体，此时的中缀表达式为：`3*2(=6)` `+` `5`， 后缀表达式为：`3 2 *(=6)`；
2. 最优先的是只有加法`3*2(=6)` `+` `5`，则此时的前缀表达式为：`5` `3 2 *(=6)` `+`，则转化完毕，前缀表达式是：`5` `3` `2` `*` `+`。

__计算__：
1. 每次找第一个运算符，取它前面的两个数作运算
2. 将运算结果替换那个运算符和两个数的组合
3. 不断重复，直到只剩下一个数
{% endnotel %}

## 实践出真知

### 究极无敌难度超级大转换

将中缀表达式`1 * (2 + 3) * 4 + 5 * (6 + 7) * 8 - 9 * 10`转化为前缀表达式。

#### 一、不怕困难，暴力出奇迹！

1. 按从左往右的顺序，先算`2` `+` `3`，将它看成`2+3(=5)`，此时的前缀表达式为：`+ 2 3(=5)`
2. 再算`1` `*` `2+3(=5)`，前缀表达式为：`*` `1` `+ 2 3(=5)`，看作整体：`* 1 + 2 3`
3. 再算`1*(2+3)(=5)` `*` `4`，前缀表达式为：`*` `* 1 + 2 3` `4`，即：`* * 1 + 2 3 4`
4. 再算`1*(2+3)*4` `+` `5*(6+7)*8`，将`5*(6+7)*8`拆分，先算`6` `+` `7`，即：`+ 6 7`
5. 再算`5` `*` `(6+7)`，即：`* 5 + 6 7`
6. 再算`5*(6+7)` `*` `8`，即：`* * 5 + 6 7 8`
7. 合并，算`1*(2+3)*4` `+` `5*(6+7)*8`，即：`+` `* * 1 + 2 3 4` `* * 5 + 6 7 8`
8. 再将`9` `*` `10`看作整体，即：`* 9 10`
9. 最后合并，得：`-` `+ * * 1 + 2 3 4 * * 5 + 6 7 8` `* 9 10`，即：`- + * * 1 + 2 3 4 * * 5 + 6 7 8 * 9 10`

#### 二、巧解问题，思维敏捷

我们可以在中序表达式中将`运算符`作为 __根__，将两个`数（当作整体的表达式）`作为它的两个 __子节点（子树）__ 来构造一棵二叉树，如：

![图7-1](/images/d7-1.png)

再加上套娃：

![图7-2](/images/d7-2.png)

- 二叉树的先序遍历：`* 8 (+ 1 1)`
- 二叉树的中序遍历：`8 * (1 + 1)`
- 二叉树的后序遍历：`8 (1 1 +) *`

可以发现，__二叉树的先序遍历就是前缀表达式，后序遍历就是后缀表达式，中序遍历就是中缀表达式__！

这样就可以构造一棵超大二叉树来解决问题，还可以编程求解

![图7-3](/images/d7-3.png)

### 编程计算前缀表达式

#### 循环式
按照`理论`部分，将输入分为运算符和数字部分，不断合并即可。

```c++
#include <bits/stdc++.h>
using namespace std;

bool isAnOperator(char _character) {
    if(_character == '+' || _character == '-' || _character == '*' || _character == '/') return true;
    return false;
}

int main() {
    int k;
    char s[1001][101];  //输入(1001个长度为101的字符串)
    int count = 1;  //标记字符串的数量
    double answer[1001] = {0};    //记录一块的答案
    int p = 0;      //answer的索引，即当前运算符后的数
    while(cin >> s[k]) k++; //获得输入
    count--;    //[1,count]
    for(int i = count; i >= 1; i--) {   //从后往前找运算符
        if(isAnOperator(s[i][0])) { //是运算符，就计算结果
            if(s[i][0] == '+') {
                answer[p - 1] = answer[p] + answer[p - 1]; //存储作为整体的表达式，p从后往前存，p-1在p的后面
                answer[p] = 0;                   //不写也可，直接覆盖
            } else if(s[i][0] == '-') {
                answer[p - 1] = answer[p] - answer[p - 1];
                answer[p] = 0;
            } else if(s[i][0] == '*') {
                answer[p - 1] = answer[p] * answer[p - 1];
                answer[p] = 0;
            } else {
                answer[p - 1] = answer[p] / answer[p - 1];
                answer[p] = 0;
            }
            p--;
        } else {    //是数，直接加入
            answer[++p] = atof(s[i]);   //atof(): (const char *) to double
        }
    }
    cout << answer[1];
}
```

#### 递归式
分析一下：

当输入 __运算符__ 时，则说明要计算后面的两个操作数（或者是整体（因为是递归，所以直接套））；

当输入 __数字__ 时，则要返回自己的`double`型。


代码一下子短了好多呢！
```c++
#include <bits/stdc++.h>
using namespace std;

double calc() {
    string str;
    cin >> str;
    if(str[0] == '+') {
        return calc() + calc(); //输入两个数（合并成整体的表达式）
    } else if(str[0] == '-') {
        return calc() - calc();
    } else if(str[0] == '*') {
        return calc() * calc();
    } else if(str[0] == '/') {
        return calc() / calc();
    } else {
        return atof(str.c_str());
    }
}

int main() {
    cout << calc();
    return 0;
}
```

### 编程计算后缀表达式

稍微改一下前缀表达式的代码，从前往后找运算符，将`answer[p - 1]`作为第一个数。

```c++
#include <bits/stdc++.h>
using namespace std;

bool isAnOperator(char _character) {
    if(_character == '+' || _character == '-' || _character == '*' || _character == '/') return true;
    return false;
}

int main() {
    char input[1001][101];  //输入(1001个长度为101的字符串)
    int count = 1;  //标记字符串的数量
    double answer[1001] = {0};    //记录一块的答案
    int p = 0;      //answer的索引，即当前运算符后的数
    while(cin >> input[k]) k++; //获得输入
    count--;    //[1,count]
    for(int i = 1; i <= count; i++) {   //从后往前找运算符
        if(isAnOperator(s[i][0])) { //是运算符，就计算结果
            if(s[i][0] == '+') {
                anwser[p - 1] = anwser[p - 1] + anwser[p]; //存储作为整体的表达式，p从后往前存，p-1在p的后面
                anwser[p] = 0;                   //不写也可，直接覆盖
            } else if(s[i][0] == '-') {
                anwser[p - 1] = anwser[p - 1] - anwser[p];
                anwser[p] = 0;
            } else if(s[i][0] == '*') {
                anwser[p - 1] = anwser[p - 1] * anwser[p];
                anwser[p] = 0;
            } else {
                anwser[p - 1] = anwser[p - 1] / anwser[p];
                anwser[p] = 0;
            }
            p--;
        } else {    //是数，直接加入
            answer[++p] = atof(s[i]);   //atof(): (const char *) to double
        }
    }
    cout << anwser[1];
}
```

后缀表达式不能递归罢（悲）

# II.单调栈

## 介绍

单调栈(Monotone Stack)，顾名思义，单调的栈。怎样保持单调呢？很简单，当要进入的元素过小/大时，一直弹出栈顶，直到元素进栈后保持单调性即可。

## 例题（看发型）

### 描述

大家排队，都面向右边。大家只能向下看。从左边数第一位开始，如果第2位同学比他低，他能看到该同学的头型，如果高就看不到了，后面的也看不到。输入n个人，再输入n个人的身高。求所有人能看到其他人的头型总数有多少。（1<n<10^6)

#### 输入描述

共两行。第一行一个整数n表示总人数。

第二行依次输入n个人的身高。

#### 输出描述

一个整数，表示所有人能看到其他人的头型总数。

### 样例

#### 输入样例

```
6 
10 3 7 4 12 2
```

#### 输出样例

```
5
```

### 解析

先用栈模拟一下，栈内单调，表示从左往右都能看到。

分析一下：

1. 栈内有零个元素，`6`入栈，累加器为`0`（自己看不见自己）
2. `10`比`6`大，`6`出栈，栈为空；`10`入栈；累加器为`0`（`6`看不见`10`，`10`看不见自己）
3. 栈内有一个元素，`3`比`10`小，`3`入栈；累加器为`1`（`10`能看见`3`）
4. `7`比`3`大，`3`出栈；`7`比`10`小，不动；栈内有一个元素，累加器为`2`（`10`能看见`7`），`7`入栈
5. 栈内有二个元素，`4`比`7`小，`7`入栈；累加器为`4`（`10`能看见`4`，`7`能看见`4`）
6. `12`比`4`大，`4`出栈；`12`比`7`大，`7`出栈；`12`比`10`大，`10`出栈；栈内有零个元素，累加器为`4`（谁都看不见`12`）
7. 栈内有一个元素，`2`比`12`小，`2`入栈；累加器为`5`（`12`能看见`2`）

典型的单调栈。维护一个单调栈，每次检测栈内的元素数并累加即可，累加后再入栈（自己不能看自己）。

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    stack<int> st;      //单调栈
    int tmp, ans = 0;
    cin >> n;
    while(n--) {
        cin >> tmp;
        while(!st.empty() && st.top() <= tmp) st.pop();   //维护单调栈，必须大于！！！等于也！要！出！栈！（破音）
        ans += st.size();   //维护完了再累加，防止反着看（单调性没了）
        st.push(tmp);   //tmp入栈
    }
    cout << ans;
    return 0;
}
```