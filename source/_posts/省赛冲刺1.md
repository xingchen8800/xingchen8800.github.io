---
title: 省赛冲刺1
date: 2024-12-07 18:36:38
tags:
---

## T2. 奶牛队伍

### 题目描述

$FJ$ 养了 $N$ 头奶牛，它们站在一条直线上，其中第i头奶牛在直线上的位置为 $x_i$（ $x_i$ 一定是整数）。除此以外，每头奶牛都有一个品种类型，用整数 $id_i$ 表示，可能存在多头奶牛属于同一个品种类型。

现在FJ希望从N头奶牛中挑选若干头奶牛拍一张照片，要求照片中每个不同品种的奶牛至少有一头，这张照片的花费取决于照片的宽度，即照片中最右边的奶牛位置和最左边的奶牛位置之差。

现在，请你计算出满足 $FJ$ 要求的照片最小花费。

### 输入格式

第1行一个整数 $N$ ，表示奶牛数量 $(1 \leq N \leq 5 \times 10^4)$

第2行到第 $N+1$ 行，每行两个整数，分别表示每头奶牛的位置 $x_i$ 和品种类型 $id_i$（ $x_i$ 和 $id_i$ 不超过 $10^9$）

### 输出格式

输出一行，一个整数，表示照片的最小花费

### 输入输出样例

#### 输入样例1

```
6
25 7
26 1
15 1
22 3
20 1
30 1
```

#### 输出样例1

```
4
```

### 题解

题目的直白翻译：选择一个长度最短的区间使区间内 __包含所有品种的奶牛__。

遇到在一条线上的坐标问题，首先对坐标进行排序。

区间选择问题，首先尝试枚举每个区间，找找优化的方案。对于每个区间，我们要维护区间内的奶牛种数，然后与总品种数进行比较。

区间枚举问题，优化方案首选 __双指针__，即用 $l,r$ 维护一个区间 $[l,r]$。我们让 $r$ 指针在 $1 \sim n$ 之间滑动，对于每个 $r$，我们找到一个最优的 $l$，再是否判断符合条件并记录。这里有几个小点需要注意：

1. 由于题目给到的 $id_i$ 范围特别大，我们用普通的桶装不下，此时可以使用 `map` 来代替桶。在每次让 $r$ 进入区间时，在 `map` 中标记。
2. 对于统计区间不同种类数的统计，我们可以在 `map` 标记时检查标记后的值是否为 $1$。
3. 如果 $l$ 不是最优的，当且仅当牛 $l$ 的 $id$ 在 $[l,r]$ 中的出现次数 $\ge 2$，此时删去 $l$，区间的奶牛种类数不会减少。

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll N = 50001;
ll n, kind = 0;
struct Cow {
    ll id, x;
} c[N];
map<ll, ll> m, m1;

bool Cmp(Cow &a, Cow &b) {
    return a.x < b.x;
}

int main() {
    cin >> n;
    for(ll i = 1; i <= n; i++) {
        cin >> c[i].x >> c[i].id;
        if(++m1[c[i].id] == 1) {
            kind++;
        }
    }
    sort(c + 1, c + n + 1, Cmp);
    ll l = 1, r = 1, kinds = 0, ans = LLONG_MAX;
    for(; r <= n; r++) {
        if(++m[c[r].id] == 1) kinds++;      //r进入区间
        while(l < r && m[c[l].id] > 1) {    //维护最优的l
            m[c[l].id]--;
            l++;
        }
        if(kinds == kind) {                 //符合条件
            ans = min(ans, c[r].x - c[l].x);
        } 
    }
    cout << ans << " " << kind << endl;
    return 0;
}
```

## T3. 圣诞礼物树

### 题目描述

圣诞节快到了，$FJ$ 计划用礼物来装扮家门口的 $N$ 棵圣诞松树（编号 $1 \sim N$，且 $N$ 是奇数， $1≤N≤1,000,000$ ），也就是将礼物挂在这些树上。 $FJ$ 会告诉他最信任的奶牛 $Bessie$ 一共 $K$ 个命令，每个命令包含两个整数 $A$ 和 $B$ ，表示 $Bessie$ 需要将编号为 $A \sim B$ 范围内的所有圣诞树上各挂上一个礼物。例如，如果命令是`9 12`，那么 $Bessie$ 应该给编号为 $9,10,11,12$ 的圣诞树各增加一个礼物。 

当 $Bessie$ 执行完所有的命令后， $FJ$ 想知道这 $N$ 棵圣诞树上的礼物数量的中位数是多少，也就是如果把这 $N$ 棵圣诞树按照礼物数量排序，序列的中间值是多少？

因为 $N$ 是奇数，所以中间值是惟一的。请帮助 $Bessie$ 计算出答案。

### 输入格式

第一行，用空格隔开的两个整数分别表示 $N$ 和 $K$（$1≤N≤1000000；1≤K≤25000$）

接下来 $K$ 行，表示 $FJ$ 的 $K$ 个命令，格式是`A B`，其中 $1≤A≤B≤N$

### 输出格式

输出一行，一个整数，表示 $N$ 棵圣诞树上的礼物数量的中位数

### 输入输出样例

#### 输入样例1：

```
7 4
5 5
2 4
4 6
3 5
```

#### 输出样例1：
```
1
```

### 题解

题目翻译：给一个长度为 $n$ 的序列作 $k$ 次操作，每次操作把 $[a,b] + 1$，求最后将所有树排序后序列中间的值。

$[a,b] + 1$，显然是区间修改，是差分数组跑不了（其实线段树和树状数组也不是不行，就是编码难度大，而且这题最后要每个树排序，用差分数组求前缀和最方便）。做完差分数组的修改后，再把数据通过求前缀和复原并求中位数即可。

```c++
#include <bits/stdc++.h>
using namespace std;

#define ll long long
const ll N = 1e6 + 1;
ll d[N], arr[N];
ll n, k, a, b;

int main() {
    cin >> n >> k;
    for(int i = 1; i <= k; i++) {
        cin >> a >> b;
        d[a]++, d[b + 1]--;         //区间修改
    }
    for(int i = 2; i <= n; i++) {
        d[i] += d[i - 1];           //前缀和
    }
    //求中位数
    sort(d + 1, d + n + 1);
    cout << d[(n + 1) / 2] << endl;
    return 0;
}
```