---
title: 省赛冲刺1
date: 2024-12-07 18:36:38
tags:
---

## T2. 奶牛队伍

### 题目描述

$FJ$ 养了 $N$ 头奶牛，它们站在一条直线上，其中第i头奶牛在直线上的位置为 $x_i$（ $x_i$ 一定是整数）。除此以外，每头奶牛都有一个品种类型，用整数 $id_i$ 表示，可能存在多头奶牛属于同一个品种类型。

现在FJ希望从N头奶牛中挑选若干头奶牛拍一张照片，要求照片中每个不同品种的奶牛至少有一头，这张照片的花费取决于照片的宽度，即照片中最右边的奶牛位置和最左边的奶牛位置之差。

现在，请你计算出满足 $FJ$ 要求的照片最小花费。

### 输入格式

第1行一个整数 $N$ ，表示奶牛数量 $(1 \leq N \leq 5 \times 10^4)$

第2行到第 $N+1$ 行，每行两个整数，分别表示每头奶牛的位置 $x_i$ 和品种类型 $id_i$（ $x_i$ 和 $id_i$ 不超过 $10^9$）

### 输出格式

输出一行，一个整数，表示照片的最小花费

### 输入输出样例

#### 输入样例1

```
6
25 7
26 1
15 1
22 3
20 1
30 1
```

#### 输出样例1

```
4
```

### 题解

题目的直白翻译：选择一个长度最短的区间使区间内 __包含所有品种的奶牛__。

遇到在一条线上的坐标问题，首先对坐标进行排序。

区间选择问题，首先尝试枚举每个区间，找找优化的方案。对于每个区间，我们要维护区间内的奶牛种数，然后与总品种数进行比较。

区间枚举问题，优化方案首选 __双指针__，即用 $l,r$ 维护一个区间 $[l,r]$。我们让 $r$ 指针在 $1 \sim n$ 之间滑动，对于每个 $r$，我们找到一个最优的 $l$，再是否判断符合条件并记录。这里有几个小点需要注意：

1. 由于题目给到的 $id_i$ 范围特别大，我们用普通的桶装不下，此时可以使用 `map` 来代替桶。在每次让 $r$ 进入区间时，在 `map` 中标记。
2. 对于统计区间不同种类数的统计，我们可以在 `map` 标记时检查标记后的值是否为 $1$。
3. 如果 $l$ 不是最优的，当且仅当牛 $l$ 的 $id$ 在 $[l,r]$ 中的出现次数 $\ge 2$，此时删去 $l$，区间的奶牛种类数不会减少。

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll N = 50001;
ll n, kind = 0;
struct Cow {
    ll id, x;
} c[N];
map<ll, ll> m, m1;

bool Cmp(Cow &a, Cow &b) {
    return a.x < b.x;
}

int main() {
    cin >> n;
    for(ll i = 1; i <= n; i++) {
        cin >> c[i].x >> c[i].id;
        if(++m1[c[i].id] == 1) {
            kind++;
        }
    }
    sort(c + 1, c + n + 1, Cmp);
    ll l = 1, r = 1, kinds = 0, ans = LLONG_MAX;
    for(; r <= n; r++) {
        if(++m[c[r].id] == 1) kinds++;      //r进入区间
        while(l < r && m[c[l].id] > 1) {    //维护最优的l
            m[c[l].id]--;
            l++;
        }
        if(kinds == kind) {                 //符合条件
            ans = min(ans, c[r].x - c[l].x);
        } 
    }
    cout << ans << " " << kind << endl;
    return 0;
}
```

## T3. 圣诞礼物树

### 题目描述

圣诞节快到了，$FJ$ 计划用礼物来装扮家门口的 $N$ 棵圣诞松树（编号 $1 \sim N$，且 $N$ 是奇数， $1≤N≤1,000,000$ ），也就是将礼物挂在这些树上。 $FJ$ 会告诉他最信任的奶牛 $Bessie$ 一共 $K$ 个命令，每个命令包含两个整数 $A$ 和 $B$ ，表示 $Bessie$ 需要将编号为 $A \sim B$ 范围内的所有圣诞树上各挂上一个礼物。例如，如果命令是`9 12`，那么 $Bessie$ 应该给编号为 $9,10,11,12$ 的圣诞树各增加一个礼物。 

当 $Bessie$ 执行完所有的命令后， $FJ$ 想知道这 $N$ 棵圣诞树上的礼物数量的中位数是多少，也就是如果把这 $N$ 棵圣诞树按照礼物数量排序，序列的中间值是多少？

因为 $N$ 是奇数，所以中间值是惟一的。请帮助 $Bessie$ 计算出答案。

### 输入格式

第一行，用空格隔开的两个整数分别表示 $N$ 和 $K$（$1≤N≤1000000；1≤K≤25000$）

接下来 $K$ 行，表示 $FJ$ 的 $K$ 个命令，格式是`A B`，其中 $1≤A≤B≤N$

### 输出格式

输出一行，一个整数，表示 $N$ 棵圣诞树上的礼物数量的中位数

### 输入输出样例

#### 输入样例1：

```
7 4
5 5
2 4
4 6
3 5
```

#### 输出样例1：
```
1
```

### 题解

题目翻译：给一个长度为 $n$ 的序列作 $k$ 次操作，每次操作把 $[a,b] + 1$，求最后将所有树排序后序列中间的值。

$[a,b] + 1$，显然是区间修改，是差分数组跑不了（其实线段树和树状数组也不是不行，就是编码难度大，而且这题最后要每个树排序，用差分数组求前缀和最方便）。做完差分数组的修改后，再把数据通过求前缀和复原并求中位数即可。

```c++
#include <bits/stdc++.h>
using namespace std;

#define ll long long
const ll N = 1e6 + 1;
ll d[N], arr[N];
ll n, k, a, b;

int main() {
    cin >> n >> k;
    for(int i = 1; i <= k; i++) {
        cin >> a >> b;
        d[a]++, d[b + 1]--;         //区间修改
    }
    for(int i = 2; i <= n; i++) {
        d[i] += d[i - 1];           //前缀和
    }
    //求中位数
    sort(d + 1, d + n + 1);
    cout << d[(n + 1) / 2] << endl;
    return 0;
}
```

## T4. 操作

### 题目描述

小可可有一个数组 $\{a_n\}$（初始值为 $\{a_n\}=\{0,0,\ldots,0\}$）和从左到右的 $m$ 个机器，其中第 $i$ 个机器有类别 $o_i \in \{1,2\}$ 和参数 $x_i,y_i$。第 $i$ 个机器执行的操作如下：

- 若 $o_i=1$，则将 $a_{(x_i)}$ 加上 $y_i$，此时保证 $1 \le x_i \le n$，$1 \le y_i \le 10^4$。
- 若 $o_i=2$，则执行第 $x_i \sim y_i$ 个机器的操作各一次，此时保证 $1 \le x_i \le y_i \le i-1$。
- 特别地，保证 $o_1=1$。

现在，小可可依次执行了第 $c_1,c_2,\ldots,c_k$ 个机器的操作各一次，她想知道最后得到的数组 $\{a_n\}$ 是什么。

由于数组中元素的值可能很大，你只需要帮她求出每个元素除以 $10007$ 的余数即可。

### 输入格式

第一行三个正整数 $n,m,k$。

接下来一行 $k$ 个正整数 $\{c_k\}$。

接下来 $m$ 行，第 $i$ 行三个正整数 $o_i,x_i,y_i$。

### 输出格式

一行 $n$ 个非负整数，表示数组 $\{a_n\}$ 中每个元素的值除以 $10007$ 的余数。

### 样例 #1

#### 样例输入 #1

```
2 3 3
1 2 3
1 1 2
2 1 1
2 1 2
```

#### 样例输出 #1

```
8 0
```

### 提示

#### 样例 1 解释

先执行第 $1$ 个机器的操作，给 $a_1$ 加上了 $2$。

然后执行第 $2$ 个机器的操作，它操作了第 $1$ 个机器，给 $a_1$ 加上了 $2$。

然后执行第 $3$ 个机器的操作。它先操作了第 $1$ 个机器，给 $a_1$ 加上了 $2$；然后操作了第 $2$ 个机器，第 $2$ 个机器又操作了第 $1$ 个机器，给 $a_1$ 加上了 $2$。

综上所述，最后得到的数组为 $\{8,0\}$。

#### 数据范围

对于 $10\%$ 的数据，$n,m,k \le 10$。

对于 $30\%$ 的数据，$n,m,k \le 1000$。

对于另外 $20\%$ 的数据，$n=1$。

对于另外 $20\%$ 的数据，$k=1$。

对于 $100\%$ 的数据，$1 \le n,m,k \le 2 \times 10^5$，$1 \le c_i \le n$，$o_i \in \{1,2\}$，$o_1=1$。此外，对于第 $i$ 个机器，保证：

- 若 $o_i=1$，则 $1 \le x_i \le n$，$1 \le y_i \le 10^4$。
- 若 $o_i=2$，则 $1 \le x_i \le y_i \le i-1$。

### 题解

题目翻译：给定一个操作序列 $c$，请按顺序执行机器 $c_i$。有两类机器：一类和二类。一类可以将 $a_{x_i}+=y_i$，二类要执行机器 $x_i \sim y_i$。

看完题目，可以发现对于机器 $i$，只需要求它被执行的 __次数__ 就能得出答案，没必要模拟。题目中二类机器的操作是区间修改一些机器的执行次数，所以我们考虑用 __差分数组__ 来解决。

- 对于一类机器，它们可以直接修改 $a_x$，所以每被直接执行一次，执行次数 $+=1$
- 对于二类机器，它们需要间接执行其他机器，所以每被直接执行一次，机器 $[x,y]$ 的执行次数 $+= 自己的执行次数$

现在问题来了，由于二类机器的被执行次数可能在不同时间会发生 __改变__，所以我们要考虑如何统计完整一个二类机器的执行次数。

> 若 $o_i=2$，则执行第 $x_i \sim y_i$ 个机器的操作各一次，此时保证 $1 \le x_i \le y_i \le i-1$。

注意一个要点：$1 \le x_i \le y_i \le i-1$。也就是说每个机器只能执行编号在它 __之前__ 的机器。这样一来，每个机器的执行次数就由它后面的机器的执行次数确定，所以我们 __从后往前__ 遍历每个机器，每个机器的执行次数就是它之后的差分数组求前缀和。

因为是从后往前地遍历，所以差分数组也要倒过来，原本的 $d_1$ 变成了 $d_m$，此时区间修改也要倒过来：

```c++
//[l,r]+1
d[r]++;
d[l-1]--;
```

完整代码：

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll N = 2e5 + 1, MOD = 10007;

ll n, m, k;
ll o[N], x[N], y[N], cf[N], ans[N], cnt[N];
int main() {
    cin >> n >> m >> k;
    //在输入操作序列时初始统计执行次数
    while(k--) {
        int c;
        cin >> c;
        cf[c]++, cf[c-1]--;
    }
    for(ll i = 1; i <= m; i++) cin >> o[i] >> x[i] >> y[i];
    //从后往前遍历每个机器
    for(ll i = m; i >= 1; i--) {
        //机器 i 被执行了 cnt[i] 次
        cnt[i] = ((cnt[i+1] + cf[i]) % MOD + MOD) % MOD;
        //二类机器
        if(o[i] == 2) {
            //[x[i], y[i]]+=cnt[i]
            cf[y[i]] += cnt[i];
            cf[x[i]-1] -= cnt[i];
        }
    }
    for(ll i = m; i >= 1; i--) {
        //是一类机器再执行修改
        if(o[i] == 1) 
            ans[x[i]] = (ans[x[i]] + cnt[i] * y[i]) % MOD;
    }
    for(int i = 1; i <= n; i++) cout << ans[i] << " ";
    return 0;
}
```