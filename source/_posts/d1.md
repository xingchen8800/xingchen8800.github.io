---
title: 提高day1
date: 2024-05-19 17:22:46
categories: 
- [提高组,课程]
- [算法,模拟]
tags:
---

# 填写特殊字符 
###### [经典例题] [模拟] [day01] [提高-]
## 题目描述:
$ N*N $ ($n<9$)的网格中,填写一些特殊字符,分别是! @ \# \$ \% ^ & * (他们之间的大小关系是 !<@<#<$<%<^<&<*)。

要求用这些字符填满$ N*N $的网格,每个网格的字母上下左右各不相同,同时要求网格元素尽可能的小。(有些网格可能已经预填字符)(大小比较,先行后列)


例如:$ 2*2 $的网格中,
1@
@!
输入$ N $组数据,输入$ n $,输入$ n*n $网格。

## 输入样例:
``` text
2
3
...
...
...
3
...
!..
...
```

## 输出样例:
```
!@!
@!@
!@!

@!@
!@!
@!@
```

## 解题思路
由于题目中的8个字符为升序，自然地选择以数组存储，下标小的是大的，即
``` c++
const char str[9] = "!@#$%^&*"
```
接下来进行模拟:

- 遍历输入中的每一位，是'.'的进入判断，一位记作 __s[i][j]__
- 遍历str，即在str中选择一个 __合适的最小的字符__ 填入s[i][j]
    - 判断是否 __不是第一行__ 并且 __与上面的__ 不同
    - 判断是否 __不是最左边__ 并且 __与左边的__ 不同
    - 判断是否 __不是最左边__ 并且 __与左边的__ 不同
    - 判断是否 __不是最右边__ 并且 __与右边的__ 不同

最后输出：
```c++
for(int i = 0; i < n; i++) {
    for(int j = 0; j < n; j++) {
        cout << s[i][j];
    }
    cout << endl;
}
```

## AC代码+注释解释
```c++
#include <bits/stdc++.h>
using namespace std;

int N, n;
const string str = "!@#$%^&*";

void solution(int n) {
    char s[11][11];
    //第一步：输入
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            cin >> s[i][j];
        }
    }
    //第二步：模拟
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            if(s[i][j] == '.') {    //需要进行填充
                for(int k = 0; k < 9; k++) {    //k为被填充的字符在str中的下标
                    bool ok = true;         //标记是否可以填充str[k]到s[i][j]中
                    //判断
                    if(i > 0 && s[i - 1][j] == str[k]) ok = false;      //不是第一行并且与上面的不同
                    if(i < n - 1 && s[i + 1][j] == str[k]) ok = false;  //不是最后一行并且与下面的不同
                    if(j > 0 && s[i][j - 1] == str[k]) ok = false;      //不是最左边并且与左边的不同
                    if(j < n - 1 && s[i][j + 1] == str[k]) ok = false;  //不是最右边并且与右边的不同
                    if(ok) {//如果可以填充str[k]到s[i][j]中
                        s[i][j] = str[k];   //填充
                        break;              //结束循环
                    }
                }
            }
        }
    }
    //第三步：输出
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) {
            cout << s[i][j];
        }
        cout << endl;
    }
    return;     //完成
}

int main() {
    cin >> N;
    while(N--) {
        cin >> n;
        solution(n);
    }
    return 0;
}
```

# [玩具谜题](https://www.luogu.com.cn/problem/P1563)
###### [经典例题] [模拟] [day01] [提高-] [NOIP2016]
## 描述

小南有一套可爱的玩具小人, 它们各有不同的职业。

有一天, 这些玩具小人把小南的眼镜藏了起来。 小南发现玩具小人们围成了一个圈,它们有的面朝圈内,有的面朝圈外。如下图:

这时 singer 告诉小南一个谜題: “眼镜藏在我左数第 3 个玩具小人的右数第 1 个玩具小人的左数第 2 个玩具小人那里。 ”

小南发现, 这个谜题中玩具小人的朝向非常关键, 因为朝内和朝外的玩具小人的左右方向是相反的: 面朝圈内的玩具小人, 它的左边是顺时针方向, 右边是逆时针方向; 而面向圈外的玩具小人, 它的左边是逆时针方向, 右边是顺时针方向。

小南一边艰难地辨认着玩具小人, 一边数着:

singer 朝内, 左数第 3 个是 archer。

archer 朝外,右数第 1 个是 thinker 。

thinker 朝外, 左数第 2 个是 writer。

所以眼镜藏在 writer 这里!

虽然成功找回了眼镜, 但小南并没有放心。 如果下次有更多的玩具小人藏他的眼镜, 或是谜题的长度更长, 他可能就无法找到眼镜了。所以小南希望你写程序帮他解决类似的谜题。 这样的谜題具体可以描述为:

有 n 个玩具小人围成一圈, 已知它们的职业和朝向。现在第 1 个玩具小人告诉小南一个包含 m 条指令的谜題, 其中第 z 条指令形如“左数/右数第 s 个玩具小人”。 你需要输出依次数完这些指令后,到达的玩具小人的职业。

## 输入描述

输入的第一行包含两个正整数 n,m，表示玩具小人的个数和指令的条数。

接下来 n 行，每行包含一个整数和一个字符串，以逆时针为顺序给出每个玩具小人的朝向和职业。其中 0 表示朝向圈内，1 表示朝向圈外。 保证不会出现其他的数。字符串长度不超过 10 且仅由小写字母构成，字符串不为空，并且字符串两两不同。整数和字符串之间用一个空格隔开。

接下来 m 行，其中第 i 行包含两个整数 $ai$​,$si$​，表示第 i 条指令。若 $ai​=0$，表示向左数 $si$​ 个人；若 $ai​=1$，表示向右数 $si$​ 个人。 保证 $ai$​ 不会出现其他的数，$1≤si​<n$。

## 输出描述

输出一个字符串，表示从第一个读入的小人开始，依次数完 m 条指令后到达的小人的职业。

## 样例1：
### 输入：
```
7 3
0 singer
0 reader
0 mengbier 
1 thinker
1 archer
0 writer
1 mogician 
0 3
1 1
0 2
```
### 输出：
```
writer
```
## 样例2：
### 输入
```
10 10
1 C
0 r
0 P
1 d
1 e
1 m
1 t
1 y
1 u
0 V
1 7
1 1
1 4
0 5
0 3
0 1
1 6
1 2
0 8
0 4
```
### 输出：
```
y
```


## 解题思路：

这道题目比较绕，其实很简单：

__就是判断顺时针数还是逆时针数！！！__

选取结构体存储：
```c++
struct Node {
    string name;
    bool rotation;
} a[100001];
```

推理如下：

朝向 |   数的方向 |    实际方向
-|-|-
内(0)  |    左(0)       |   顺时针
内(0)  |    右(1)       |   逆时针
外(1)  |    左(0)       |   逆时针
外(1)  |    右(1)       |   顺时针

可以发现：

朝向与数的方向相同时是顺时针，不同时是逆时针
```c++
int index = 0; //从头开始数
while(m--) {
    cin >> x >> y;
    if(a[index].rotation ^ x) index = (index + y) % n;
    else index = (index + n - y) % n; //index + n是为了防止越界为负数
}
```

## AC代码：
```c++
#include <iostream>
using namespace std;

int m, n;
struct Node {
    string name;
    bool rotation;
} a[100001];

int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; i++) 
        cin >> a[i].rotation >> a[i].name;    
    int x, y;   //等待输入方向(x)与个数(y)
    int index = 0; //从头开始数
    while(m--) {
        cin >> x >> y;
        if(a[index].rotation ^ x) index = (index + y) % n;
        else index = (index + n - y) % n; //index + n是为了防止越界为负数
    }

    cout << a[index].name << endl;
    return 0;
}
```

# 偶数矩阵
##### [经典例题] [枚举]
## 描述

给你一个 n×n 的01矩阵（每个元素非 0 即 1），你的任务是把尽量少的 0 变成 1，使得每个元素的上、下、左、右的元素（如果存在的话）之和均为偶数。比如，左边所示的矩阵至少要把 3 个 0 变成 1，最终右边图所示，才能保证其为偶数矩阵。

## 输入描述

第一行是正整数 n，接下来的 n 行每行包含 n 个非 0 即 1 的整数，相邻整数间用一个空格隔开。

## 输出描述

对于每组数据，输出被改变的元素的最小个数。如果无解，应输出 −1。

## 样例输入 1
```
3
0 0 0
1 0 0 
0 0 0
```
## 样例输出 1
```
3
```

## 解题思路

由题意知：我们只要枚举出n×n的01矩阵的所有情况，比较差异，计算最小差异即可。并且在01矩阵中，一旦确定第一行，就确定了整个矩阵。所以只要枚举第一行($ 2^n $)即可。

## AC代码+注释解释
```c++
#include <iostream>
using namespace std;

int n, a[16][16], b[16][16];
/* a矩阵是原矩阵，b矩阵是填充后*/

/*求解：枚举第一行*/
int solution(int first_line) {
    memset(b, 0, sizeof(b));    //初始化b矩阵
    //1、将二进制数据转化为一维的01数组
    for(int i = n - 1; i >= 0; i--) {
        if(s % 2 == 1) b[0][i] = 1;
        else b[0][i] = 0;
        if(a[0][i] == 1 && b[0][i] == 0) return -1; /*如果填充的不是0，就不合法*/
    }
    //2、处理剩下的n-1行的同时计算差异
    int cnt = 0;
    for(int i = 1; i < n; i++) {
        for(int j = 0; j < n; j++) {
            int sum = 0;
            if(i > 1) sum += b[i - 2][j];       //不是第一行，取上上方
            if(j > 0) sum += b[i - 1][j - 1];   //不是第一列，取左上方
            if(j < n - 1) sum += b[i - 1][j + 1];   //不是最后一列，取右上方
            b[i][j] = sum % 2;  //确定 b[i][j];
            if(a[i][j] == 1 && b[i][j] == 0) return -1; /*如果填充的不是0，就不合法*/
            if(a[i][j] != b[i][j]) cnt++;
        }
    }
    //3、返回
    return cnt;
}

int main() {
    cin >> n;
    //输入
    for(int i = 0; i < n; i++) {
        for(int j = 0; j < n; j++) cin >> a[i][j];
    }
    int min = 1145;
    //枚举
    for(int i = 1; i < (1 << n); i++) {
        min = min(min, solution(i));
    }
    //输出
    cout << (min == 1145 ? -1 : min) << endl;
    return 0;
}
```