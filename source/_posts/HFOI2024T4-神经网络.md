---
title: HFOI2024T4-神经网络
date: 2024-11-16 22:34:49
tags:
    - C++
    - 省选
categories:
    - [CSP,CSP-S,非课程]
    - [算法,图,最短路径]
    - [算法,图,网络流]
excerpt: 本题类似于ICPC-BJ2006中的狼抓兔子，主要复习网络流图中最小割与对偶图中最短路的转化。
---

[洛谷链接](https://www.luogu.com.cn/problem/U505752)

本蒟蒻又来写题解了。本人比较弱，请 $dalao$ 多多指教。

# 【题目描述】
小 $C$ 最近在研究神经网络。他发现神经网络可以看成一个网格，最左上角的坐标为 $(1, 1)$，最右下角的坐标为 $(n, m)$。当 $1≤x≤n$、$1≤y<m$ 时，坐标 $(x,y)$ 和 $(x,y+1)$ 之间有一条 __无向边__，边权为 $wa_{x,y}$；当 $1≤x<n$、$1≤y≤m$ 时，坐标 $(x,y)$ 和 $(x+1,y)$ 之间有一条 __无向边__ ，边权为 $wb_{x,y}$。下图展示了一个 $3×4$ 的神经网络，其中红色边的边权 $wa$，蓝色边的边权为 $wb$。

![T4图](/images/省选/HFOI2024T4-1.png)

神经网络具备传输信号的能力。小 $C$ 发现信号从 $(1, 1)$ 通过网络中的边传递到 $(n, m)$。

然而，某些边可能会突然失活，而信号无法通过失活的边传输。当信号无法从 $(1, 1)$ 传递到 $(n, m)$ 时，整个神经网络将会失活。小 $C$ 发现，当边的权值越大，这条边越难以失活。

据此小 $C$ 定义了一个“稳定系数”，即使得整个神经网络失活的最小边权和。

现在小 $C$ 告诉你这个神经网络，并希望你回答它这个神经网络的稳定系数是多少。

# 【输入格式】

从文件 `network.in` 中读取数据。
第一行包含两个整数 $n$ 和 $m$，分别表示网格的行数和列数。
接下来的 $n$ 行，每行包含 $m −1$ 个整数，依次表示边权 $wa_{x,y}$。
接下来的 $n −1$ 行，每行包含 $m$ 个整数，依次表示边权 $wb_{x,y}$。

# 【输出格式】

输出到文件 `network.out` 中。
仅一行，一个整数表示其稳定系数。

# 【样例 1 输入】
```
2 2
4
2
3 0
```

# 【样例 1 输出】
```
2
```

# 【样例 1 解释】
该样例描述的神经网络如下图所示。

![T4-2](/images/省选/HFOI2024T4-2.png)

可以证明，按照图中红色边的选法，即得到使得神经网络失活的最小边权和。

# 【样例 2 输入】
```
3 3
2 0
1 6
4 1
5 1 1
4 2 5
```
# 【样例 2 输出】
```
5
```
# 【样例 2 解释】

该样例描述的神经网络如下图所示。

![T4-3](/images/省选/HFOI2024T4-3.png)

可以证明，按照图中红色边的选法，即得到使得神经网络失活的最小边权和。

# 【数据范围】

![数据范围](/images/省选/HFOI2024T4-4.png)

# 题解

{% note green fa-book %}
同类题目：[狼抓兔子](https://www.luogu.com.cn/problem/P4001)、[海拔](https://www.luogu.com.cn/problem/P2046)
{% endnote %}

[网络流传送门](https://xingchen8800.github.io/2024/11/10/网络流/)

题面翻译：给定 $n \times m$ 的网格图，求其最小割。

## 测试点1~3

此时 $n=2$，枚举出 $2$ 种割边方案，比较大小即可。

## 测试点7~8

此时 $n=3$，暴力枚举并检验即可。

## 测试点1~15

建图并跑 $ISAP$ 求最大流，最大流的值就是最小割。

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1001, M = 1001, INF = 0x3f3f3f3f;
int node[N][N];
struct Edge {
    int v, c, nxt;
} l[N * M * 8];
int h[N*M], cnt = 1;
int S, T, tot = 0;

void AddEdge(int u, int v, int c) {
    l[++cnt] = {v, c, h[u]}; h[u] = cnt;
    l[++cnt] = {u, 0, h[v]}; h[v] = cnt; 
}

int dis[N*M], gap[N*M];
int Stream(int u, int cur) {
    int sum = 0, d;
    if(u == T) return cur;
    for(int i = h[u], v; i; i = l[i].nxt) {
        v = l[i].v;
        if(l[i].c > 0 && dis[v] + 1 == dis[u]) {
            d = Stream(v, min(l[i].c, cur));
            l[i].c -= d, l[i^1].c += d;
            sum += d, cur -= d;
            if(dis[S] == tot || !cur) return sum;
        }
    }
    if(!(--gap[dis[u]])) dis[S] = tot;
    gap[++dis[u]]++;
    return sum;
}

int Sap() {
    int ans = 0;
    memset(dis, 0, sizeof dis);
    memset(gap, 0, sizeof gap);
    gap[0] = tot;
    while(dis[S] < tot) ans += Stream(S, INF);
    return ans;
}

#undef int

int main() {

#define int long long
    int n, m; cin >> n >> m;
    //建图
    for(int i = 1; i <= n; i++) {
    	for(int j = 1; j <= m; j++) {
    		node[i][j] = ++tot;
		}
	} 
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m - 1; j++) {
            int w; cin >> w;
            AddEdge(node[i][j], node[i][j+1], w);
            AddEdge(node[i][j+1], node[i][j], w);
        }
    }
    for(int i = 1; i <= n - 1; i++) {
        for(int j = 1; j <= m; j++) {
            int w; cin >> w;
            AddEdge(node[i][j], node[i+1][j], w);
            AddEdge(node[i+1][j], node[i][j], w);
        }
    }
    //定义源点、汇点和总点数
    S = 1, T = tot;
    cout << Sap();  //ISAP算法出结果就是最小割
#undef int
    return 0;
}
```

## 100%数据

{% note red fa-star %}
前置结论：__网格图中的最小割就是对偶图中的最短路__
{% endnote %}

![T4题解-1](/images/省选/HFOI2024T4-5.png)

如图所示，我们可以把网格图中每个四条边框起来的面作为一个 $\color{orange}{节点}$，把面与面之间的边的割线看作是边（权值为对应边的权值），就能建出这张图。其中，所有在左下的外围边的割线与  $\color{green}{源点S}$ 相连（权值是对应边的权值），所有在右上的外围边的割线与  $\color{red}{汇点T}$ 相连（权值为对应边的权值）。

每一种网格图的割，就相当于一条从 $S$ 到 $T$ 的路径（把路径上的边的对应边看作割的一边），那么最小割自然就是对偶图的 __最短路径__！

$SPFA$ 代码，被~~自己~~随机生成的数据卡了5分（$16$ 号点）。
```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1001, M = 1001, INF = 0x3f3f3f3f;
int node[N][M]; //面的编号

//链式前向星模板
struct Edge {
    int u, v, w, nxt;
} l[N * M * 4];
int h[N * M], cnt = 0;
int S, T, tot = 0;

void AddEdge(int u, int v, int w) {
    l[++cnt] = {u, v, w, h[u]}; h[u] = cnt; 
}

//SPFA模板
int dis[N * M], vis[N * M], _cnt[N * M];
bool SPFA(int s) {
    memset(dis, 0x3f, sizeof dis);
    queue<int> q;
    q.push(s);
    dis[s] = 0;
    vis[s] = 1;
    while(q.size()) {
        int u = q.front(); q.pop(); vis[u] = false;
        for(int i = h[u], v, w; i; i = l[i].nxt) {
            v = l[i].v; w = l[i].w;
            if(dis[v] > dis[u] + w) {
                dis[v] = dis[u] + w;
                
                if(vis[v]) continue;
                
                vis[v] = true;
                q.push(v);
                _cnt[v]++;
                if(_cnt[v] > tot) return false;
            }
        }
    }
    return true;
}

#undef int

int main() {
	freopen("network.in", "r", stdin);
	freopen("network.out", "w", stdout);
    int n, m; cin >> n >> m;
    //建图
    for(int i = 1; i <= n - 1; i++) {
    	for(int j = 1; j <= m - 1; j++) {
    		node[i][j] = ++tot;
		}
	} 
    S = ++tot, T = ++tot;
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m - 1; j++) {
            int w; cin >> w;
            if(i == 1) {                        //上层最外侧，与超级汇点连接
                AddEdge(node[i][j], T, w);
                AddEdge(T, node[i][j], w);
            } else if(i == n) {                 //下层最外侧，与超级源点连接
                AddEdge(node[i - 1][j], S, w);
                AddEdge(S, node[i - 1][j], w);
            } else {                            //中间层，将左右边转成上下边，作为对偶图的连边
                AddEdge(node[i - 1][j], node[i][j], w);
                AddEdge(node[i][j], node[i - 1][j], w);
            }
        }
    }
    for(int i = 1; i <= n - 1; i++) {
        for(int j = 1; j <= m; j++) {
            int w; cin >> w;
            if(j == 1) {                        //左侧最外侧，与超级源点连接
                AddEdge(node[i][j], S, w);
                AddEdge(S, node[i][j], w);
            } else if(j == m) {                 //右侧最外侧，与超级汇点连接
                AddEdge(node[i][j - 1], T, w);
                AddEdge(T, node[i][j - 1], w);
            } else {                            //中间层，将上下边转成左右边，作为对偶图连边
                AddEdge(node[i][j - 1], node[i][j], w);
                AddEdge(node[i][j], node[i][j - 1], w);
            }
        }
    }
    SPFA(S);            //对偶图最短路=平面图最大流=最小割
    cout << dis[T] << endl;
    return 0;
}
```

$Dijsktra$ 做法，$100pts$
```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;

const int N = 1001, M = 1001, INF = 0x3f3f3f3f;
int node[N][M];
struct Edge {
    int u, v, w, nxt;
} l[N * M * 10];
int h[N * M], cnt = 0;
int S, T, tot = 0;

void AddEdge(int u, int v, int w) {
    l[++cnt] = {u, v, w, h[u]}; h[u] = cnt; 
}

int dis[N * M], vis[N * M];

void Dijsktra(int s) {
    //初始化
    memset(dis, 0x3f, sizeof dis);
    memset(vis, false, sizeof vis);
    
    //s入队
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > q; //优先队列免去了在dis中找最小值的操作
    dis[s] = 0;
    q.push({0, s});
    
    //bfs
    while(q.size()) {
        pair<int, int> _pair = q.top(); q.pop(); //取出队首
        int u = _pair.second;   //获取节点
        if(!vis[u]) {
            vis[u] = true;
            int v, w;  //邻接点和权值
            //遍历邻接点
            for(int i = h[u]; i; i = l[i].nxt) {
                v = l[i].v;  //邻接点
                w = l[i].w;  //权值
                if(!vis[v] && dis[v] > dis[u] + w) {    //松弛
                    dis[v] = dis[u] + w;
                    q.push({dis[v], v});
                }
            }
        }
    }
}
#undef int

int main() {
    int n, m; cin >> n >> m;
    //建图
    for(int i = 1; i <= n - 1; i++) {
    	for(int j = 1; j <= m - 1; j++) {
    		node[i][j] = ++tot;
		}
	} 
    S = ++tot, T = ++tot;
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m - 1; j++) {
            int w; cin >> w;
            if(i == 1) {
                AddEdge(node[i][j], T, w);
                AddEdge(T, node[i][j], w);
            } else if(i == n) {
                AddEdge(node[i - 1][j], S, w);
                AddEdge(S, node[i - 1][j], w);
            } else {
                AddEdge(node[i - 1][j], node[i][j], w);
                AddEdge(node[i][j], node[i - 1][j], w);
            }
        }
    }
    for(int i = 1; i <= n - 1; i++) {
        for(int j = 1; j <= m; j++) {
            int w; cin >> w;
            if(j == 1) {
                AddEdge(node[i][j], S, w);
                AddEdge(S, node[i][j], w);
            } else if(j == m) {
                AddEdge(node[i][j - 1], T, w);
                AddEdge(T, node[i][j - 1], w);
            } else {
                AddEdge(node[i][j - 1], node[i][j], w);
                AddEdge(node[i][j], node[i][j - 1], w);
            }
        }
    }
    Dijsktra(S);
    cout << dis[T] << endl;
    return 0;
}

```