---
title: 二分法
date: 2024-07-04 21:31:13
categories:
  - - 《算法竞赛》
    - 第二章
  - [算法,搜索,二分查找]
tags: 
    - C++
    - CSP入门组
    - CSP提高组
---

{% notel default fa-info 提示 %}
后面的部分 __没有完成__，要等到图以后才更新。

24/10/3 附加：万能二分模板
{% endnotel %}

二分法就是不断地将一个序列一分为二，判断答案所在的区间（左或有），将答案所在的区间作为新的序列继续一分为二，直到达到（接近）答案为止。时间复杂度为 $O(nlog_2n)$

{% note red fa-bolt %}
 __一般情况下__ 二分的对象是 __题目提问的对象__。
{% endnote %}

二分解决实际问题的思路一般为二分 __题目提问的对象__，通过结合其他算法的方式 __验证__ 当前答案的可行性，再根据可行性决定下一步的区间。

# 理论背景
二分法本来的作用是求线性方程（在区间内满足 __单调性__）的根

# 整数二分

{% notel yellow fa-info 注意 %}
在 __整数二分__ 中，难点在于中间值`mid`的处理，如：

1. `l`是取`mid - 1`还是`mid`？（在 __整数二分__ 中，一般采用`mid - 1`，否则容易陷入死循环）
2. `r`是取`mid`还是`mid + 1`？（在 __整数二分__ 中，一般采用`mid + 1`，否则容易陷入死循环）
3. `mid`是取左中位数（`mid = left + (right - left) >> 1`//更接近`left`）还是右中位数（`mid = left + (right - left + 1) >> 1`//更接近`right`）？

这些都需要结合具体的问题来分析（~~其实模拟一下才知道~~）
{% endnotel %}

## 框架
```c++
int l = 1, r = n, mid;
while(l < r) {
    mid = l + (l - r) >> 1;
    if(/*答案在左区间*/) {
        r = mid /*-1*/;
    } else {
        l = mid /*+1*/;
    }
}
```

## 在单调递增序列中查找x或大于x且最接近x的数
{% notel blue fa-file-lines 描述 %}

| 情况 | `方案` |
|:-:|:-:|
|有x| `返回x`|
|多个x|`返回第一个和x相等的数`|
|无x|`返回大于x且最接近x的数`|


{% endnotel %}

### 思路

1. 二分法，定义`left, right, middle`三个变量:`int left = 1, right = n, middle;`
2. 当`left < right`时不断循环，先计算`middle = left + (right - left) >> 1; //取左中位数是因为要找后继`。当`x`比`a[middle]`小时，说明答案在左区间，`right = middle - 1;`；当`x`比`a[middle]`大时，说明答案在右区间，`left = middle + 1`。
3. 最终，`left`（`right`也一样）就是`x`所在的位置。

### 代码
```c++
int binary_search(int *a, int n, int x) {
    int left = 1, right = n, middle;
    while(left < right) {
        middle = left + (right - left) >> 1;    //取平均值
        if(a[middle] >= x) { //在左区间
            right = middle - 1;
        } else {
            left = middle + 1;
        }
    }
    return left;
}
```

```c++
int binary_search(int *a, int n, int x) {
    int left = 1, right = n + 1, middle;
    while(left < right) {
        middle = left + (right - left + 1) >> 1;    //取平均值
        if(a[middle] >= x) {
            right = middle;
        } else {
            left = middle + 1; 
        }
    }
    return left;
}
```

## 在单调递增序列中查找x或小于x且最接近x的数
{% notel blue fa-file-lines 描述 %}

| 情况 | `方案` |
|:-:|:-:|
|有x| `返回x`|
|多个x|`返回第一个和x相等的数`|
|无x|`返回小于x且最接近x的数`|


{% endnotel %}

### 思路

1. 二分法，定义`left, right, middle`三个变量:`int left = 1, right = n, middle;`
2. 当`left < right`时不断循环，先计算`middle = left + (right - left + 1) >> 1; //取右中位数是因为要找前驱`。当`x`比`a[middle]`小时，说明答案在左区间，`right = middle - 1;`；当`x`比`a[middle]`大时，说明答案在右区间，`left = middle + 1`。
3. 最终，`left`（`right`也一样）就是`x`所在的位置。

### 代码
```c++
int binary_search1(int *a, int n, int x) {
    int left = 1, right = n, middle;
    while(left < right) {
        middle = left + (right - left + 1) >> 1;    //取平均值
        if(a[middle] >= x) { //在左区间
            right = middle - 1;
        } else {
            left = middle;  //右中位数不能+1
        }
    }
    return left;
}
```

```c++
int binary_search1(int *a, int n, int x) {
    int left = 1, right = n + 1, middle;
    while(left < right) {
        middle = left + (right - left) >> 1;    //取平均值
        if(a[middle] > x) {
            right = middle;
        } else {
            left = middle + 1; 
        }
    }
    return left;
}
```

## 整数二分的STL模板函数
`lower_bound(int *b, int *e, int x)`和`upper_bound(int *b, int *e, int x)`两个STL函数的功能：

| 项目 | 功能 |
|-|-|
| `lower_bound(int *b, int *e, int x)` | 在地址`b`到`e`中查找`x`或`x`的后继 |
| `upper_bound(int *b, int *e, int x)` | 在地址`b`到`e`中查找`x`或`x`的前驱 |

***
{% note yellow fa-warning %}
注意：`lower_bound`和`upper_bound`返回的是地址，获得相对位置要减去`a`！
{% endnote %}
{% note red fa-bolt %}
可以使用`lower_bound(a, a + n, x) - upper_bound(a, a + n, x)`来获得`a[]`中`x`的个数。
{% endnote %}

## 整数二分的建模

### T2.5 [两数之和](https://leetcode.cn/problems/two-sum/description/)

#### 题目描述

> 给定一个长度为$n$得数组$a$和一个正整数$m$（保证$m$为$a$数组中两个数的和），求$a$中的哪两个数的和是$m$（一个即可）。

#### 样例
输入：
```
9
21 4 5 6 13 65 32 9 23
28
```
输出：
```
5 23
```

#### 思路+代码
{% notel red fa-bolt 思路 %}

1. 对数组进行排序[复杂度 $O(nlog_2n)$ ]
2. 遍历数组，对于`a[i]`，通过二分法寻找`m - a[i]`[复杂度 $O(nlog_2n)$]
{% endnotel %}
```c++
//T2.5.cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int n, a[10001], m;
    cin >> n;
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    cin >> m;
    sort(a + 1, a + n + 1); //排序
    for(int i = 1; i <= n; i++) {
        int x = a[lower_bound(a + i + 1, a + n + 1, m - a[i]) - a]; //核心，找m-a[i]或其前驱
        if(x == m - a[i]) { //符合条件
            cout << a[i] << " " << x;   //输出
            return 0;
        }
    }
    return 0;
}
```

## 整数二分的经典模型
整数二分有两种经典模型： __最大值最小化__ 和 __最小值最大化__

### T2.6 序列划分
{% notel blue fa-file-lines 描述 %}
有一个序列，要将其划分为$m$个子序列（每个子序列都 __不为空__ ），记作 $S_1, S_2, S_3, \cdots, S_n$，请求出一个方案，使 $S_1, S_2, S_3, \cdots, S_n$ 的 __每个子序列的所有元素的和__ 的最大值最小。
{% endnotel %}

#### 思路
设一个$x$，使$x$对于任意$S_i$有$S_i \leq x$，即$x$是所有$S_i$中的 __元素和的最大值__ ，题目也就变成了使$x$最小。

因为一个序列的 __元素和的最大值__ 在$[max, sum]$中。
{% notel orange fa-pen 解释 %}
假设有序列$S={1,2,3,5,4}$

1. 若分为$S_1={1},S_2={2},S_3={3},S_4={5},S_5={4}$，则 __每个子序列的所有元素的和__ 的最大值就是 $S_4$ 中所有元素的和的值，为$5$，就是$S$中的最大值（max）。
2. 若分为$S_1={1,2,3,5,4}$，则 __每个子序列的所有元素的和__ 的最大值就是 $S_1$ 中所有元素的和的值，为$1+2+3+5+4=15$，就是$S$中所有元素的和（sum）。
{% endnotel %}

所以二分$[max,sum]$即可，但要注意 $x$ 要满足划分后子序列个数，过程如下：

1. 取中点`mid = l + (r - l) >> 1;`
2. 若最大值（$x$）取`mid`时要分成的份数<$n$，则说明`mid`大了，`r = mid - 1;`；若取`mid`时要分成的份数>$n$，则说明`mid`小了，`l = mid + 1;`
3. 若最大值取`mid`时要分成的份数=$n$，则说明`mid`就是$x$的最优解，结束即可，否则重复1和2.

代码：
```c++
int binary_search(int max, int sum) {
    int l = max, r = sum, mid;
    while(l < r) {
        mid = l + (r - l) >> 1;
        if(check(mid) == -1) {    //mid大了
            r = mid;
        } else if(check(mid) == 1) {    //mid小了
            l = mid + 1;
        }
    }
    return l;
}
```

`check(int x)`的思路：
每次都将$S_2$的第一个数加入到$S_1$中，若$S_1$的元素和小于等于传入的$x$，则说明$S_1$还需要分，否则$S_1$已经分好，后面的继续分。
```c++
int check(int x) {
    int cut = 1;
    int sum = a[1]; //类似于“窗口”的和
    for(int i = 2; i <= n; i++) {
        if(sum + a[i] <= x) {   //还要分
            sum += a[i];
        } else {    //不能分了
            cut++;
            sum = a[i]; //继续分
        }
    }
    return cut;
}
```

#### 完整代码
```c++
//T2.6.cpp
#include <iostream>
using namespace std;

int n, m, a[100001];

int check(int x) {
    int cut = 1;
    int sum = a[1]; //类似于“窗口”的和
    for(int i = 2; i <= n; i++) {
        if(sum + a[i] <= x) {   //还要分
            sum += a[i];
        } else {    //不能分了
            cut++;
            sum = a[i];
        }
    }
    return cut;
}

int binary_search(int max, int sum) {
    int l = max, r = sum, mid;
    while(l < r) {
        mid = l + ((r - l) >> 1);
        if(check(mid) <= m) {    //mid大了
            r = mid;        //确保循环结束后l正确
        } else {    //mid小了
            l = mid + 1;    //确保不卡死循环
        }
    }
    return l;
}

int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    int _max = -1145141, sum = 0;
    for(int i = 1; i <= n; i++) {
        _max = max(_max, a[i]);
        sum += a[i];
    }   //取得max和sum，以便二分
    int ans = binary_search(_max, sum);
    cout << ans << endl;
    return 0;
}
```

### T2.7 [通往奥格瑞玛的道路](https://www.luogu.com.cn/problem/P1462)

#### 题目背景

在艾泽拉斯大陆上有一位名叫歪嘴哦的神奇术士，他是部落的中坚力量。

有一天他醒来后发现自己居然到了联盟的主城暴风城。

在被众多联盟的士兵攻击后，他决定逃回自己的家乡奥格瑞玛。

#### 题目描述

在艾泽拉斯，有 $n$ 个城市。编号为 $1,2,3,\ldots,n$。

城市之间有 $m$ 条双向的公路，连接着两个城市，从某个城市到另一个城市，会遭到联盟的攻击，进而损失一定的血量。

每次经过一个城市，都会被收取一定的过路费（包括起点和终点）。路上并没有收费站。

假设 $1$ 为暴风城，$n$ 为奥格瑞玛，而他的血量最多为 $b$，出发时他的血量是满的。如果他的血量降低至负数，则他就无法到达奥格瑞玛。

歪嘴哦不希望花很多钱，他想知道，在所有可以到达奥格瑞玛的道路中，对于每条道路所经过的城市收费的最大值，最小值为多少。

#### 输入格式

第一行 $3$ 个正整数，$n,m,b$。分别表示有 $n$ 个城市，$m$ 条公路，歪嘴哦的血量为 $b$。

接下来有 $n$ 行，每行 $1$ 个正整数，$f_i$。表示经过城市 $i$，需要交费 $f_i$ 元。

再接下来有 $m$ 行，每行 $3$ 个正整数，$a_i,b_i,c_i$（$1\leq a_i,b_i\leq n$）。表示城市 $a_i$ 和城市 $b_i$ 之间有一条公路，如果从城市 $a_i$ 到城市 $b_i$，或者从城市 $b_i$ 到城市 $a_i$，会损失 $c_i$ 的血量。

#### 输出格式

仅一个整数，表示歪嘴哦交费最多的一次的最小值。

如果他无法到达奥格瑞玛，输出 `AFK`。

#### 样例 #1

##### 样例输入 #1

```
4 4 8
8
5
6
10
2 1 2
2 4 1
1 3 4
3 4 3
```

##### 样例输出 #1

```
10
```

#### 提示

对于 $60\%$ 的数据，满足 $n\leq 200$，$m\leq 10^4$，$b\leq 200$；

对于 $100\%$ 的数据，满足 $1\leq n\leq 10^4$，$1\leq m\leq 5\times 10^4$，$1\leq b\leq 10^9$；

对于 $100\%$ 的数据，满足 $1\leq c_i\leq 10^9$，$0\leq f_i\leq 10^9$，可能有两条边连接着相同的城市。

#### 思路+代码


### T2.8 [进击的奶牛](https://www.luogu.com.cn/problem/P1824)

#### 题目描述

Farmer John 建造了一个有 $N$（$2 \leq N \leq 10 ^ 5$) 个隔间的牛棚，这些隔间分布在一条直线上，坐标是 $x _ 1, x _ 2, \cdots, x _ N$（$0 \leq x _ i \leq 10 ^ 9$）。

他的 $C$（$2 \leq C \leq N$）头牛不满于隔间的位置分布，它们为牛棚里其他的牛的存在而愤怒。为了防止牛之间的互相打斗，Farmer John 想把这些牛安置在指定的隔间，所有牛中相邻两头的最近距离越大越好。那么，这个最大的最近距离是多少呢？

#### 输入格式

第 $1$ 行：两个用空格隔开的数字 $N$ 和 $C$。

第 $2 \sim N+1$ 行：每行一个整数，表示每个隔间的坐标。

#### 输出格式

输出只有一行，即相邻两头牛最大的最近距离。

#### 样例 #1

##### 样例输入 #1

```
5 3
1
2
8
4
9
```

##### 样例输出 #1

```
3
```

#### 思路+代码
{% note red fa-bolt %}
__思路点拨__ ：这道题其实就是 __最大值最小化__，二分对象就是 __距离的最大值__，区间就是 $[1, len]$（`len = x[n] - x[1]`）
{% endnote %}


1. 设置变量：`int l = 1, r = x[n] - x[1], mid, ans`。
2. 准备验证可行性的函数：（`int check(int mid)`，求在 __距离的最大值__ 是`mid`时可以放多少）
    - 设置变量：`int result = 1, nowIndex = 2`
    - 循环，从`2`到`n`遍历`x[]`数组（`for(int i = 2; i <= n; i++)`）
        - 判断`x[i] - x[nowIndex] //两头牛的距离`是否>=`mid`
            - 若>=，则表明距离足够，`result++, nowIndex = i;`
            - 若<，则表明距离不够，继续执行即可。
    - 返回`result`
3. 循环：`while(l < r)`。
    - 更新`mid`的值：`mid = l + (r - l) >> 1;`；
    - 将`mid`代入题目条件进行可行性验证：
        - 当 __距离的最大值__ 为`mid`时，所给出的坐标不够时：说明`mid`太大，显然答案在 $[l, mid]$；
        - 当 __距离的最大值__ 为`mid`时，所给出的坐标有冗余（刚好）时：说明`mid`（有一定可能）太小，先用`ans`记录`mid`，然后再假设答案在 $(mid, r]$，不是`mid`。
4. 输出答案`ans`。

代码：
```c++
#include <iostream>
#include <algorithm>
using namespace std;

int n, c, x[100001], ans;

int check(int mid) {
    int result = 1, nowIndex = 1;
    for(int i = 2; i <= n; i++) {
        if(x[i] - x[nowIndex] >= mid) { //保证每两头牛之间的距离不小于mid，即保证了mid是距离的最小值
            result++, nowIndex = i;
        }
    }
    return result;
}

int main() {
    cin >> n >> c;
    for(int i = 1; i <= n; i++) {
        cin >> x[i];
    }
    sort(x + 1, x + n + 1);
    int l = 1, r = x[n] - x[1], mid;
    while(l < r) {
        mid = l + ((r - l) >> 1);   //二分
        int checkVal = check(mid);
        if(checkVal >= c) { //有冗余（刚好）
            ans = mid;  //记录
            l = mid + 1;//假设mid还能再大
        } else {        //mid大了
            r = mid;   
        }
    }
    cout << ans << endl;
    return 0;
}
```

{% notel purple fa-pen 整数二分总结 %}

1. 二分的 __对象__ 一般是题目的 __设问对象__，如T2.6中的 __每个子序列的所有元素的和__，T2.8中的 __最大的最近距离__
2. 整数二分的应用中，若可行性判断是个数问题（如T2.6的子序列的个数，T2.8的可放置奶牛的数量），则一般`l = mid + 1`且`r = mid`，这样做可以避免死循环。
{% endnotel %}

# 实数二分

实数二分和整数二分差别不大，难点在于 __精度的控制__（用`eps`实现），但是，实数二分不需要确定`l = mid`还是`l = mid + 1`。

标准代码：
```c++
const double eps = 1e-7;    //精度为1 * 10 ^ (-7)
int l = 1, r = n;
while(r - l > eps) {
    double mid = l + (r - l) / 2;
    if(check(mid)) r = mid;
    else l = mid;
}
```

用for实现：
```c++
for(int i = 1; i <= 35; i++) { //因为每执行一次精确到2 ^ (-i)，100次就是2^ (-35)约等于 2 * 10 ^ (-11)，比eps更精确
    //...
}
```

## T2.9 Pie(http://poj.org/problem?id=3122)

### Description 描述

My birthday is coming up and traditionally I'm serving pie. Not just one pie, no, I have a number N of them, of various tastes and of various sizes. F of my friends are coming to my party and each of them gets a piece of pie. This should be one piece of one pie, not several small pieces since that looks messy. This piece can be one whole pie though.

我的生日快到了，传统上我是吃馅饼的。不只是一个馅饼，不，我有N个馅饼，口味各异，大小不一。我的F个朋友来参加我的聚会，他们每个人都得到了一块馅饼。这应该是一个馅饼中的一块，而不是几小块，因为看起来很乱。不过，这块可以是一个完整的馅饼。

My friends are very annoying and if one of them gets a bigger piece than the others, they start complaining. Therefore all of them should get equally sized (but not necessarily equally shaped) pieces, even if this leads to some pie getting spoiled (which is better than spoiling the party). Of course, I want a piece of pie for myself too, and that piece should also be of the same size.

我的朋友很烦人，如果其中一个人比其他人得到更大的一块，他们就会开始抱怨。因此，它们都应该得到大小相等（但不一定形状相同）的碎片，即使这会导致一些馅饼变质（这比破坏派对要好）。当然，我也想给自己一块馅饼，那块馅饼也应该是一样的大小。

What is the largest possible piece size all of us can get? All the pies are cylindrical in shape and they all have the same height 1, but the radii of the pies can be different.

我们所有人都可以获得的最大尺寸是多少？所有的馅饼都是圆柱形的，它们的高度都相同 1，但馅饼的半径可以不同。

### Input 输入

One line with a positive integer: the number of test cases. Then for each test case:

一行正整数：测试用例数。然后对于每个测试用例：

One line with two integers N and F with 1 ≤ N, F ≤ 10 000: the number of pies and the number of friends.

一行有两个整数 N 和 F，有 1 ≤ N，F ≤ 10 000：馅饼的数量和朋友的数量。

One line with N integers ri with 1 ≤ ri ≤ 10 000: the radii of the pies.

一条有 N 个整数 $r_i$，其中 1 ≤ $r_i$ ≤ 10 000是饼的半径。

### Output 输出

For each test case, output one line with the largest possible volume V such that me and my friends can all get a pie piece of size V. The answer should be given as a floating point number with an absolute error of at most 10−3.

对于每个测试用例，输出一行具有最大可能的体积 V，这样我和我的朋友都可以得到一块大小为 V 的馅饼。答案应以绝对误差最多为 10 的浮点数给出 −3 。

### Sample Input 示例输入

3
3 3
4 3 3
1 24
5
10 5
1 4 2 3 4 5 6 5 4 2

### Sample Output 示例输出

25.1327
3.1416
50.2655

### 思路
这道题简化了就是：

有$N$个馅饼，每个馅饼的半径是$r_i(1 \leq i \leq N)$，要将这些馅饼分给$F$个朋友，要求每份的大小($V$)相同且每份都是从一个馅饼上取下一个整块，求$V$的最大值。

典型的 __最小值最大化__ 模型。

1. 定义常量：`const double PI = acos(-1), eps = 1e-5; //cos(π)=-1,arccos(-1)=π`
2. 定义变量：`double l = 0, r = maxV, mid; //maxV是V[i]的最大值，二分区间为[0, maxR]`
3. 定义`int check(double v)`函数：
    - 定义变量：`int sum = 0;`
    - 循环，从`1`到`N`遍历`r[]`数组：
        - `sum`累加`V[i] / mid` //第i块馅饼能分成大小为`v`的小块数量
    - 返回`sum`
4. 开始二分：`while(r - l > eps)`
    - 更新`mid`的值
    - 判断`check(mid)`与`F`的关系
        - 若`check(mid)`不小于`F`，则说明分成大小为`mid`的小块数量足够，区间缩小至$[mid, r]$
        - 否则说明大小为`mid`的小块数量不足，区间缩小至$[l, mid]$
5. 输出结果（`l`就是结果）

### 代码
```c++
#include <iostream>
#include <cmath>
#include <iomanip>
using namespace std;

const double PI = acos(-1), eps = 1e-5;

int T, N, F;
double V[100001];

int check(double v) {   //分成一份v有check(v)份
    int sum = 0;
    for(int i = 1; i <= N; i++) {
        sum += (int)(V[i] / v);     
    }
    return sum;
}

int main() {
    cin >> T;
    while(T--){
        cin >> N >> F;
        F++;    //自己还有一份
        double maxV = -1;
        for(int i = 1; i <= N; i++) {
            cin >> V[i];
            V[i] = PI * V[i] * V[i];    //V[i]是第i块馅饼的体积
            maxV = max(V[i], maxV);
        }
        double l = 0, r = maxV, mid;
        while(r - l > eps) {    //二分核心
            mid = l + (r - l) / 2.0;
            if(check(mid) >= F) l = mid;
            else r = mid;
        }
        cout << endl << fixed << setprecision(4) << l << endl;
    }
    return 0;
}
```

# 附加：万能二分代码

```c++
int l = 1, r = n; //[1,n]开区间
while(l <= r) {
    int mid = (l + r) / 2;
    if(check(mid)) l = mid + 1;
    else r = mid - 1;
}
return l;
```

## 二分最小值代码

```c++
int l, r;   //[l,r)
while(l < r) {
    int mid = (l + r) / 2;
    if(check(mid)) r = mid;
    else l = mid + 1;
}
return l;
```

## 二分最大值代码

```c++
int l, r;    //[l,r)
while(l < r) {
    int mid = (l + r) / 2;
    if(check(mid)) l = mid;
    else r = mid - 1;
}
return l;
```

## 习题

### 寻找段落

洛谷 [P1419](https://www.luogu.com.cn/problem/P1419)

#### 题目描述

给定一个长度为 $n$ 的序列 $a$，定义 $a_i$ 为第 $i$ 个元素的价值。现在需要找出序列中最有价值的“段落”。段落的定义是长度在 $[S, T]$ 之间的连续序列。最有价值段落是指平均值最大的段落。

**段落的平均值** 等于 **段落总价值** 除以 **段落长度**。

#### 输入格式

第一行一个整数 $n$，表示序列长度。

第二行两个整数 $S$ 和 $T$，表示段落长度的范围，在 $[S, T]$ 之间。

第三行到第 $n+2$ 行，每行一个整数表示每个元素的价值指数。

#### 输出格式

一个实数，保留 $3$ 位小数，表示最优段落的平均值。

#### 样例 #1

##### 样例输入 #1

```
3
2 2
3
-1
2
```

##### 样例输出 #1

```
1.000
```

#### 提示

【数据范围】

对于 $30\%$ 的数据有 $n \le 1000$。

对于 $100\%$ 的数据有 $1 \le n \le 100000$，$1 \le S \le T \le n$，$-{10}^4 \le a_i \le {10}^4$。

【题目来源】

tinylic 改编

#### 题解

本题要求的是 __区间最大平均值__，那我们不妨通过二分的方式直接寻找最大值，再通过可行性验证。

```c++
double Solve() { 
    double l = -1e4, r = 1e4, mid;
    const double eps = 1e-6;
    while(r - l > eps) {
        mid = (l + r) / 2;
        //如果存在某个区间的平均值大于等于mid，则说明mid可行，最优答案在mid的右侧
        if(check(mid)) l = mid;
        //否则说明mid太大，最优答案在mid左侧
        else r = mid;
    }
    //由于l最后一次记录了可行答案，所以l为最优答案
    return l;
}
```

接下来考虑 `check()` 函数的编写，即：如何验证是否有区间的平均值大于等于 $mid$？

因为求平均值涉及到求区间和，所以我们先对原数组做前缀和。此时，对于一个区间 $[l,r]$，其均值为 $\frac{s_r-s_{l-1}}{r-l+1}$。

一个区间的均值比 $mid$ 大，当且仅当 $\frac{s_r-s_{l-1}}{r-l+1} - mid \ge 0$。也就是说：

$$
s_r-s_{l-1} - (r-l+1)mid \ge 0
$$

将 $s$ 展开，有：

$$
\overbrace{a_l + a_{l+1} + \dots + a_{r}}^{r-l+1 项} - (r-l+1)mid \ge 0
$$

整理得：

$$
(a_l - mid) + (a_{l+1} - mid) + \dots + (a_{r}-mid) \ge 0
$$

那我们可以开始就将每个 $s_i$ 减去 $mid$，这时只需要在处理好的 $s$ 中做单调队列，找到 **任意** 区间长度在 $[S,T]$、区间和大于等于 $0$ 的区间，就说明 $mid$ 是可行的。

```c++
double s[N];
bool check(double mid) {
    memset(s, 0, sizeof s);
    //预处理 s 数组
    for(int i = 1; i <= n; i++)
        s[i] = s[i - 1] + a[i] - mid;
    //单调队列求最大区间和模板
    deque<int> q;
    for(int i = S; i <= n; i++) {
        int maxLeft = i - S;
       	while(q.size() && s[q.back()] > s[maxLeft]) q.pop_back();
		q.push_back(maxLeft);
		while(q.size() && q.front() < i - T) q.pop_front();
        if(s[i] - s[q.front()] >= 0) return true;
	}
    return false;
}
```

完整代码：

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 1, AI = 1e4 + 1;
int a[N], S, T, n;

double s[N];
bool check(double mid) {
    memset(s, 0, sizeof s);
    //预处理 s 数组
    for(int i = 1; i <= n; i++)
        s[i] = s[i - 1] + a[i] - mid;
    //单调队列求最大区间和模板
    deque<int> q;
    for(int i = S; i <= n; i++) {
        int maxLeft = i - S;
       	while(q.size() && s[q.back()] > s[maxLeft]) q.pop_back();
		q.push_back(maxLeft);
		while(q.size() && q.front() < i - T) q.pop_front();
        if(s[i] - s[q.front()] >= 0) return true;
	}
    return false;
}
 
double Solve() { 
    double l = -10001, r = 10001, mid;
    const double eps = 1e-6;
    while(r - l > eps) {
        mid = (l + r) / 2;
        //如果存在某个区间的平均值大于等于mid，则说明mid可行，最优答案在mid的右侧
        if(check(mid)) l = mid;
        //否则说明mid太大，最优答案在mid左侧
        else r = mid;
    }
    //由于l最后一次记录了可行答案，所以l为最优答案
    return l;
}

int main() {
    cin >> n;
    cin >> S >> T;
    for(int i = 1; i <= n; i++) cin >> a[i];

    printf("%.3lf", Solve());
    return 0;
}
```