---
title: 二分法
date: 2024-07-04 21:31:13
tags:
---

二分法就是不断地将一个序列一分为二，判断答案所在的区间（左或有），将答案所在的区间作为新的序列继续一分为二，直到达到（接近）答案为止。时间复杂度为 $O(nlog_2n)$

# 整数二分

{% notel yellow fa-info 注意 %}
在 __整数二分__ 中，难点在于中间值`mid`的处理，如：
1. `l`是取`mid - 1`还是`mid`？（在 __整数二分__ 中，一般采用`mid - 1`，否则容易陷入死循环）
2. `r`是取`mid`还是`mid + 1`？（在 __整数二分__ 中，一般采用`mid + 1`，否则容易陷入死循环）
3. `mid`是取左中位数（`mid = left + (right - left) >> 1`//更接近`left`）还是右中位数（`mid = left + (right - left + 1) >> 1`//更接近`right`）？

这些都需要结合具体的问题来分析（~~其实模拟一下才知道~~）
{% endnotel %}

## 框架
```c++
int l = 1, r = n, mid;
while(l < r) {
    mid = l + (l - r) >> 1;
    if(/*答案在左区间*/) {
        r = mid /*-1*/;
    } else {
        l = mid /*+1*/;
    }
}
```

## 在单调递增序列中查找x或大于x且最接近x的数
{% notel blue fa-file-lines 描述 %}

| 情况 | `方案` |
|:-:|:-:|
|有x| `返回x`|
|多个x|`返回第一个和x相等的数`|
|无x|`返回大于x且最接近x的数`|


{% endnotel %}

### 思路
1. 二分法，定义`left, right, middle`三个变量:`int left = 1, right = n, middle;`
2. 当`left < right`时不断循环，先计算`middle = left + (right - left) >> 1; //取左中位数是因为要找后继`。当`x`比`a[middle]`小时，说明答案在左区间，`right = middle - 1;`；当`x`比`a[middle]`大时，说明答案在右区间，`left = middle + 1`。
3. 最终，`left`（`right`也一样）就是`x`所在的位置。

### 代码
```c++
int binary_search(int *a, int n, int x) {
    int left = 1, right = n, middle;
    while(left < right) {
        middle = left + (right - left) >> 1;    //取平均值
        if(a[middle] >= x) { //在左区间
            right = middle - 1;
        } else {
            left = middle + 1;
        }
    }
    return left;
}
```

## 在单调递增序列中查找x或小于x且最接近x的数
{% notel blue fa-file-lines 描述 %}

| 情况 | `方案` |
|:-:|:-:|
|有x| `返回x`|
|多个x|`返回第一个和x相等的数`|
|无x|`返回小于x且最接近x的数`|


{% endnotel %}

### 思路
1. 二分法，定义`left, right, middle`三个变量:`int left = 1, right = n, middle;`
2. 当`left < right`时不断循环，先计算`middle = left + (right - left + 1) >> 1; //取右中位数是因为要找前驱`。当`x`比`a[middle]`小时，说明答案在左区间，`right = middle - 1;`；当`x`比`a[middle]`大时，说明答案在右区间，`left = middle + 1`。
3. 最终，`left`（`right`也一样）就是`x`所在的位置。

### 代码
```c++
int binary_search1(int *a, int n, int x) {
    int left = 1, right = n, middle;
    while(left < right) {
        middle = left + (right - left + 1) >> 1;    //取平均值
        if(a[middle] >= x) { //在左区间
            right = middle - 1;
        } else {
            left = middle;  //右中位数不能+1
        }
    }
    return left;
}
```

## 整数二分的STL模板函数
`lower_bound(int *b, int *e, int x)`和`upper_bound(int *b, int *e, int x)`两个STL函数的功能：

| 项目 | 功能 |
|-|-|
| `lower_bound(int *b, int *e, int x)` | 在地址`b`到`e`中查找`x`或`x`的后继 |
| `upper_bound(int *b, int *e, int x)` | 在地址`b`到`e`中查找`x`或`x`的前驱 |

***
{% note yellow fa-warning %}
注意：`lower_bound`和`upper_bound`返回的是地址，获得相对位置要减去`a`！
{% endnote %}
{% note red fa-bolt %}
可以使用`lower_bound(a, a + n, x) - upper_bound(a, a + n, x)`来获得`a[]`中`x`的个数。
{% endnote %}

## 整数二分的建模

### T2.5 [两数之和](https://leetcode.cn/problems/two-sum/description/)

#### 题目描述
> 给定一个长度为$n$得数组$a$和一个正整数$m$（保证$m$为$a$数组中两个数的和），求$a$中的哪两个数的和是$m$（一个即可）。

#### 样例
输入：
```
9
21 4 5 6 13 65 32 9 23
28
```
输出：
```
5 23
```

#### 思路+代码
{% notel red fa-bolt 思路 %}
1. 对数组进行排序[复杂度 $O(nlog_2n)$ ]
2. 遍历数组，对于`a[i]`，通过二分法寻找`m - a[i]`[复杂度 $O(nlog_2n)$]
{% endnotel %}
```c++
//T2.5.cpp
#include <iostream>
#include <algorithm>
using namespace std;

int main() {
    int n, a[10001], m;
    cin >> n;
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    cin >> m;
    sort(a + 1, a + n + 1); //排序
    for(int i = 1; i <= n; i++) {
        int x = a[lower_bound(a + i + 1, a + n + 1, m - a[i]) - a]; //核心，找m-a[i]或其前驱
        if(x == m - a[i]) { //符合条件
            cout << a[i] << " " << x;   //输出
            return 0;
        }
    }
    return 0;
}
```

## 整数二分的经典模型
整数二分有两种经典模型： __最大值最小化__ 和 __最小值最大化__

### T2.6 序列划分
{% notel blue fa-file-lines 描述 %}
有一个序列，要将其划分为$m$个子序列（每个子序列都 __不为空__ ），记作 $S_1, S_2, S_3, \cdots, S_n$，请求出一个方案，使 $S_1, S_2, S_3, \cdots, S_n$ 的 __每个子序列的所有元素的和__ 的最大值最小。
{% endnotel %}

#### 思路
设一个$x$，使$x$对于任意$S_i$有$S_i \leq x$，即$x$是所有$S_i$中的 __元素和的最大值__ ，题目也就变成了使$x$最小。

因为一个序列的 __元素和的最大值__ 在$[max, sum]$中。
{% notel orange fa-pen 解释 %}
假设有序列$S={1,2,3,5,4}$
1. 若分为$S_1={1},S_2={2},S_3={3},S_4={5},S_5={4}$，则 __每个子序列的所有元素的和__ 的最大值就是 $S_4$ 中所有元素的和的值，为$5$，就是$S$中的最大值（max）。
2. 若分为$S_1={1,2,3,5,4}$，则 __每个子序列的所有元素的和__ 的最大值就是 $S_1$ 中所有元素的和的值，为$1+2+3+5+4=15$，就是$S$中所有元素的和（sum）。
{% endnotel %}

所以二分$[max,sum]$即可，但要注意 $x$ 要满足划分后子序列个数，过程如下：
1. 取中点`mid = l + (r - l) >> 1;`
2. 若最大值（$x$）取`mid`时要分成的份数<$n$，则说明`mid`大了，`r = mid - 1;`；若取`mid`时要分成的份数>$n$，则说明`mid`小了，`l = mid + 1;`
3. 若最大值取`mid`时要分成的份数=$n$，则说明`mid`就是$x$的最优解，结束即可，否则重复1和2.

代码：
```c++
int binary_search(int max, int sum) {
    int l = max, r = sum, mid;
    while(l < r) {
        mid = l + (r - l) >> 1;
        if(check(mid) == -1) {    //mid大了
            r = mid;
        } else if(check(mid) == 1) {    //mid小了
            l = mid + 1;
        }
    }
    return l;
}
```

`check(int x)`的思路：
每次都将$S_2$的第一个数加入到$S_1$中，若$S_1$的元素和小于等于传入的$x$，则说明$S_1$还需要分，否则$S_1$已经分好，后面的继续分。
```c++
int check(int x) {
    int cut = 1;
    int sum = a[1]; //类似于“窗口”的和
    for(int i = 2; i <= n; i++) {
        if(sum + a[i] <= x) {   //还要分
            sum += a[i];
        } else {    //不能分了
            cut++;
            sum = a[i]; //继续分
        }
    }
    return cut;
}
```

#### 完整代码
```c++
//T2.6.cpp
#include <iostream>
using namespace std;

int n, m, a[100001];

int check(int x) {
    int cut = 1;
    int sum = a[1]; //类似于“窗口”的和
    for(int i = 2; i <= n; i++) {
        if(sum + a[i] <= x) {   //还要分
            sum += a[i];
        } else {    //不能分了
            cut++;
            sum = a[i];
        }
    }
    return cut;
}

int binary_search(int max, int sum) {
    int l = max, r = sum, mid;
    while(l < r) {
        mid = l + ((r - l) >> 1);
        if(check(mid) <= m) {    //mid大了
            r = mid;        //确保循环结束后l正确
        } else {    //mid小了
            l = mid + 1;    //确保不卡死循环
        }
    }
    return l;
}

int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
    }
    int _max = -1145141, sum = 0;
    for(int i = 1; i <= n; i++) {
        _max = max(_max, a[i]);
        sum += a[i];
    }   //取得max和sum，以便二分
    int ans = binary_search(_max, sum);
    cout << ans << endl;
    return 0;
}
```