---
title: 提高组第十三天（最短路径算法）
date: 2024-08-27 23:25:33
tags: 
    - C++
    - CSP提高组
categories:
    - [CSP,CSP-S,课程]
    - [算法,图,最短路径]
---

# 壹、 $Floyed$ 算法

不能处理负环。

## 核心思路
分别以每个节点作为 __中间节点__，更新每个节点之间的距离。

{% note green fa-star %}
优点：编码方便；跑一次，整个图。
{% endnote %}

{% note red fa-ban %}
缺点：时间复杂度$\mathbf{O}(n^3)$，进行大量无用运算。
{% endnote %}

## 核心代码
```c++
//n个节点
for(int mid = 1; mid <= n; mid++) {         //分别以每个节点作为中间节点
    for(int from = 1; from <= n; from++) {
        for(int to = 1; to <= n; to++) {
            if(G[from][mid] + G[mid][to] < G[from][to]) {   //如果经过当前中间节点比上一次的方案更优
                G[from][to] = G[from][mid] + G[mid][to];
            }
        }
    }
}
```

# 贰、$Dijkstra$ 算法

不能处理负环。

## 核心思路
用`dis[]`数组记录从`s`出发到各点的距离，`vis[]`数组记录每个节点的访问情况。其中，`dis[s]`等于零。

1. 遍历起始节点$s$的邻边$E(s,j)$，更新`dis[j]`与`vis[s]`。
2. 在`dis[]`中找最小值，将它的对应点作为中间点$from$，更新`vis[from]`，遍历其邻边$\mathbf{e}(from,l)$，更新`dis[l]`为`dis[from]`与其连边长度之和。
3. 重复2，直到`vis[]`数组中的所有值为`true`。

## 核心代码
```c++
memset(dis, 0x3f, sizeof dis);
dis[s] = 0;
for(int i = 1; i <= n; i++) {
    //找dis中的最小值
    int minn = 0x3f3f3f3f, from = 0;
    for(int j = 1; j <= n; j++) {
        if(!vis[j] && dis[j] < minn) {
            minn = dis[j];
            from = j;
        }
    }
    vis[from] = true;   //标记from已访问
    for(int j = 1; j <= n; j++) {   //遍历邻接点
        if(!vis[j] && g[from][j] + dis[from] < dis[j]) {    //2
            dis[j] = g[from][j] + dis[from];
        }
    }
}
```

## 堆优化的 $Dijsktra$

```c++
//优先队列 + Dijsktra
int dis[1001] = {};
bool vis[1001] = {};
void Dijsktra(int s) {
    //初始化
    memset(dis, 0x3f, sizeof dis);
    memset(vis, false, sizeof vis);
    
    //s入队
    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>> > q; //优先队列免去了在dis中找最小值的操作
    dis[s] = 0;
    q.push({0, s});
    
    //bfs
    while(q.size()) {
        pair<int, int> h = q.top(); q.pop(); //取出队首
        int u = h.second;   //获取节点
        if(!vis[u]) {
            vis[u] = true;
            int v, w;  //邻接点和权值
            //遍历邻接点
            for(int i = head[u]; i; i = edge[i].nxt) {
                v = edge[i].v;  //邻接点
                w = edge[i].w;  //权值
                if(!vis[v] && dis[v] > dis[u] + w) {    //松弛
                    dis[v] = dis[u] + w;
                    q.push({dis[v], v});
                }
            }
        }
    }
}
```