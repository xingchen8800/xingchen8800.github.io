---
title: 训练士兵
date: 2025-02-18 21:27:50
tags: 
    - C++
---

## 题目描述

小科是科丁王国首都科丁城的守备司令，统领着 $N$（ $1 \leq N \leq 1000$ ）名士兵，还有两名副官助手。小科经常会从中挑选出两队士兵进行比武PK，从而达到训练士兵的目的。今天小科让他的 $N$ 名士兵从西往东站成一排，并将他们按照从西往东的顺序，编号为 $1, \dots, N$。每一名士兵都有一个武力值，其中第 $i$ 名士兵的武力值为 $f_i$（ $1 \leq f_i \leq 1000000$）。

小科让他的两名副官，每人挑出一队士兵，进行比武PK。小科要求每个副官选出的士兵编号必须连续，并且一名士兵不能同时属于两个队伍。为了公平起见，小科还要求两队士兵的武力值之和必须相等。请你帮助副官们算一算，有多少种不同的组合满足小科的要求。（两支满足条件的队伍组成一个组合，两个组合中只要有一名士兵不同，就认为是不同的组合。）

## 输入格式

第 $1$ 行：一个整数 $N$ ，表示士兵的数量。

第 $2$ 行：$N$ 个空格的分隔的整数，其中第 $i$ 个整数 $f_i$ 表示编号为 $i$ 的士兵的武力值。

## 输出格式

$1$ 行：满足条件的分组数量。

## 输入输出样例

### 输入样例1

```plaintext
4
3 2 2 3
```

### 输出样例1

```plaintext
3
```

## 题解

不难看出，样例有三种选法。

$$
\begin{align}
\{3\},\{3\} \\
\{2\},\{2\} \\
\{3,2\},\{2,3\}
\end{align}
$$

题目里有一句话非常关键：“小科要求每个副官选出的士兵编号必须连续，并且一名士兵不能同时属于两个队伍。”这就说明了应该在 $f$ 中选择两个 __连续__ 区间，区间 __不相交__。又由于涉及到区间求和，所以可以用前缀和优化。

显然，我们需要先选择两个区间，然后再判断 $f$ 和是否相等（这点与 [异或和为0](/2025/省赛冲刺/10/异或和为0) 相同）。因为区间不相交，自然想到 __枚举分界线__。对于每个分界线 $i$，在右边选一点 $r$，相对右区间就是 $[i,r]$；在左边选一点 $l$，相对左区间就是 $[l,i)$。如果分层枚举 $i,l,r$，那么时间复杂度是 $O(n^3)$，显然超时，故考虑同层枚举 $l,r$：在枚举 $l$ 时记录相对左区间的 $f$ 和，在枚举 $r$ 时累加区间 $f$ 和为相对有区间的区间 $f$ 和的区间数，这样时间复杂度为 $O(n^2)$，不会超时。

$$
\{ \color{green}{ \underset{\underset{\rightarrow}{l}}{3},2} , \color{red}{ \underset{i}{2},\underset{\underset{\rightarrow}{r}}{3}} \}
$$

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll N = 1001;
ll f[N], n, p[N];
map<ll,ll> cnt;

int main() {
    cin >> n;
    p[0] = 0;
    for(ll i = 1; i <= n; i++) {
        cin >> f[i];
        p[i] = p[i-1] + f[i];
    }
    ll ans = 0;
    for(ll i = 1; i <= n; i++) {
        for(ll l = 1; l < i; l++) {
            cnt[p[i-1] - p[l-1]]++;
        }
        for(ll r = i; r <= n; r++) {
            ans += cnt[p[r] - p[i-1]];
        }
    }
    cout << ans << endl;
    return 0;   
}
```
