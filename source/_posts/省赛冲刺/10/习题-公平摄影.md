---
title: 公平摄影（FairPhotography）
date: 2025-02-20 20:31:50
tags:
    - C++
    - 前缀和
---

## 题目描述

FJ的 $N$ 头奶牛($1 \leq N \leq 10^5$)住在一排长栅栏的不同位置处，其中第 $i$ 头奶牛的位置是 $x_i(1 \leq x_i \leq 10^9)$，第i头奶牛的品种为 $b_i$ ，要么是荷斯坦牛`H`，要么是根西牛`G`，并且没有两头奶牛在同一个位置。

FJ想拍一张连续奶牛的照片，他希望照片中每个品种的奶牛数量相等，例如一张照片中包含全部的 $27$ 头荷斯坦牛是可以的，包含 $27$ 头荷斯坦牛和 $27$ 头根西牛也是可以的，但是如果包含 $10$ 个荷斯坦牛以及 $8$ 个根西牛，就不可以了。请你计算出FJ能够拍摄照片的最大尺寸，一张照片的尺寸是照片中所有奶牛的最大位置与最小位置的差值。FJ可能最后只拍了一头奶牛，那么此时照片尺寸为 $0$.

## 输入格式

第一行一个整数 $N$ ，接下来的 $N$ 行每行两个值 $x_i$ 和 $b_i$，分别表示第 $i$ 头奶牛的位置和种类

## 输出格式

输出照片的最大尺寸

## 输入输出样例

### 输入样例1

```plaintext
6 
4 G 
10 H 
7 G 
16 G 
1 G 
3 H 
```

### 输出样例1

```plaintext
7
```

## 题解

本题最大时间复杂度： $O(n \ logn)$

这题训练的是[男生女生配](/2025/省赛冲刺/10/男生女生配)的前缀和思想：

> 更进一步，我们可以将`B`看作 $+1$，将`G`看作 $-1$，这样如果一段区间的区间和为 $0$，就说明男生女生数量相同

在本题，我们可以把`G`看作 $+1$，`H`看作 $-1$，只需要找到区间和为 $0$ 的区间或连续的只含`G`或`H`的区间，取区间长最大值即可。

$$
\{G,H,G,G,H,G\} \rightarrow \{1,-1,1,1,-1,1\}
$$

找区间和为 $0$ 的区间，即找 $l,r$ 满足 $s_r-s_{l-1}=0$，即 $s_r=s_{l-1}$。所以我们可以用`map`来维护每个 $s_r$ 对应的 __最前面与之相等的 $s_{l-1}$ 与 $x_l$__ ，这样就可以每次以 $O(logn)$ 的时间复杂度找出每个 $r$ 对应的最优 $l$。

$$
\{\underset{l-1}{ \color{green}{1}},\underset{l}{0},1,2,\underset{r}{ \color{green}{1}},2\}
$$

```c++
cows[i].b += cows[i - 1].b;         //前缀和，cows[i].b即为s[r]
if(pos.count(cows[i].b))            //当可以找到某个s[l-1]=s[r]
    ans = max(ans, cows[i].x - pos[cows[i].b]);
else pos[cows[i].b] = cows[i + 1].x;    //首次出现，记录s[l-1(即i)]与l(即i+1)
```

同时，对于处理连续的只含`G`或`H`的区间，我们可以通过逐两位比较的方法，找出连续区间的起点和终点并计算长度即可。

```c++
//连续区间终点，记录
if(cows[i].b1 != cows[i-1].b1) lst = cows[i].x;
ans = max(ans, cows[i].x - lst);    //计算区间长度
```

完整代码：

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll N = 1e5 + 10;
struct Cow{
    ll x;
    ll b;
    char b1;
    bool operator<(const Cow& rhs) const {
        return this->x < rhs.x;
    }
} cows[N];
ll n;
map<ll, ll> pos;    //sum[r]->sum[l-1],x[l]
ll s[N];

int main() {
    cin >> n;
    for(ll i = 1; i <= n; i++){
        char ch;
        cin >> cows[i].x >> cows[i].b1;
        if(cows[i].b1 == 'G') cows[i].b = 1;
        else cows[i].b = -1;
    }
    sort(cows + 1, cows + n + 1);
    pos[0] = cows[1].x;
    ll ans = 0, lst = cows[1].x;
    for(int i = 1; i <= n; i++) {
        //连续区间终点，记录
        if(cows[i].b1 != cows[i-1].b1) lst = cows[i].x;
        ans = max(ans, cows[i].x - lst);    //计算区间长度
        
        cows[i].b += cows[i - 1].b;         //前缀和，cows[i].b即为s[r]
        if(pos.count(cows[i].b))            //当可以找到某个s[l-1]=s[r]
            ans = max(ans, cows[i].x - pos[cows[i].b]);
        else pos[cows[i].b] = cows[i + 1].x;    //首次出现，记录s[l-1(即i)]与l(即i+1)
    }
    cout << ans << endl;
    return 0;
}
```
