---
title: 幸运手链2.0
date: 2025-02-15 22:01:11
tags:
    - C++
    - STL
    - set
    - 前缀和
---

### 题目描述

小科准备为自己做一条幸运手链。小科有 $N$（$1 \leq N \leq 500000$）颗宝石。小科把它们摆成了一个圈，然后小科随意挑选了一颗宝石编号为 $1$ ，然后按照顺时针方向依次为其他的 $N-1$ 颗宝石编号为 $2,\dots,N$。每颗宝石都有一个价值，编号为 $i$ 的宝石的价值为 $v_i$（$1 \leq v_i \leq 10^6$）。小科喜欢数字 $8$，所以他希望选出的宝石的价值之和是 $8$ 的倍数。他只会挑选编号连续的宝石（由于是圆形，所以编号 $N$ 的宝石和编号1的宝石也是连续的）。并且他希望最终项链上的宝石越多越好。请帮助小科计算他可以制作的幸运手链中宝石的最大数量。如果无法制作幸运手链，输出`0`。

### 输入格式

第1行：一个整数 $N$

第2到 $N$ 行，每行一个整数，其中第 $i+1$ 行的整数 $v_i$，表示编号为 $i$ 的宝石的价值。

### 输出格式

一行：一个整数，表示小科制作的幸运手链可以包含的最大宝石的最大数量。如果无法制作幸运手链，输出`0`。

### 输入输出样例

#### 输入样例1

```
5
8 8 8 8 8
```

#### 输出样例1

```
5
```

#### 输入样例2

```
5
4 8 3 8 4
```

#### 输出样例2

```
4
```

#### 输入样例3

```
5
9 9 9 9 9
```

#### 输出样例3

```
0
```

## 题解

这题跟幸运手链1.0有两处不同：

1. 必须在环上连续
2. 要求是 $8$ 的倍数

由于是环，我们根据经验，自然想到拆环为链，将环复制一份，首尾相接。这样，我们就可以把环上问题变为区间问题：

$$
9,9,9,9,9,9,9,9,9,9
$$

但是，因为环被复制了一份，如果继续沿用1.0的代码的话，当 $i > n$ 时，有可能出现链长大于 $n$ 的情况（如下）。

$$
\{\overbrace{\underset{f_1}{9},9,9,9,9}^{n个},9,9,\underset{i}{9}\},9,9
$$

此时，我们不能单纯维护静态`f[]`，而是动态地更新`f[]`来防止链长 $>n$（即当链长 $>n$ 时踢出原来的下标，用在区间内的最远的下标）：

$$
9,9,9,\{\overbrace{\underset{f_1}{9},9,9,9,\underset{i}{9}}^{n个}\},9,9
$$

我们可以使用set来维护所有`f[i]`，需要时从中挑选符合条件的最优解即可（当 $i$ 移动到 $8$ 时，$f_1$ 集合中元素如下图）。

$$
f_1 \in \{ \  \color{red}{1,2,3},\color{green}{\underset{i-n}{4}},5,6,7 \ \}
$$

```c++
#include <bits/stdc++.h>
using namespace std;

#define ll long long

ll n, v[500010 * 2];
set<ll> f[8];

int main() {
    cin >> n;
    for(ll i = 1; i <= n; i++) {
        cin >> v[i];
        v[n + i] = v[i];
    };
    
    ll sum = 0, ans = 0;
    f[0].insert(0);
    for(ll i = 1; i <= 2 * n; i++) {
        sum += v[i];
        ll r = sum % 8;
        set<ll>::iterator it = f[r].lower_bound(max(0LL, i - n));   //获取第一个下标不小于max(0,i-n)
        if(it != f[r].end()) ans = max(ans, i - (*it));
        f[r].insert(i);
    }
    cout << ans << endl;
}
```