---
title: 异或和为0
date: 2025-02-15 20:28:09
tags:
    - C++
    - 推理
    - 前缀和
    - 位运算
    - 枚举
---

## 题目描述

给定 $N$（ $1 \leq N \leq 2000$）个非负整数，小 $A$ 想要从中挑出两个互不相交的闭区间，使得两个闭区间中的所有整数异或到一起后的值为 $0$。小科想知道，有多少个不同的区间对满足他的要求。

## 输入格式

第 $1$ 行：$1$ 个整数 $N$，表示非负整数的数量。

第 $2$ 行：$N$ 个大于等于 $0$，小于等于 $1000000$ 的整数。

## 输出格式

一行：一个整数，表示答案。

## 输入输出样例

**输入样例 1：**

```
3
1 1 1
```

**输出样例 1：**

```
3
```

**样例说明**

满足条件的区间有：{[1,1], [2,2]}，{[1,1], [3,3]}，{[2,2], [3,3]}。

## 题解

异或和为 $0$，说明两个数相等。现在就相当于找两个不相交区间，使它们异或和的结果相等。

按照传统方法，分别枚举 $l_1, r_1, l_2, r_2$，时间复杂度为 $O(n^4)$~~，给10s都不够跑的~~。

我们可以枚举一个分界线，将分界线作为右侧区间的左端点，然后向右拓展，构成多个子区间。

$$
a_1,a_2,a_3,\underset{l}{|} \ \underset{\underset{r}{\rightarrow}}{a_4} \ ,a_5,a_6
$$

对于每个子区间，我们求出它的异或和，然后在分界线左侧寻找与其异或和相等的区间，每个对答案的贡献为 $1$。

对于上一步操作，我们可以用预处理的思想将其时间复杂度优化到 $O(1)$。我们可以预处理左侧区域每个子区间的异或和，并将其存储在一个`cnt[]`中，`cnt[i]`代表区间异或和为 $i$ 的子区间在左侧区域出现的次数。

预处理可以在分界线移动的同时进行，每移动一次分界线，就把分界线左侧第一个元素当作左侧区间的右端点，枚举左侧区间的左端点并更新`cnt[]`。这样，当分界线在 $a_2$ 处时，会处理 $[1,1]$ 区间；当分界线在 $a_3$ 处时，会处理 $[1 \sim 2, 2]$ 区间；当分界线在 $a_3$ 处时，会处理 $[1 \sim 3, 3]$ 区间……

$$
\underset{\underset{l_1}{\rightarrow}}{a_1} \ ,a_2,a_3, \ \underset{r_1}{|} \ ,a_4 ,a_5,a_6
$$

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll N = 2025, M = 1e6 + 10;
ll a[N], n, p[N], cnt[M];

int main() {
    cin >> n;
    p[0] = 0;
    for(ll i = 1; i <= n; i++) {
        cin >> a[i];
        p[i] = p[i - 1] ^ a[i];
    }
    ll ans = 0;
    for(ll i = 1; i <= n; i++) {
        for(ll l = 1; l < i; l++) {
            cnt[p[i-1] ^ p[l - 1]]++;
        }
        for(ll r = i; r <= n; r++) {
            ans += cnt[p[r] ^ p[i - 1]];
        }
    }
    cout << ans << endl;
    return 0;
}
```
