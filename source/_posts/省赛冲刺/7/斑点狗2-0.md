---
title: 斑点狗2.0
date: 2025-01-21 20:02:19
tags:
    - C++
    - 搜索
    - 路径
    - BFS
---

## 题目描述

时尚真是变化迅速，现在又开始流行三个斑点的斑点狗了，时尚达人小科，当然要紧跟时尚潮流，经过一凡修剪，小科将自己的斑点狗改造出了 $3$ 个斑点，又一次的站在了时尚之巅，然而好景不长，没过多少时间，一个斑点的斑点狗又重新开始流行了，小科又要对他的斑点狗进行改造了，小科可以通过画笔将几个斑点连在一起，形成一个大斑点。小科的斑点狗的皮肤由 $n \times m$ 个小格子组成，$(1 \leq n,m \leq 50)$ 用 $n \times m$ 个字符来表示皮肤上的斑点信息。如下图所示:

![图1](/images/省赛冲刺/7/1.png)

这里，每一个`X`表示一个斑点的一部分。垂直或水平相邻（对角线相邻不在内）的两个`X`属于同一个斑点，所以上图正好有 $3$ 个斑点。

小科的零花钱有限，所以希望使用尽可能少的颜料合并三个斑点为一个。在上面的例子中，他只要画4个附加的字符就可以做到这一点。附加字符`X`（新的字符如下图中的`*`那样表示，很容易看到）。

![图2](/images/省赛冲刺/7/2.png)

请帮助小科确定要让 $3$ 个斑点合并为一个，最少需要画多少个点。

## 输入格式

输入的第一行，用空格隔开的两个整数 $N$ 和 $M$

接下来 $N$ 行，每行 $M$ 个字符，字符是`X`或者`.`，表示斑点狗的皮肤的图形。

## 输出格式

输出一行，一个整数，表示把两个斑点合并成一个斑点，需要添加的`X`的最小数量

## 输入输出样例

### 输入样例1

```plaintext
6 16
................
..XXXX....XXX...
...XXXX....XX...
.XXXX......XXX..
........XXXXX...
..XXX....XXX....
```

### 输出样例1

```plaintext
4
```

## 题解

![图3](/images/省赛冲刺/7/3.png)

我们可以先对图进行染色，将每个斑点都染成不同的颜色，如 __图3__ 所示。

接下来，我们考虑如何计算 $3$ 个连通分量间的路径最短距离：

1. 我们可以让 $3$ 个连通分量两两分别连接，看看怎样连接需要涂色的格子最少（即 $1 \to 2, 1 \to 3$ 或 $2 \to 1, 2 \to 3$ 或 $3 \to 1, 3 \to 2$），此为第一种情况。

2. 但是，这样连接可能导致涂色的格子有重叠。所以，我们可以再分别枚举每个点作为假想的交点，然后将这个点与 $3$ 个连通分量分别连接，求最小值。此为第二种情况。

综合两种情况，我们取它们的最小值。

由此，我们就解决了计算最短路的逻辑问题，但是我们还不知道连通分量间的距离和连通分量与图中点的距离。

我们可以通过 $BFS$ 扩散的方式来计算这些距离：

![图4](/images/省赛冲刺/7/4.png)

如 __图4__ 所示，蓝色块为扩散后一步可达的点，绿色块为扩散后第二步可达的点，以此类推。

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll N = 51, M = 51;
char G[N][M];
ll n, m, color = 1;
const ll dx[] = {0, 0, 1, -1}, dy[] = {1, -1, 0, 0};

//DFS染色
void dfs(ll x, ll y, ll color) {
    G[x][y] = color;
    for(ll i = 0; i < 4; i++) {
        ll xx = x + dx[i], yy = y + dy[i];
        if(xx >= 1 && xx <= n && yy >= 1 && yy <= m) 
        if(G[xx][yy] == 'X') {
            dfs(xx, yy, color);
        }
    }
}

//BFS扩散
bool vis[N][M];
ll minc[4][4], mind[4][N][M];
void bfs(ll color) {
    memset(vis, 0, sizeof vis);
    queue<pair<ll,ll> > q;
    for(ll i = 1; i <= n; i++) {
        for(ll j = 1; j <= m; j++){
            if(G[i][j] == color) {
                vis[i][j] = true;
                mind[color][i][j] = 0;
                q.push({i,j});
            }
        }
    }
    while(q.size()) {
        auto u = q.front(); q.pop();
        for(ll i = 0; i < 4; i++) {
            ll xx = u.first + dx[i], yy = u.second + dy[i];
            if(xx >= 1 && xx <= n && yy >= 1 && yy <= m) 
            if(!vis[xx][yy]) {
                if(G[xx][yy] == '.') {
                    mind[color][xx][yy] = mind[color][u.first][u.second] + 1;
                } else {
                    mind[color][xx][yy] = mind[color][u.first][u.second] + 1;
                    minc[color][G[xx][yy]] = min(minc[color][G[xx][yy]], mind[color][u.first][u.second] );
                }
                vis[xx][yy] = true;
                q.push({xx, yy});
            }
        }
    }
}

int main() {
    memset(minc, 0x3f, sizeof minc);
    memset(mind, 0x3f, sizeof mind);
    cin >> n >> m;
    for(ll i = 1; i <= n; i++) {
        for(ll j = 1; j <= m; j++) cin >> G[i][j];
    }
    for(ll i = 1; i <= n; i++) {
        for(ll j = 1; j <= m; j++){
            if(G[i][j] == 'X') dfs(i, j, color++);
        }
    }
    for(ll i = 1; i <= 3; i++) {
        bfs(i);
    }
    ll ans = 0x3f3f3f3f;
    ans = min(ans, minc[1][2] + minc[1][3]);
    ans = min(ans, minc[2][1] + minc[2][3]);
    ans = min(ans, minc[3][1] + minc[3][2]);
    for(ll i = 1; i <= n; i++) {
        for(ll j = 1; j <= m; j++) {
            if(G[i][j] == '.') ans = min(ans, mind[1][i][j] + mind[2][i][j] + mind[3][i][j] - 3 + 1);
        }
    }
    cout << ans << endl;
    return 0;
}
```
