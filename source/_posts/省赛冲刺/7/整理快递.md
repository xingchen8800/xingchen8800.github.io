---
title: 整理快递
date: 2025-01-21 18:14:00
tags:
    - C++
    - 枚举
    - 推理
---

## 题目描述

小X所在的快递驿站今天到了很多快递，巧合的是这些快递都来自同一个商家，所以每一个快递盒的高度大小都是相同的。为了方便大家来取快递，小X将所有的快递进行了整理，一共整齐地码放了 $N$ 列，每一列的快递个数都是相同的。居民小Y来取快递的时候为了找到自己的快递，不小心把小X整理好的 $N$ 列快递弄乱了，导致每一列快递的数量不再相同了。找了这么久把快递弄乱了，还没找到自己的快递，小Y感到十分抱歉，于是他想要用最快的速度帮助小X把快递码放恢复原样。请你帮助小Y计算一下，他最少要移动多少个快递才能使得快递的码放恢复原样，即码放回 $N$ 列，每一列都是相同的数量。

## 输入格式

第一行，一个整数 $N$，表示码放快递的列数，$1 \leq N \leq 10000$。

接下来 $N$ 行，每行一个整数，分别表示弄乱后每一列快递中快递的数量，每个整数的范围是 $1$ 到 $10000$。

## 输出格式

输出一行，一个整数，表示小Y需要至少移动多少快递，才能使得快递码放恢复原样。

## 输入输出样例

### 输入样例1

```plaintext
4
2
10
7
1
```

### 输出样例1

```plaintext
7
```

## 说明

### 样例说明

一共移动了 7 个快递，从第 2 列移动 3 个快递到第 1 列，再从第 2 列移动 2 个快递到第 4 列，再从第 3 列移动 2 个快递到第 4 列，最终每一列快递的快递数量都是 5 个。

## 题解

通过题目条件算出每行的快递个数 $per$，然后模拟挪动即可（注意：挪动一次可以改变两行的数量，所以答案是 $sum \div 2$）。

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll N = 10001;
ll a[N], n;

int main() {
    cin >> n;
    ll tot = 0;
    for (ll i = 1; i <= n; i++) {
        cin >> a[i];
        tot += a[i];
    }
    ll per = tot / n;
    ll ans = 0;
    for (ll i = 1; i <= n; i++) {
        ans += llabs(a[i] - per);
    }
    cout << ans / 2 << endl;
    return 0;
}
```
