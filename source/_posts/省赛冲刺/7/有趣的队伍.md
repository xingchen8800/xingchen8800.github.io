---
title: 有趣的队伍
date: 2025-01-21 18:43:15
tags:
    - C++
    - 排序
    - sort
    - 推理
excerpt: 复习了用sort中自定义cmp进行排序定位元素位置的知识点，同时复习了交换元素位置有关的推理问题
---

## 题目描述

科丁博士正在教授他的学生们如何排队，并准备拍下一个队伍的照片。班级里有 $n(1≤n≤20000)$ 个学生，每个学生都有一个编号 $1,2,3,...,n$。

科丁博士希望按照特定顺序将学生们排成一列，看做一个序列 $a$ ，站在第 $i$ 个位置的学生的编号就是 $a_i$。

当科丁博士准备按下快门时，可能会有一个淘气鬼把自己的位置换到队列的另一个位置，当然也可能没有。恼羞成怒的科丁博士让学生们再按照开始的顺序重新排队，但是在接下来的五次重排期间，队伍中总可能有一个学生（1个或0个）不守规矩地折腾。现在给出了这五个时间点上的队伍排序情况，请问是否能够恢复出最初的序列 $a$。

每个时间点提供了新的队伍排序情况，其中每次最多只有一个学生从队伍的原始位置移动到了新位置，并且每次都是不同的学生在移动。

## 输入格式

第一行，一个整数 $N$，表示学生的数量 $(1≤N≤20000)$

接下来 $5$ 行，每行描述一张照片中学生队伍的排序。每一行中的数字表示学生的编号，范围是1到N

## 输出格式

输出 $N$ 行，每行一个数字，输出预期的序列 $a$

## 输入输出样例

### 输入样例1

```plaintext
5
1 2 3 4 5
2 1 3 4 5 
3 1 2 4 5
4 1 2 3 5
5 1 2 3 4
```

### 输出样例1

```plaintext
1
2
3
4
5
```

## 题解

{% notel red fa-lightbulb 解题知识点 %}
__排序定位__：当排列中的每两对元素的比较规则相同时，我们可以通过改`cmp`的方式用`sort()`确定每个元素的位置。

在本题中，我们需要确定预定的排列，所以我们需要得到每两对元素的先后关系（即比较规则）。
{% endnotel %}

一个重要 __结论__： __通过这 $5$ 个排列，我们可以确定每个学生 $x$ 是否在学生 $y$ 的前面。__

由题意：

> 每次都是不同的学生在移动。

可以得到：在 $5$ 的排列中，至少有 $3$ 个排列中 $x$ 与 $y$ 的先后关系是正确的（因为每个学生只能移动一次，所以最多 $x \to y$ 一次和 $y \to x$ 一次，最多共两次关系不正确），所以我们只需要记录 $x$ 在 $y$ 前的次数，当次数比 $3$ 大（或等于）时，就表明 $x$ 一定在 $y$ 前。

我们可以通过自定义 `sort()` 的 `cmp` 规则来进行排列（当 `cmp(x,y)` 为 $true$ 时会将 $x$ 放在 $y$ 前）。

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll N = 20001;
ll p[6][N], a[N], n;

bool cmp(ll a, ll b) {
    ll cnt = 0;
    for(ll i = 1; i <= 5; i++) {
        if(p[i][a] < p[i][b]) cnt++;
    }
    return cnt >= 3;
}

int main() {
    cin >> n;
    for(ll i = 1; i <= 5; i++) {
        for(ll j = 1; j <= n; j++) {
            cin >> a[j];
            p[i][a[j]] = j;
        }
    }
    sort(a + 1, a + n + 1, cmp);
    for(ll i = 1; i <= n; i++) cout << a[i] << "\n";
    cout << endl;
    return 0;
}
```
