---
title: 银行卡限额
date: 2025-01-21 19:18:41
tags:
    - C++
    - 搜索
    - 全排列
    - 高精度
---

## 题目描述

小C新办了一张银行卡，但由于信用等级过低，他的银行卡有一种非常特殊的限额方式，具体限额方式如下：

小C一天可以使用一次银行卡用来购买物品，一次可以购买多个物品，但购买的多个物品价格相加，不能发生进位（使用标准的10进制相加，不能发生进位的意思是指每一位相加都不产生进位）。

现在小C面前有 $N$ 个物品，价格分配是 $V_1,\dots,V_n$。小C想知道，如果购买，可以使得在满足银行卡限额的前提下，购买商品的数量最多（也就是数量最多的一组物品，价格相加没有导致进位）。

## 输入格式

第一行是一个整数 $N$ ，表示物品的数量 $(1≤N≤20)$

接下来 $N$ 行，每行一个整数，表示物品的价格，整数的范围是 $1$ 到 $100000000$。

## 输出格式

输出能够购买物品的最大数量

## 输入输出样例

### 输入样例1

```plaintext
5
522
6
84
7311
19
```

### 输出样例1

```plaintext
3
```

## 说明

### 样例说明

输入中有 $5$ 种物品，价格分别是 $522,6,84,7311,19$，相加时没有进位的 $3$ 个物品价格为 $522,6$ 和 $7311$，相加为 $7839$

## 题解

我们可以通过搜索的全排列确定一个决策方案，然后判断每个方案是否会进位，不进位就更新答案。

本题重点：__处理进位__

```c++
bool check(ll x, ll y) {
    while(x && y) { //x与y都不为0
        ll dx = x % 10, dy = y % 10;    //分解出x,y的末位
        if(dx + dy >= 10) return false; //发生进位
        x /= 10, y /= 10;
    }
    return true;
}
```

```c++
//子集问题：1.增量构造法（决策每子集） 2.位向量法（决策每一位选不选）

#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll N = 21;
ll n, b[N], is[N], ans = 0;
vector<ll> a[N];

bool check(ll x, ll y) {
    while(x && y) {
        if(x % 10 + y % 10 >= 10) return false;
        x /= 10, y /= 10;
    }
    return true;
}

//O(n)
void Calc() {
    ll sum = 0, cnt = 0;
    for(ll i = 1; i <= n; i++) {
        if(is[i]) {
            if(check(sum, b[i])) {
                sum += b[i];
                cnt++;
            } else return;
        }
    }
    ans = max(ans, cnt);
}

//O(2^n)
void dfs(ll i) {
    if(i > n) {
        Calc();
        return;
    }
    is[i] = 1;
    dfs(i+1);
    is[i] = 0;
    dfs(i+1);
}

int main() {
    cin >> n;
    for(ll i = 1; i <= n; i++) {
        cin >> b[i];
    }
    dfs(1);
    cout << ans << endl;
    return 0;
}
```

总体时间复杂度 $O(2^nn)$
