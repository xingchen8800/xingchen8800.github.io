---
title: 省赛冲刺1
date: 2024-12-07 18:36:38
tags:
---

## T2. 奶牛队伍

### 题目描述

$FJ$ 养了 $N$ 头奶牛，它们站在一条直线上，其中第i头奶牛在直线上的位置为 $x_i$（ $x_i$ 一定是整数）。除此以外，每头奶牛都有一个品种类型，用整数 $id_i$ 表示，可能存在多头奶牛属于同一个品种类型。

现在FJ希望从N头奶牛中挑选若干头奶牛拍一张照片，要求照片中每个不同品种的奶牛至少有一头，这张照片的花费取决于照片的宽度，即照片中最右边的奶牛位置和最左边的奶牛位置之差。

现在，请你计算出满足 $FJ$ 要求的照片最小花费。

### 输入格式

第1行一个整数 $N$ ，表示奶牛数量 $(1 \leq N \leq 5 \times 10^4)$

第2行到第 $N+1$ 行，每行两个整数，分别表示每头奶牛的位置 $x_i$ 和品种类型 $id_i$（ $x_i$ 和 $id_i$ 不超过 $10^9$）

### 输出格式

输出一行，一个整数，表示照片的最小花费

### 输入输出样例

#### 输入样例1

```
6
25 7
26 1
15 1
22 3
20 1
30 1
```

#### 输出样例1

```
4
```

### 题解

题目的直白翻译：选择一个长度最短的区间使区间内 __包含所有品种的奶牛__。

遇到在一条线上的坐标问题，首先对坐标进行排序。

区间选择问题，首先尝试枚举每个区间，找找优化的方案。对于每个区间，我们要维护区间内的奶牛种数，然后与总品种数进行比较。

区间枚举问题，优化方案首选 __双指针__，即用 $l,r$ 维护一个区间 $[l,r]$。我们让 $r$ 指针在 $1 \sim n$ 之间滑动，对于每个 $r$，我们找到一个最优的 $l$，再是否判断符合条件并记录。这里有几个小点需要注意：

1. 由于题目给到的 $id_i$ 范围特别大，我们用普通的桶装不下，此时可以使用 `map` 来代替桶。在每次让 $r$ 进入区间时，在 `map` 中标记。
2. 对于统计区间不同种类数的统计，我们可以在 `map` 标记时检查标记后的值是否为 $1$。
3. 如果 $l$ 不是最优的，当且仅当牛 $l$ 的 $id$ 在 $[l,r]$ 中的出现次数 $\ge 2$，此时删去 $l$，区间的奶牛种类数不会减少。

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll N = 50001;
ll n, kind = 0;
struct Cow {
    ll id, x;
} c[N];
map<ll, ll> m, m1;

bool Cmp(Cow &a, Cow &b) {
    return a.x < b.x;
}

int main() {
    cin >> n;
    for(ll i = 1; i <= n; i++) {
        cin >> c[i].x >> c[i].id;
        if(++m1[c[i].id] == 1) {
            kind++;
        }
    }
    sort(c + 1, c + n + 1, Cmp);
    ll l = 1, r = 1, kinds = 0, ans = LLONG_MAX;
    for(; r <= n; r++) {
        if(++m[c[r].id] == 1) kinds++;      //r进入区间
        while(l < r && m[c[l].id] > 1) {    //维护最优的l
            m[c[l].id]--;
            l++;
        }
        if(kinds == kind) {                 //符合条件
            ans = min(ans, c[r].x - c[l].x);
        } 
    }
    cout << ans << " " << kind << endl;
    return 0;
}
```

## T3. 圣诞礼物树

### 题目描述

圣诞节快到了，$FJ$ 计划用礼物来装扮家门口的 $N$ 棵圣诞松树（编号 $1 \sim N$，且 $N$ 是奇数， $1≤N≤1,000,000$ ），也就是将礼物挂在这些树上。 $FJ$ 会告诉他最信任的奶牛 $Bessie$ 一共 $K$ 个命令，每个命令包含两个整数 $A$ 和 $B$ ，表示 $Bessie$ 需要将编号为 $A \sim B$ 范围内的所有圣诞树上各挂上一个礼物。例如，如果命令是`9 12`，那么 $Bessie$ 应该给编号为 $9,10,11,12$ 的圣诞树各增加一个礼物。 

当 $Bessie$ 执行完所有的命令后， $FJ$ 想知道这 $N$ 棵圣诞树上的礼物数量的中位数是多少，也就是如果把这 $N$ 棵圣诞树按照礼物数量排序，序列的中间值是多少？

因为 $N$ 是奇数，所以中间值是惟一的。请帮助 $Bessie$ 计算出答案。

### 输入格式

第一行，用空格隔开的两个整数分别表示 $N$ 和 $K$（$1≤N≤1000000；1≤K≤25000$）

接下来 $K$ 行，表示 $FJ$ 的 $K$ 个命令，格式是`A B`，其中 $1≤A≤B≤N$

### 输出格式

输出一行，一个整数，表示 $N$ 棵圣诞树上的礼物数量的中位数

### 输入输出样例

#### 输入样例1：

```
7 4
5 5
2 4
4 6
3 5
```

#### 输出样例1：
```
1
```

### 题解

题目翻译：给一个长度为 $n$ 的序列作 $k$ 次操作，每次操作把 $[a,b] + 1$，求最后将所有树排序后序列中间的值。

$[a,b] + 1$，显然是区间修改，是差分数组跑不了（其实线段树和树状数组也不是不行，就是编码难度大，而且这题最后要每个树排序，用差分数组求前缀和最方便）。做完差分数组的修改后，再把数据通过求前缀和复原并求中位数即可。

```c++
#include <bits/stdc++.h>
using namespace std;

#define ll long long
const ll N = 1e6 + 1;
ll d[N], arr[N];
ll n, k, a, b;

int main() {
    cin >> n >> k;
    for(int i = 1; i <= k; i++) {
        cin >> a >> b;
        d[a]++, d[b + 1]--;         //区间修改
    }
    for(int i = 2; i <= n; i++) {
        d[i] += d[i - 1];           //前缀和
    }
    //求中位数
    sort(d + 1, d + n + 1);
    cout << d[(n + 1) / 2] << endl;
    return 0;
}
```

## T4. 操作

### 题目描述

小可可有一个数组 $\{a_n\}$（初始值为 $\{a_n\}=\{0,0,\ldots,0\}$）和从左到右的 $m$ 个机器，其中第 $i$ 个机器有类别 $o_i \in \{1,2\}$ 和参数 $x_i,y_i$。第 $i$ 个机器执行的操作如下：

- 若 $o_i=1$，则将 $a_{(x_i)}$ 加上 $y_i$，此时保证 $1 \le x_i \le n$，$1 \le y_i \le 10^4$。
- 若 $o_i=2$，则执行第 $x_i \sim y_i$ 个机器的操作各一次，此时保证 $1 \le x_i \le y_i \le i-1$。
- 特别地，保证 $o_1=1$。

现在，小可可依次执行了第 $c_1,c_2,\ldots,c_k$ 个机器的操作各一次，她想知道最后得到的数组 $\{a_n\}$ 是什么。

由于数组中元素的值可能很大，你只需要帮她求出每个元素除以 $10007$ 的余数即可。

### 输入格式

第一行三个正整数 $n,m,k$。

接下来一行 $k$ 个正整数 $\{c_k\}$。

接下来 $m$ 行，第 $i$ 行三个正整数 $o_i,x_i,y_i$。

### 输出格式

一行 $n$ 个非负整数，表示数组 $\{a_n\}$ 中每个元素的值除以 $10007$ 的余数。

### 样例 #1

#### 样例输入 #1

```
2 3 3
1 2 3
1 1 2
2 1 1
2 1 2
```

#### 样例输出 #1

```
8 0
```

### 提示

#### 样例 1 解释

先执行第 $1$ 个机器的操作，给 $a_1$ 加上了 $2$。

然后执行第 $2$ 个机器的操作，它操作了第 $1$ 个机器，给 $a_1$ 加上了 $2$。

然后执行第 $3$ 个机器的操作。它先操作了第 $1$ 个机器，给 $a_1$ 加上了 $2$；然后操作了第 $2$ 个机器，第 $2$ 个机器又操作了第 $1$ 个机器，给 $a_1$ 加上了 $2$。

综上所述，最后得到的数组为 $\{8,0\}$。

#### 数据范围

对于 $10\%$ 的数据，$n,m,k \le 10$。

对于 $30\%$ 的数据，$n,m,k \le 1000$。

对于另外 $20\%$ 的数据，$n=1$。

对于另外 $20\%$ 的数据，$k=1$。

对于 $100\%$ 的数据，$1 \le n,m,k \le 2 \times 10^5$，$1 \le c_i \le n$，$o_i \in \{1,2\}$，$o_1=1$。此外，对于第 $i$ 个机器，保证：

- 若 $o_i=1$，则 $1 \le x_i \le n$，$1 \le y_i \le 10^4$。
- 若 $o_i=2$，则 $1 \le x_i \le y_i \le i-1$。

### 题解

题目翻译：给定一个操作序列 $c$，请按顺序执行机器 $c_i$。有两类机器：一类和二类。一类可以将 $a_{x_i}+=y_i$，二类要执行机器 $x_i \sim y_i$。

看完题目，可以发现对于机器 $i$，只需要求它被执行的 __次数__ 就能得出答案，没必要模拟。题目中二类机器的操作是区间修改一些机器的执行次数，所以我们考虑用 __差分数组__ 来解决。

- 对于一类机器，它们可以直接修改 $a_x$，所以每被直接执行一次，执行次数 $+=1$
- 对于二类机器，它们需要间接执行其他机器，所以每被直接执行一次，机器 $[x,y]$ 的执行次数 $+= 自己的执行次数$

现在问题来了，由于二类机器的被执行次数可能在不同时间会发生 __改变__，所以我们要考虑如何统计完整一个二类机器的执行次数。

> 若 $o_i=2$，则执行第 $x_i \sim y_i$ 个机器的操作各一次，此时保证 $1 \le x_i \le y_i \le i-1$。

注意一个要点：$1 \le x_i \le y_i \le i-1$。也就是说每个机器只能执行编号在它 __之前__ 的机器。这样一来，每个机器的执行次数就由它后面的机器的执行次数确定，所以我们 __从后往前__ 遍历每个机器，每个机器的执行次数就是它之后的差分数组求前缀和。

因为是从后往前地遍历，所以差分数组也要倒过来，原本的 $d_1$ 变成了 $d_m$，此时区间修改也要倒过来：

```c++
//[l,r]+1
d[r]++;
d[l-1]--;
```

完整代码：

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll N = 2e5 + 1, MOD = 10007;

ll n, m, k;
ll o[N], x[N], y[N], cf[N], ans[N], cnt[N];
int main() {
    cin >> n >> m >> k;
    //在输入操作序列时初始统计执行次数
    while(k--) {
        int c;
        cin >> c;
        cf[c]++, cf[c-1]--;
    }
    for(ll i = 1; i <= m; i++) cin >> o[i] >> x[i] >> y[i];
    //从后往前遍历每个机器
    for(ll i = m; i >= 1; i--) {
        //机器 i 被执行了 cnt[i] 次
        cnt[i] = ((cnt[i+1] + cf[i]) % MOD + MOD) % MOD;
        //二类机器
        if(o[i] == 2) {
            //[x[i], y[i]]+=cnt[i]
            cf[y[i]] += cnt[i];
            cf[x[i]-1] -= cnt[i];
        }
    }
    for(ll i = m; i >= 1; i--) {
        //是一类机器再执行修改
        if(o[i] == 1) 
            ans[x[i]] = (ans[x[i]] + cnt[i] * y[i]) % MOD;
    }
    for(int i = 1; i <= n; i++) cout << ans[i] << " ";
    return 0;
}
```

## 课后T1. 国王的奖赏

### 题目描述

小科战胜恶龙，救回公主，国王答应奖赏给他黄金。为了测试小科是否既有勇，也有谋，国王是这样对小科进行赏赐的：

国王拿来了 $N$ 块不同大小的黄金，价值自然也不相同，编号 $1-N$ ，第 $i$ 块黄金的价值为 $A_i$ 。小科可以进行 $M$ 次操作，每次小科可以选择一个编号为 $x(1 \leq x \leq N-1)$的黄金，把它融入编号为 $x+1$ 的黄金，融合后的黄金价值为原先两块黄金价值之和。 $M$ 次操作过后，小科可以任选一块黄金带走，请问小科最终可以获得的黄金最大价值是多少？

### 输入格式

输入共三行。

第一行一个整数 $N$，表示黄金数量。

第二行一个整数 $M$，表示小科的机会数量。

第三行有 $N$ 个非负整数，相邻两个数用空格隔开，表示初始所有黄金的价值.

### 输出格式

一行，仅一个非负整数，表示答案。

### 输入输出样例

#### 输入样例1：

```
10 5
890 965 256 419 296 987 45 676 976 742
```

#### 输出样例1：

```
3813
```

### 说明

***【数据规模与约定】*** 

对于 $100\%$ 的数据， $1<N \leq 1000000,0≤M≤N-1,0≤A_i≤1000000$.

### 题解

根据推理可得：

$\operatorname{}{定理1}$：如果合并了两个黄金，那么这两个黄金一定要合并成最终的那个被拿走的黄金，否则这次合并就是 __无意义的__。

$\operatorname{定理2}$：由 $\operatorname{定理1}$ 得，若所有合并操作都是 __有意义的__，那么所有被合并的黄金一定在一段 __连续的区间__ 上。

$\operatorname{定理3}$：对于一段子区间，若把其中的黄金融合，无论采取如何的策略，最终结果都是一样的，都是 __区间和__。

所以这道题就是：在 $N$ 个数中取长度为 $M+1$ 的区间，使其区间和最大。

这就是妥妥的 __单调队列模板题__！

复习一下单调队列求最大区间和的模板代码：

{% folding green::模板 %}

```c++
//先求前缀和（略）

deque<ll> q; q.push_back(0);    //0是辅助下标，用0的原因间下面的区间解释
ll ans = 0;
//区间：[q.front()-1,i]
for(int i = 1; i <= n; i++) {
    while(q.size() && s[q.back()] >= s[i]) q.pop_back();    //去尾，维护队列单调
    while(q.size() && i - q.front() >= m+1) q.pop_front();  //删头，维护队列长度
    q.push_back(i);                                         //入队
    ans = max(ans, s[i] - s[q.front()]);                    //更新答案
}
```

{% endfolding %}

```c++
#include <bits/stdc++.h>
using namespace std;

#define ll long long

const ll N = 1000001;

ll n, m, s[N];
int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; i++) {
        cin >> s[i];
        s[i] += s[i-1]; //calc prefix sum
    }
    deque<int> q;
    ll ans = 0;
    q.push_back(0);
    for(int i = 1; i <= n; i++) {
        while(!q.empty() && s[q.back()] >= s[i]) q.pop_back();
        q.push_back(i);
        while(!q.empty() && i - q.front() > m+1) q.pop_front();
        ans = max(ans, s[i] - s[q.front()]);
    }
    cout << ans << endl;
    return 0;
}
```

## 课后T2.海底高铁(rail)

### 题目描述

某国有一条铁路经过 $N$ 个城市，每个城市都有一个站。不过，由于各个城市之间不能协调好，于是乘客每经过两个相邻的城市之间（方向不限），必须单独购买这一小段的车票。第 $i$ 段铁路连接了城市 $i$ 和城市 $i+1(1≤i<N)$。如果乘车路线比较远，那么乘客需要分别购买每一段的车票，第 $i$ 段铁路购买纸质单程票需要 $A_i$ 元。虽然一些事情没有协调好，但各段铁路公司也为了方便乘客，推出了 $IC$ 卡。第 $i$ 段铁路，需要花 $Ci$ 元的工本费购买一张 $IC$ 卡，如果刷卡乘坐第 $i$ 段车路，那么这段铁路一次就只要从卡里扣 $B_i$ ($B_i < A_i$) 元。IC 卡可以提前购买，有钱就可以从网上买得到，而不需要亲自去对应的城市购买。工本费不能退，也不能购买车票。每张卡都可以充值任意数额。对于第 $i$ 段铁路的 $IC$ 卡，无法乘坐别的铁路的车。

小科现在需要出差，要去 $M$ 个城市，从城市 $P_1$ 出发分别按照 $P_1,P_2,P_3,\dots,P_M$ 的顺序访问各个城市，可能会多次访问一个城市，且相邻访问的城市位置不一定相邻，而且不会是同一个城市。

现在他希望知道，出差结束后，至少会花掉多少的钱，包括购买纸质车票、买卡和充值的总费用。

### 输入格式

第一行两个整数，$N,M$。

接下来一行，$M$ 个数字，表示 $P_i$。

接下来 $N−1$ 行，表示第 $i$ 段铁路的 $A_i,B_i,C_i$。

### 输出格式

一个整数，表示小科完成出差的最少花费

### 输入输出样例

#### 输入样例1：

```
9 10 
3 1 4 1 5 9 2 6 5 3 
200 100 50 
300 299 100 
500 200 500 
345 234 123 
100 50 100 
600 100 1 
450 400 80 
2 1 10
```

#### 输出样例1：

```
6394
```

### 说明

样例说明：$2 \to 3$ 这一段 以及 $8 \to 9$ 这一段小科选择买纸质的票，其余的段分别买 $IC$ 卡。

***数据规模与约定***

对于 $30\%$ 数据 $M=2$。

对于另外 $30\%$ 数据 $N≤1000,M≤1000$。

对于 $100\%$ 的数据 $M,N≤100000$，$1 \leq P_i \leq N$，$A_i,B_i,C_i≤100000$。

### 题解

这道题和 $T4$ 很像。我们既然要对每个区间购买的票种做出选择，我们肯定要知道这个区间被经过的 __次数__。当 $次数 \times A_i > B_i + C_i \times 次数$ 时，购买 $IC$ 卡，否则购买纸质票。

统计每个区间的经过次数，我们可以通过差分数组来实现：

![例图](/images/省赛冲刺/1/1.png)

例如对于上图，若用差分维护 __区间__ 的经过次数，我们考虑将点 $i$ 的前缀和作为 $i \to i+1$ 的经过次数。若要将 $[2,5]$ 的经过次数 $+1$，即将 $d_2 + 1, d_5 - 1$，不用 $d_{5+1}-1$ 是因为区间 $4 \to 5$ 的经过次数归 $4$ 存储，即原 $r_1=4$， 则 $r_1+1=5=r$。

```c++
#include <bits/stdc++.h>
using namespace std;

#define ll long long

ll n, m;
const ll N = 100001;
ll p[N], a[N], b[N], c[N], cf[N] = {0}, cnt[N] = {0};

int main() {
    cin >> n >> m;
    for(int i = 1; i <= m; i++) cin >> p[i];
    for(int i = 1; i <= n - 1; i++) cin >> a[i] >> b[i] >> c[i];
    for(int i = 2; i <= m; i++) {
        //差分，注意左右端点的顺序可能颠倒
        ll l = p[i-1], r = p[i];
        if(l > r) swap(l,r);
        cf[l]++, cf[r]--;
    }
    ll sum = 0;
    for(int i = 1; i <= n - 1; i++) {   //i --> i+1
        cnt[i] = cnt[i-1] + cf[i];      //前缀和求 i --> i+1 的经过次数
        sum += min(c[i] + cnt[i] * b[i], cnt[i] * a[i]);    //求解最小花费
    }
    cout << sum << endl;
    return 0;
}
```

## 课后T3. Jessica's Reading Problem

### 题目描述

Jessica是一个非常可爱的女孩，最近她遇到了一个问题。期末考试即将到来，但她几乎没有花时间学习这门课程。如果她想通过考试，她必须掌握一本厚厚的课本中包含的所有知识点。教科书的作者对这些知识点非常重视，所以某个知识点可能在不止一页上进行讲解。Jessica认为，如果她能把每个知识点至少读一次，那么她就能通过考试。

时间关系，她决定只读这本书的连续的某些页，其中必须包含整本书涉及到的所有知识点。当然，她读的部分应该尽可能少。Jessica的课本的每一页手动编列出了这一页的知识点（一页仅一个知识点），请你帮助Jessica决定她应该阅读哪个连续的部分。为了方便起见，每个知识点都用一个 $ID$ 编码，$ID$ 是一个非负整数。

### 输入格式

输入的第一行是整数 $P（1≤P≤1000000）$，这是Jessica的课本的页数。

第二行包含 $P$ 个非负整数，描述每一页的知识点，范围不超过 $32$ 位整数类型。

### 输出格式

输出Jessica应该阅读的最少页数

### 输入输出样例

#### 输入样例1：

```plaintext
5
1 8 8 8 1
```

#### 输出样例1：

```plaintext
2
```

### 题解

题意简述：在 $P$ 页中选取最短的阅读区间使其涉及所有的知识点。

同 [$T2$](/2024/省赛冲刺/1/省赛冲刺1/#t2.-%E5%A5%B6%E7%89%9B%E9%98%9F%E4%BC%8D)：

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll N = 1000001;
ll n, kind = 0;
struct KnowledgePoint {
    ll id, x;
} c[N];
map<ll, ll> m, m1;

bool Cmp(KnowledgePoint &a, KnowledgePoint &b) {
    return a.x < b.x;
}

int main() {
    cin >> n;
    for(ll i = 1; i <= n; i++) {
        cin >> c[i].id;
        c[i].x = i;
        if(++m1[c[i].id] == 1) {
            kind++;
        }
    }
    sort(c + 1, c + n + 1, Cmp);
    ll l = 1, r = 1, kinds = 0, ans = LLONG_MAX;
    for(; r <= n; r++) {
        if(++m[c[r].id] == 1) kinds++;
        while(l < r && m[c[l].id] > 1) {
            m[c[l].id]--;
            l++;
        }
        if(kinds == kind) {
            ans = min(ans, c[r].x - c[l].x + 1);
        } 
    }
    cout << ans << endl;
    return 0;
}
```

## 课后T4. Rope Folding[USACO-2012-Feb-B]

### 题目描述

FJ有一条长度为 $L$ 的绳 $(1≤L≤10000)$，在绳子的不同位置有 $N(1≤N≤100)$ 个结,包括绳子两端的两个结。

FJ注意到绳子上存在一个位置，从这个位置把绳子进行对折，对折后一股绳子上有结的位置，另一股绳子相同位置也有一个结，如下图所示：

![课后T4图](/images/省赛冲刺/1/2.png)

请帮助FJ计算一下，符合上述条件的位置一共有多少个？

在有结的位置进行折叠是可以的，但是两端的那两个结不可以，另外折叠后较长的一股绳上有结是可以的（也就是说对折后两股绳子的长度不一定一样，而且只要求两股绳子重叠的部分存在相对的结即可）。FJ只会折叠绳子一次，不会进行多次折叠。

### 输入格式

第一行，用空格隔开的两个整数分别表示 $N$ 和 $L$

接下来 $N$ 行，每行一个整数，分别表示 $N$ 个结的位置，每个整数的范围是 $0$ 到 $L$ ，并且两端的两个结的位置分别是 $0$ 和 $L$

### 输出格式

一行，一个整数，表示符合折叠条件的折叠位置的数量，注意折叠位置 __可以是小数__。

### 输入输出样例

#### 输入样例1：

```plaintext
5 10
0
10
6
2
4
```

#### 输出样例1：

```plaintext
4
```

### 说明

#### 样例说明：

样例中，绳子的长度是 $10$ ，一共有 $5$ 个结，位置分别是 $0,2,4,6,10$ 。一共存在 $4$ 个符合折叠条件的折叠位置，分别是 $1,2,3,8$。

### 题解

本题核心就是 __桶__。

我们考虑用桶记录每个点是否有结，然后枚举 $1 \sim L-1$ 中的所有点（包括小数点后为 $5$ 的点），模拟判断是否符合条件即可。

```c++
#include <bits/stdc++.h>
using namespace std;

#define ll long long

ll len, n;
const ll N = 101, L = 10001;
ll x[N];
bool isPos[L] = {0};

bool check1(int i) {
    int l,r; l = r = i;
    while(l >= 0 && r <= len) {
        if(isPos[l] != isPos[r]) return false;
        l--, r++;
    }
    return true;
}

bool check2(int i) {
    int l = i, r = i+1;
    while(l >= 0 && r <= len) {
        if(isPos[l] != isPos[r]) return false;
        l--, r++;
    }
    return true;
}

int main() {
    cin >> n >> len;
    for(ll i = 1; i <= n; i++) {
        cin >> x[i];
        isPos[x[i]] = true;
    }
    ll cnt = check2(0); 
    for(ll i = 1; i < len; i++) {
        cnt += check1(i);   //i点
        cnt += check2(i);   //i+0.5点
    }
    cout << cnt << endl;
    return 0;
}
```
