---
title: 习题-修理大师
date: 2025-02-13 22:30:13
tags:
    - C++
    - 优先队列
    - 堆
    - 模拟
---

## 题目描述

小 $A$ 的扫雷机器人虽然最终圆满的完成了任务，拆完了所有的地雷，但是也有不少机器人在扫雷过程中负伤。为了让这些可怜的扫雷机器人恢复活力，小 $A$ 制造了一台修理机器人。由于修理机器人只有一台，每次只能修理一台扫雷机器人，所以可能会有很多的扫雷机器人需要排队等候。扫雷机器人们脾气不好，如果等待的时间太久他们就会互相打架或者乱扔零件（自己的或者其他机器人的），特别是那些负伤较重的扫雷机器人，脾气更加的坏。

小 $A$ 知道有 N 台机器人需要修理，第 i 台机器人将会在时间 $a_i$ 到达修理厂，它的负伤度为 $p_i$（N 台机器人的负伤度各不相同），修理它需要 $t_i$ 的时间。为了让扫雷机器人们尽量不要打架或乱扔零件，小 $A$ 制定了一种排队规则，详细描述如下：

- 修理机器人不会休息，一旦空闲，会立刻从当前已到达的机器人中选择一台进行修理，选择所花时间可以忽略不计。
- 一旦选择修理某台机器人，就一定会修理完成（花费 $t_i$ 的时间），即使有优先级更高的机器人到达，也不会打断修理。
- 如果有多台机器人都在等待维修，那么优先选择负伤度最高的机器人进行修理。

小 $A$ 想检验一下这种排队规则的效果如何，他想知道按照这种排队规则，等待时间最长的扫雷机器人的等待时间是多少？机器人 i 的等待时间定义为机器人 i 开始修理的时间减去机器人 i 的到达时间。

## 输入格式

- 第 1 行：一个整数 N，表示机器人的数量。
- 第 2 行到第 N+2 行：每行两个空格分隔的整数，其中第 i+1 行的两个整数 $a_i$ 和 $t_i$ 表示第 i 台扫雷机器人的到达时间和修理时间。
- 输入数据按照扫雷机器人的负伤度从高到低给出，即：输入靠前的机器人的负伤度也较高。

## 输出格式

- 一行，一个整数，表示等待时间最长的扫雷机器人的等待时间。

## 输入输出样例

### 输入样例 1

```plaintext
3
20 10
10 15
20 5
```

### 输出样例 1

```plaintext
15
```

### 输入样例 2

```plaintext
4
25 10
10 15
20 5
10 5
```

### 输出样例 2

```plaintext
30
```

### 输入样例 3

```plaintext
3
30 10
15 10
5 5
```

### 输出样例 3

```plaintext
0
```

## 说明

【数据范围】

- 对于 10% 的数据：N = 1；
- 对于 100% 的数据：$1 \leq N \leq 100{,}000$，$1 \leq t_i \leq 10{,}000$，$1 \leq a_i \leq 1{,}000{,}000{,}000$；

## 题解

### 理解题意

我们可以把这题看作一个对时间 $t$ 的模拟：

1. 第 $i$ 个机器人到达，开始修理，$t$ 要加上 $t_i$
2. 寻找所有在 $t$ 时刻到达的机器人，并挑选优先级最高的机器人当作 $i$，重复第一步

```c++
sort(robots + 1, robots + 1 + n, [=](Robot&a, Robot&b) { 
    if(a.a != b.a) return a.p > b.p;
    return a.a < b.a;
});
ll i = 1, t = robots[1].a, maxt = 0;
while(i <= n) {
    t += robots[i].t;
    maxt = max(maxt, t - robots[i].a);
    bool f = false;
    for(ll j = i; j <= n; j++) {
        if(robots[j].a <= t) {  //找到第一个就是优先级最高的
            i = j;
            f = true;
            break;
        }
    }
    if(!f) i++;     //当前时间无机器人，跳到下一个时间
}
```

但是，这种方法的时间复杂度为 $O(n^2)$，必然 $\color{red}{\text{TLE}}$。

### 优化

我们可以使用优先队列来将寻找所有在 $t$ 时刻到达的机器人中优先级最高者的时间复杂度降为 $O(\log{n})$，这样总体时间复杂度就是 $O(n\log{n})$，就能 $\color{green}{\text{AC}}$ 了。

```c++
sort(/*同上*/);
priority_queue<Robot> q;    //大根堆
ll i = 1, t = robots[1].a, maxt = 0;
while(i <= n || q.size()) {
    while(i <= n && robots[i].a <= t) q.push(robots[i++]);  //如果有在t时就到达的机器人，统统入队（注意，此时i指向第一个未入队的机器人）
    if(q.size()) {  //当队列里有机器人
        Robot tmp = q.top(); q.pop();  //取出队首（优先级最高）的机器人
        maxt = max(maxt, t - tmp.a);    //更新
        t += tmp.t;
    } else t = robots[i].a; //否则直接跳到下一个机器人的到达时间
}
```

### 完整代码

``` c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 100001;

struct Robot {
    ll a, t, p;
    bool operator<(const Robot& rhs) const {
        return this->p > rhs.p;
    }
} robots[N];

int main() {
    ll n;
    cin >> n;
    
    for (ll i = 1; i <= n; i++) {
        cin >> robots[i].a >> robots[i].t;
        robots[i].p = i;
    }
    priority_queue<Robot> q;
    sort(robots + 1, robots + 1 + n, [=](const Robot& lhs, const Robot& rhs) {
        return lhs.a < rhs.a;
    }); 
    ll i = 1, t = robots[1].a, maxt = 0;
    while(i <= n || q.size()) {
        while(i <= n && robots[i].a <= t) q.push(robots[i++]);  //如果有在t时就到达的机器人，统统入队（注意，此时i指向第一个未入队的机器人）
        if(q.size()) {  //当队列里有机器人
            Robot tmp = q.top(); q.pop();  //取出队首（优先级最高）的机器人
            maxt = max(maxt, t - tmp.a);    //更新
            t += tmp.t;
        } else t = robots[i].a; //否则直接跳到下一个机器人的到达时间
    }
    cout << maxt << endl;
    return 0;
}
```
