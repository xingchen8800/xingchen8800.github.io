---
title: 最大中间价值
date: 2025-02-08 20:25:16
tags:
    - C++
    - 堆
    - 优先队列
---

## 题目描述

商店里有 $n$ 个物品, 依次编号为 $1 \ldots n$, 其中第 $i$ 件物品的价格是 $P_i$, 价值是 $V_i$. 小科有 $C$ 元钱, 他想要购买 $m$ ($m$ 是奇数) 件物品, 并且希望购买的 $m$ 件物品中价值排在中间的物品价值尽量高. 请计算并输出这个中间值的最大价值, 如果无法购买 $m$ 件物品, 输出 $-1$.

## 输入格式

第 $1$ 行: $3$ 个空格分隔的整数 $m$, $n$, $C$. ($1 \leq m < 20000$, $m \leq n \leq 100000$, $0 \leq C \leq 2 \times 10^9$).

接下来 $n$ 行: 每行两个空格分隔的整数, 其中第 $i+1$ 行的两个整数 $V_i$ 和 $P_i$ 分别表示第 $i$ 件物品的价值和价格. ($0 \leq V_i \leq 2 \times 10^9$, $0 \leq P_i \leq 10^5$).

## 输出格式

一行: 一个整数, 表示可以获得的价值中间值的最大值, 如果无法购买 $m$ 件物品, 输出 $-1$.

## 输入输出样例

### 输入样例1

```plaintext
3 5 70
30 25
50 21
20 20
5 18
35 30
```

### 输出样例1

```plaintext
35
```

## 说明

### 【样例说明】

购买第 $2、4、5$ 件物品，可以获得最大价值中间值 $35$。

## 题解

题目要求我们既要选出 $m$ 个物品使它们的价格 $\leq C$，由要使中位数最大。所以，我们可以考虑先去掉一个条件，然后把另一个条件变成判断。

不难发现，判断 $m$ 个物品使它们的价格 $\leq C$ 很容易，但是选出 $m$ 个物品使其满足条件很困难。所以，我们考虑控制“使中位数最大”的条件，通过确定中位数的位置，左右各凑出 $m \div 2$ 个物品，然后判断 $m$ 个物品使它们的价格 $\leq C$。

所以，我们将 $n$ 个物品按照价值从小到大排序，样例为：

$$
\begin{array}{c|lcr}
i & 1 & 2 & 3 & 4 & 5 \\
\hline
V_i         & 5 & 20 & 30 & 35 & 50 \\
\hline
P_i         & 18 & 20 & 25 & 30 & 21
\end{array}
$$

我们从右往左将可行的数作为中位数，就可以使第一次判断通过的价值中位数即为最大中间价值。

由于中位数左右各有 $m \div 2$ 个物品，所以中位数 $i$ 的取值为 $\frac{m}{2} < i < n - \frac{m}{2}$。

$$
\begin{array}{c|lcr}
i   & 1 & \color{green}{2} & \color{green}3 & \color{green}4 & 5 \\
\hline
V_i & 5 & \color{green}20 & \color{green}30 & \color{green}35 & 50 \\
\hline
P_i & 18 & \color{green}20 & \color{green}25 & \color{green}30 & 21
\end{array}
$$

中位数已经确定后，只要左右各有 $m \div 2$ 个物品即可，物品的价值无关紧要，所以我们只需要选 $i$ 左侧 $m \div 2$ 个价格最小的物品，右侧 $m \div 2$ 个价格最小的物品。这样一来，可以使这 $m$ 个物品的价格和尽量小，$m \leq C$ 的可能性越大。

$$
\begin{array}{c|lcr}
i   & \color{orange}1 & 2 & 3 & \color{blue}4 & \color{orange}5 \\
\hline
V_i & \color{orange}5 & 20& 30& \color{blue}35 & \color{orange}50 \\
\hline
P_i & \color{orange}18& 20& 25& \color{blue}30 & \color{orange}21
\end{array}
$$


可以，每次都选 $i$ 左侧 $m \div 2$ 个价格最小的物品，右侧 $m \div 2$ 个价格最小的物品，时间复杂度为一次 $O(n)$，$n$ 次 $O(n^2)$，显然超时。超时 $\to$ 优化 $\to$ 预处理，我们可以用`priority_queue`选择出对于每个 $i$ 的 $m \div 2$ 个最小价格的物品，并记录。

```c++
//costl[i]:[1,i],costr[i]:[i,n]
ll costl[N], costr[N];
priority_queue<ll> q1,q2;
for(ll i = 1; i <= n; i++) {
    //先选择a[i]
    costl[i] = costl[i-1] + a[i].p;
    //a[i]入队
    q1.push(a[i].p);
    if(i > m / 2) { //物品数量>m/2
        //从costl[i]中减掉花费最大的（相当于优先队列选前m/2个最小值）
        costl[i] -= q1.top();
        q1.pop();
    }
}
for(ll i = n; i >= 1; i--) {
    //先选择a[i]
    costr[i] = costr[i+1] + a[i].p;
    //a[i]入队
    q2.push(a[i].p);
    if(i < n - m / 2) { //物品数量>m/2
        //从costr[i]中减掉花费最大的（相当于优先队列选前m/2个最小值）
        costr[i] -= q2.top();
        q2.pop();
    }
}
```

### 完整代码

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll N = 100010;

struct Item {
    ll v, p;
    bool operator<(const Item& rhs) const {
        return v < rhs.v;
    }
} a[N];
ll n, costl[N], costr[N], m, c;

int main() {
    cin >> m >> n >> c;
    for(ll i = 1, v, p; i <= n; i++) {
        cin >> v >> p;
        a[i] = {v, p};
    }
    sort(a + 1, a + n + 1);
    priority_queue<ll> pq1, pq2;
    for(ll i = 1; i <= n; i++) {
        costl[i] = costl[i - 1] + a[i].p;
        pq1.push(a[i].p);
        if(i > m / 2) {
            costl[i] -= pq1.top();
            pq1.pop();
        } 
    }
    for(ll i = n; i >= 1; i--) {
        costr[i] = costr[i + 1] + a[i].p;
        pq2.push(a[i].p);
        if(i <= n - m / 2) {
            costr[i] -= pq2.top();
            pq2.pop();
        } 
    }
    for(ll i = n - m / 2; i > m / 2; i--) {
        if(costl[i - 1] + costr[i + 1] + a[i].p <= c) {
            cout << a[i].v << endl;
            return 0;
        }
    }
    cout << -1 << endl;
    return 0;
}
```
