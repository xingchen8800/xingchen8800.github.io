---
title: 习题-丛林探险
date: 2025-02-09 20:03:55
tags:
    - C++
    - 优先队列
    - 堆
    - 贪心
---

## 题目描述

奶牛们获得了一辆卡车并决定驾驶着这辆卡车进行一次丛林探险。由于驾驶技术太差，卡车底盘蹭到了岩石上，把卡车的油箱撞破了。现在卡车每行驶一单位的路程就会漏一单位的油。为了修理卡车，奶牛们需要沿着一条蜿蜒的长路(不超过 $1000000$ 单位的距离)开到最近的城镇上，路途中有 $N(1≤N≤10000)$ 个加油站，每个加油站可以加的油量是 $1$ 到 $100$ 之间的整数。为了尽快的达到城镇，奶牛们想尽可能少的停下来加油，油箱的加油量是无限大的。卡车目前距离城镇的距离是 $L$ 个单位，油箱里目前有 $P(1≤P≤1000000)$ 个单位的油.请你帮助奶牛们计算一下它们能不能达到城镇，如果能达到城镇，那么计算出过程中需要的最少的加油站的数量。

## 输入格式

第一行，一个整数 $N$

第 $2$ 到 $N+1$ 行，每行两个整数，第一个表示加油站距离城镇的距离，第二个表示这个加油站能够加油的油量

第 $N+2$ 行：两个整数分别表示 $L$ 和 $P$

## 输出格式

一行，如果能够达到城镇，输出路径过程中需要的最少加油站的数量，如果不能达到城镇输出-1

## 输入输出样例

### 输入样例1

```plaintext
4
4 4
5 2
11 5
15 10
25 10
```

### 输出样例1

```plaintext
2
```

## 说明

### 【样例说明】

卡车距离城镇的距离是 $25$ 个单位，目前邮箱的油量是 $10$ 单位，中途一共有 $4$ 个加油站，距离城镇的距离分别是 $4,5,11,15$ (所以距离卡车的距离分别是 $21,20,14,10$ )，每个加油站能够提供油量分别是 $4,2,5,10$.

奶牛们驾驶了 $10$ 个单位的距离，停下来加了 $10$ 单位的油，然后又行驶了 $4$ 单位的距离，停下来加了 $5$ 单位的油，然后达到了城镇。

## 题解

1. 遇到坐标系，先按坐标排序。
2. 尽可能少得加油次数，就要尽可能多得单次加油量。
3. 所以贪心策略如下：如果车内油量不足以行驶到某个加油站 $i$ 时，就让车在前 $i-1$ 个加油站中，选择一个可加最多油的加油站加油。

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll N = 100001;
ll n, p, l;
struct Node {
    ll pos, oil;
    bool operator<(const Node& rhs) const {
        return pos < rhs.pos;
    }
} a[N];

int main() {
    cin >> n;
    for(ll i = 1; i <= n; i++) cin >> a[i].pos >> a[i].oil;
    cin >> l >> p;
    for(ll i = 1; i <= n; i++) a[i].pos = l - a[i].pos;
    priority_queue<ll> q;
    sort(a + 1, a + n + 1);
    //cnt表示加油次数,sumOil表示历史加油总数,i表示当前加油站下标
    ll cnt = 0, sumOil = p, i = 1;
    while(sumOil < l) { //还未到达终点
        while(i <= n && a[i].pos <= sumOil) {   //访问每个在当前油量下可以访问的加油站
            q.push(a[i++].oil); //入队备选
        }
        if(!q.size()) {         //当前不能到达任何加油站
            cout << -1 << endl;
            return 0;
        }
        //卡住了，要从前面经过的加油站里选择一个加油量最大的加油
        sumOil += q.top(); q.pop();
        cnt++;
    }
    cout << cnt << endl;
    return 0;
}
```
