---
title: 锁妖塔
date: 2025-02-10 15:46:39
tags:
    - C++
    - 二分
    - 贪心
    - 优先队列
    - 堆
---

## 题目描述

锁妖塔有 $N$（ $1 \leq N \leq 2 \times 10^5$ ）层，从下往上依次编号为 $1,\dots,N$ 。锁妖塔的每层都有一个妖怪，第i层的妖怪战斗力为 $A_i$。勇士小科计划击败锁妖塔里所有的妖怪，小科的初始战斗力为 $X$ 。小科每次可以在第 $1$ 到 $M$（ $1 \leq M \leq N$ ）层中选择一层 $i$ ，如果 $A_i$ 不大于 $X$ ，那么小科可以击败它，击败第 $i$ 层的妖怪后小科的战斗力会提升 $A_i$。第 $i$ 层的妖怪被击败后，第 $i$ 层将会消失，此时第 $i+1$ 层会变为第 $i$ 层，第 $i+2$ 层会变为第 $i+1$ 层，依此类推。小科想知道他的战斗力至少为多少，才能保证可以击败所有的妖怪。

## 输入格式

第 $1$ 行：两个空格分隔的整数 $N, M$。

第 $2$ 行：$N$ 个空格分隔的整数，第 $i$ 个整数 $A_i$，表示第 $i$ 层的妖怪的战斗力。（ $1 \leq A_i \leq 10^9$ ）。

## 输出格式

一行：一个整数，表示要消灭所有N个妖怪，小科需要的最低的初始战斗力。

## 输入输出样例

### 输入样例1

```plaintext
3 2
1 10 5
```

### 输出样例1

```plaintext
4
```

### 输入样例2

```plaintext
3 1
1 10 5
```

### 输出样例2

```plaintext
9
```

## 题解

题目要求我们求最小的初始战力，分析一下，初始战力越大打怪越容易，所以符合单调性，也就是二分中的 __最小化__ 问题（附上最小值代码）。

```c++
ll binary_solve() {
    ll l = 1, r = n + 1;    //[l,r)
    while(l < r) {
        ll mid = l+r>>1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}
```

现在，我们需要解决的就是`check()`。由于可以从前 $1 \sim m$ 层中选一层先打，所以我们自然选择 $A_i$ 最小的打（可以累计战力，打后面的更容易）。

$Q:$ 如何处理第 $i$ 层被打掉后上方的层数掉落？

$A:$ 我们可以考虑先将前 $m$ 层push进小根堆`priority_queue<ll,vector<ll>,greater<ll>>`，并定义`index`存储当前入队的最后层数上一层的下标，在取出最小值后将第`index`层push进小根堆（因为不用考虑堆内顺序，只需要知道从 $1 \sim m$ 中任意删掉一层，$m-1$ 层都会加入到可选区域），这样就相当于完成了层数的掉落。（如图所示）

$$
m=2
$$

$$
\begin{array}{|c|}
a_4 \\
a_3 \\
\color{red}a_2 \\
\color{green}a_1
\end{array}
\Rightarrow
\begin{array}{|c|}
a_4 \\
\color{green}a_3 \\
\color{green}a_1
\end{array}
$$

```c++
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
const ll N = 2e5 + 1;
ll n, a[N], m;

bool check(ll x) {
    priority_queue<ll, vector<ll>, greater<ll> > sq;
    ll i = 1;
    //先将前m层push进小根堆
    for(; i <= m; i++) sq.push(a[i]);
    //堆内还有没打完的怪
    while(sq.size()) {
        //如果a[i]最小的怪都打不过，就打不下去了
        if(x < sq.top()) return false;
        else {
            //战力增加a[i]
            x += sq.top();
            sq.pop();
            //当还有层可以掉落时，就将新掉落的一层入堆
            if(i <= n) sq.push(a[i++]);
        }
    }
    return true;
}

int main() {
    cin >> n >> m;
    for(ll i = 1; i <= n; i++) cin >> a[i];
    
    ll l = 1, r = 1e9 + 1;
    while(l < r) {
        ll mid = l+r>>1;
        if(check(mid)) r = mid;
        else l = mid + 1;
    }
    cout << l << endl;
    return 0;
}
```
