---
title: 垃圾分类站
date: 2024-12-21 13:13:07
tags:
    - C++
    - 贪心
    - 区间选点
---

## 题目描述

C小镇正在推行垃圾分类回收。由于C小镇有 $N$ 户居民，居民们都把房子建在了Center大街的两边，所以镇长小Z决定在Center大街上建设一些垃圾分类回收站。为了节省成本，小Z希望建设的垃圾分类回收站尽可能的少。但是他也知道，C小镇的居民可以忍受的最大扔垃圾距离为 $L$。如果某个居民的房子到离他最近的垃圾分类回收站的直线距离超过了 $L$，那么他就不会把垃圾送到垃圾分类站。

所以回收站的建设必须要保证所有居民到离他最近的回收站的距离不超过 $L$。我们可以把C小镇看成一个二维平面，Center大街看做 $x$ 轴，Center大街的 __自西向东__，最西边的坐标为 $(0, 0)$，可以认为Center大街往东可以无限延伸。每个房子都有一个二维坐标，给定每个房子的二维坐标，请帮助小科计算，至少要建多少个垃圾分类回收站，才能满足所有居民的需求。

## 输入格式

第 $1$ 行：两个空格分隔的整数 $N$ 和 $L$ $(1 <= N <= 1000，1 <= L <= 10000)$。

接下来 $N$ 行：每行两个空格分隔的整数 $x$ 和 $y$，表示一户居民的房子坐标。$(x >= 0 且 |y| <= L)$

## 输出格式

一行：一个整数，表示最少需要建设的回收站的数量。

## 输入输出样例

### 输入样例1

```plaintext
3 5
2 4
3 3
5 -4
```

### 输出样例1

```plaintext
1
```

## 题解

### 题目分析

~~题目有点误导性，~~ 下面给出一张直观的图片

![示意图](/images/省赛冲刺/2/3-1.png)

其中，$L$ 表示点 $(x,y)$ 的最大接受距离，那么 $\color{blue}{蓝色线段}$ 就是在Center大街上可以建回收站的区域。这样，我们就完成了 __从面到线的映射__。

具体的映射过程：

我们设映射区域的内的点为 $(a,0)$。

显然可以列出不等式：

$$
|a-x| \leq \sqrt{L^2 - y^2}
$$

当 $a \ge x$ 时，有：

$$
a-x \leq \sqrt{L^2 - y^2}
$$

整理得：

$$
\begin{equation}
a \leq \sqrt{L^2 - y^2} + x
\end{equation}
$$

当 $a < x$ 时，有：

$$
x-a \leq \sqrt{L^2 - y^2}
$$

整理得：

$$
\begin{equation}
a \geq x - \sqrt{L^2 - y^2}
\end{equation}
$$

综合 $(1)(2)$ 得：

$x - \sqrt{L^2 - y^2} \leq a \leq \sqrt{L^2 - y^2} + x$

则线段的左端点 $=x - \sqrt{L^2 - y^2}$，右端点 $=\sqrt{L^2 - y^2} + x$

映射成线段之后，就可以通过区间选点来实现了。

```cpp
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 1e4 + 1;

struct Line {
    double l, r;
    bool operator<(Line &rhs) {
        return r < rhs.r;
    }
} a[N];
ll n, l;

int main() {
    cin >> n >> l;
    for(ll i = 1, x, y; i <= n; i++) {
        cin >> x >> y;
        double dis = sqrt(l * l - y * y);
        a[i] = {max((double)x - dis, 0.0), (double)x + dis};
    }
    sort(a + 1, a + n + 1);
    
    ll ans = 1;
    double r = a[1].r;
    for(ll i = 1; i <= n; i++) {
        if(a[i].l > r) {
            ans++;
            r = a[i].r;
        }
    }
    cout << ans << endl;
    return 0;
}
```