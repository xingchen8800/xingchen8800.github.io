---
title: 偷懒的小Z
date: 2024-12-19 22:26:13
tags:
    - C++
    - 贪心
    - 区间选点
---

## 题目描述

小Z养了 $N（1 <= N <= 10000）$ 只鸡。为了方便管理，小Z给它们依次编号为 $1,2,\dots,N$。小Z把它们放养到一条直线场地中。每只鸡都有自己喜欢的觅食范围（多只鸡的觅食范围可能会有重叠），确切的说编号为 $i$ 的鸡会在 $S_i$ 到 $T_i$ 的范围内觅食（包括 $S_i$ 和 $T_i$ ）。小科每天都要为这 $N$ 只鸡喂食，对于任意一只鸡 $i$，小Z只需要在 $S_i$ 到 $T_i$ 范围内的任何一个位置放上饲料，鸡 $i$ 就可以吃到饲料。小Z非常懒，他希望饲料放置的位置越少越好，请帮助小Z计算他最少需要在多少个位置放置饲料。

## 输入格式

第 $1$ 行：一个正整数 $N$，表示鸡的数量。

接下来 $N$ 行，每行两个空格分隔的整数 $S_i$ 和 $T_i$，表示一只鸡的觅食范围 $0 \leq S_i \leq T_i \leq 10^6$。

## 输出格式

一行：一个整数，表示小Z最少需要在多少个位置放置饲料，才能保证每只鸡都能吃到饲料

## 输入输出样例

### 输入样例1

```plaintext
3
1 4
2 3
3 3
```

### 输出样例1

```plaintext
1
```

### 输入样例2

```plaintext
3
4 6
2 3
3 4
```

### 输出样例2

```plaintext
2
```

## 题解

区间选点问题的模板：在多个区间中选择数量最少的点使每个区间内至少有一个点。

对于两段区间，我们一般可以分成三种情况：

![情况1](/images/省赛冲刺/2/image.png)

此时，两个区间不相交，显然必须选两个点。

![情况2](/images/省赛冲刺/2/image-1.png)

此时，显然只需要选一个点。

![情况3](/images/省赛冲刺/2/image-2.png)

此时显然只需要选一个点。

显然，我们选的点要尽量向右靠，才可能被更多的区间包含。并且区间也需要按照右端点从小到大排序。

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 1e4 + 1;

struct Cow {
    ll l, r;
    bool operator<(Cow &rhs) {
        return r < rhs.r;
    }
} a[N];
ll n;

int main() {
    cin >> n;
    for(ll i = 1; i <= n; i++) cin >> a[i].l >> a[i].r;
    sort(a + 1, a + n + 1);
    
    ll ans = 1, r = a[1].r;
    for(ll i = 1; i <= n; i++) {
        if(a[i].l > r) {
            ans++;
            r = a[i].r;
        }
    }
    cout << ans << endl;
    return 0;
}

```