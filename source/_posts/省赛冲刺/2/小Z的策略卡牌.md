---
title: 小Z的策略卡牌
date: 2024-12-19 21:40:01
tags:
    - C++
    - 贪心
    - 博弈论
---

## 题目标签

贪心、博弈论

## 题目描述

小Z开发了一款卡牌游戏，取名叫策略卡牌。游戏由两名选手进行PK，游戏开始时游戏系统会给游戏双方各随机发 $N$ 张卡牌，每张卡牌上都有一个人物和战斗值。接下来双方要进行 $N$ 轮PK。每轮PK双方各选一张卡牌进行PK，战斗值较高的一方获胜，战斗力相同则该轮PK平局。获胜方可以获得 $20$ 点积分，失败方要被扣除 $10$ 点积分。如果双方平局，则各获得 $5$ 点积分。小Z和小J正在玩策略卡牌游戏，给定游戏开始时小Z和小J的每张卡牌的战斗值，请计算小Z最多可以获得多少积分，最少可以获得多少积分。

## 输入格式

第 $1$ 行：一个正整数 $N$，表示小Z和小J每人拿到的卡牌总数量;

第 $2$ 行：$N$ 个空格分隔的整数，表示小Z的 $N$ 张卡牌的战斗值 $a_i$。;

第 $3$ 行：$N$ 个空格分隔的整数，表示小J的 $N$ 张卡牌的战斗值 $b_i$。;

## 输出格式

$1$ 行：两个空格分隔的整数，分别表示小Z可以获得的最高积分和最低积分。

## 输入输出样例

### 输入样例1

```plaintext
3
1 3 5
2 4 6
```

### 输出样例1

```plaintext
30 -30
```

## 提示

### 【样例#1解释】

小Z的卡牌：$1, 3, 5$

小J的卡牌：$2, 4, 6$

__最优策略：__

- 第一轮，小Z出 $1$ 与小J的 $6$ 比，积分 $-10$；
- 第二轮，小Z出 $5$ 与小J的 $4$ 比，积分 $+20$；
- 第三轮，小Z出 $3$ 与小J的 $2$ 比，积分 $+20$。

最终积分：$-10+20+20=30$

__最差策略：__

- 第一轮，小Z出 $1$ 与小J的 $2$ 比，积分 $-10$；
- 第二轮，小Z出 $3$ 与小J的 $4$ 比，积分 $-10$；
- 第三轮，小Z出 $5$ 与小J的 $6$ 比，积分 $-10$。

最终积分：$-10-10-10=-30$

### 【数据范围】

$1 \leq N, a_i, b_i \leq 10^5$

## 题解

本题主要考察 __田忌赛马__ + 贪心。

贪心策略：求小Z可以获得的最高积分，就要使 __小Z__ 的每张卡牌发挥 __最大价值__；求小Z可以获得的最低积分，就要使 __小J__ 的每张卡牌发挥 __最大价值__ 。

我们回顾一下田忌赛马的策略：

> 第一局，田忌派出了自己的下等马，对阵齐威王的上等马。结果可想而知，田忌输掉了第一局。齐威王十分得意。第二局，田忌派出了自己的上等马对阵齐威王的中等马。结果，田忌赢了第二局。第三局，田忌派出自己的中等马对阵齐威王的下等马，田忌又赢了第三局。

策略总结成一句话：先用差的消耗好的，在用好的比掉差的。

假设对于两个人 $a,b$，我们求 $a$ 的最优策略。

1. 我们先对 $a,b$ 进行排序。
2. 如果 $\max\{a\} > \max\{b\}$，直接赢一场，并删去两个最大的，这样发挥了这张牌的最大价值（能赢就赢，反正删去最大价值后剩下的不会比当前的最大价值大）；
3. 再如果 $\min\{a\} > \min\{b\}$，直接赢一场，并删去两个最小的，发挥这张牌的最大价值（最小的能赢，更大的显然能赢，但是浪费）；否则输了，则这张牌被认为是 __没有价值__ 的，应当消耗掉 $b$ 中的最大值，输一场，并删去这两张牌；
4. 若上述条件均不成立，则平局；
5. 若 $a$ 和 $b$ 均有牌，继续从 $2$ 开始。

实现：

```c++
ll GetBestScore(ll *a, ll *b) {
    //al,bl分别指向a,b中的最小值，ar, br同理
    ll al, ar, bl, br, ret = 0;
    al = bl = 1, ar = br = n;
    while(al <= ar) {
        if(a[ar] > b[br]) { //最大的能赢
            ret += 20;
            ar--, br--;
        } else if(a[al] > b[bl]) { //最小的能赢
            ret += 20;
            al++, bl++;
        } else if(a[al] == b[br]) { //最小的能平局
            ret += 5;
            al++, br--;
        } else {                    //最小的消耗
            ret -= 10;
            al++, br--;
        }
    }
    return ret;
}
```

值得注意的是：每场无论是平局（$5+5$），还是输（$-10+20$）、赢（$+20-10$），最终产生的分数总和都为 $10$，所以 $n$ 场产生 $10n$ 积分。

最终代码：

```c++
#include <bits/stdc++.h>
using namespace std;
typedef long long ll;
const ll N = 1e5 + 1;

ll n, a[N], b[N];
ll GetBestScore(ll *a, ll *b) {
    //al,bl分别指向a,b中的最小值，ar, br同理
    ll al, ar, bl, br, ret = 0;
    al = bl = 1, ar = br = n;
    while(al <= ar) {
        if(a[ar] > b[br]) { //最大的能赢
            ret += 20;
            ar--, br--;
        } else if(a[al] > b[bl]) { //最小的能赢
            ret += 20;
            al++, bl++;
        } else if(a[al] == b[br]) { //最小的能平局
            ret += 5;
            al++, br--;
        } else {                    //最小的消耗
            ret -= 10;
            al++, br--;
        }
    }
    return ret;
}

int main() {
    cin >> n;
    for(ll i = 1; i <= n; i++) cin >> a[i];
    for(ll i = 1; i <= n; i++) cin >> b[i];
    sort(a + 1, a + n + 1);
    sort(b + 1, b + n + 1);
    cout << GetBestScore(a, b) << " " << 10 * n - GetBestScore(b, a) << endl;
    return 0;
}
```
