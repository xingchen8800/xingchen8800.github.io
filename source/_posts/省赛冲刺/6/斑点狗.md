---
title: 时尚斑点狗
date: 2025-01-18 20:50:13
tags:
    - C++
    - 搜索
    - 路径
---

### 题目描述

小X的同学们最近非常流行养有两个斑点的斑点狗，小X也非常想养一只。小X的妈妈答应他只要他这学期的文化课和编程课考试都在班级前5就带他也去买一只。在小X的不断努力下他终于达到了目标，小X的妈妈也兑现了承诺带他去买一只有两个斑点的斑点狗。但是小X在有了斑点狗之后和同学们聊天的时候发现，现在开始流行只有一个斑点的斑点狗了，这让小X有些苦恼，他决定让他的小斑点狗也变成只有一个斑点的斑点狗，这样他的狗狗就是最时尚的狗狗了。小X通过画画让小斑点狗的两个斑点连在一起成为一个斑点，小斑点狗的皮肤由一个 $n \times m \ (1 \leq n, m \leq 50)$ 的字符格子表示：

```plaintext
................
..XXXX....XXX...
...XXXX....XX...
.XXXX......XXX..
........XXXXX...
.........XXX....
```

这里，每一个’X’表示一个斑点的一部分。垂直或水平相邻（对角线相邻不在内）的两个’X’属于同一个斑点，所以上图正好有两个斑点。所有小X的斑点狗只有两个斑点。小X的零花钱有限，所以希望使用尽可能少的颜料合并两个斑点为一个。在上面的例子中，他只要画三个附加的字符就可以做到这一点。附加字符“X”（新的字符如下图中的`*`那样表示，很容易看到）。

```plaintext
................
..XXXX....XXX...
...XXXX**..XX...
.XXXX...*..XXX..
........XXXXX...
.........XXX....
```

请帮助小X确定要让两个斑点合并为一个，最少需要画多少个点。

### 输入格式

输入的第一行，用空格隔开的两个整数 $N$ 和 $M$。接下来 $N$ 行，每行 $M$ 个字符，字符是 "X" 或者 "."，表示斑点狗的皮肤的图形。

### 输出格式

输出一行，一个整数，表示把两个斑点合并成一个斑点，需要添加的 “X” 的最小数量。

### 输入输出样例

#### 输入样例 1

```plaintext
6 16
................
..XXXX....XXX...
...XXXX....XX...
.XXXX......XXX..
........XXXXX...
.........XXX....
```

#### 输出样例 2

```plaintext
3
```

### 题解

遇到这种题，我们首先尝试进行“染色”：

```plaintext
................
..1111....222...
...1111....22...
.1111......222..
........22222...
.........222....
```

然后遍历每个“色块”中的点，一一找曼哈顿距离，求最短路。（或者也可使用 $BFS$ 扩散，看看第几步的时候碰到了另一个“色块”）

```c++
#include <bits/stdc++.h>
using namespace std;
#define ll long long

const ll N = 60, M = 60;
ll n, m, code = 0;
bool b[N][M], vis[N][M];
struct Point {ll x, y;}; 
vector<Point> bd[2];
//获取曼哈顿距离
ll GetDis(ll x, ll y, ll xx, ll yy) {
    return llabs(x - xx) + llabs(y - yy);
}

const ll DX[] = {0, 0, 1, -1}, DY[] = {1, -1, 0, 0};
void bfs(ll x, ll y, ll cd) {
    queue<pair<ll, ll> > q;
    q.push({x, y});
    bd[cd].push_back({x,y});
    vis[x][y] = true;
    while(q.size()) {
        auto u = q.front(); q.pop();
        ll x = u.first, y = u.second;
        for(ll i = 0; i < 4; i++) {
            ll xx = x + DX[i]; 
            ll yy = y + DY[i];
            if(xx >= 1 && xx <= n && yy >= 1 && yy <= m) 
            if(!vis[xx][yy] && b[xx][yy]) {
                vis[xx][yy] = true;
                q.push({xx, yy});
                bd[cd].push_back({xx,yy});
            }
        }
    }
}

int main() {
    cin >> n >> m;
    for(ll i = 1; i <= n; i++) {
        for(ll j = 1; j <= m; j++) {
            char c;
            cin >> c;
            b[i][j] = (c == 'X');
        }
    }
    for(ll i = 1; i <= n; i++) {
        for(ll j = 1; j <= m; j++) {
            if(b[i][j] && !vis[i][j]) bfs(i,j,code++);
        }
    }
    ll ans = LLONG_MAX;
    for(auto i : bd[0]) {
        for(auto j :bd[1]) {
            ll dis = GetDis(i.x, i.y, j.x, j.y);
            ans = min(ans, dis);
        }
    }
    cout << ans - 1 << endl;
    return 0;
}
```
