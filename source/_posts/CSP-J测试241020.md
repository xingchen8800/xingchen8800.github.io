---
title: CSP-J测试（2024）
date: 2024-10-20 13:43:49
tags:
---

# 一、字符串删除(delete)

## 题目描述

小A最近学了字符串的知识，正想大显身手。他找到了一道题，题目是这么描述的：

给定一个字符串 $s$ ，现在要求你讲字符串 $s$ 中的所有`code`子串删除，输出删除之后的 $s$ 。

注：因删除子串而产生的 `code` 子串无需处理。

## 输入格式
输入文件名：`delete.in`

一行不包含空格的字符串 $s$。

## 输出格式
输出文件名：`delete.out`

删除之后的 $s$。

## 输入输出样例

### 输入样例1：

```
hahagcocodedemcode
```

### 样例输出1：

```
hahagcodem
```

### 输入样例2：
```
cococodedede
```

### 样例输出2：
```
cocodede
```

## 说明
### 【数据范围】

- 对于 $100\%$ 的数据：输入字符串长度不超过 $100$。

## 题解
{% folding yellow::答案 %}
做法一、遍历
```c++
for(int i = 0; i + 3 < s.size(); i++) {
    if(s.substr(i, 4) == "code") s.erase(s.begin() + i, 4);
}
```

做法二、`find`函数
```c++
int i = 0;
while(i != s.size()) {
    i = s.find("code", i);
    if(i != string::npos) {
        s.erase(i, 4);
    } else break;
}
```
{% endfolding %}

# 二、记事本(note)

### 题目描述

XX村的村长小X有一本记事本，上面大大小小记录了一大堆东西。这天小X闲来无事翻看他的记事本，他突然觉得根本看不懂，因为这上面的东西写的太乱了！于是小X决定痛改前非，以后每记录一个事宜就给这个事宜加上一个标题，对于要记录的事宜小X总共归纳了三种标题来方便他后面进行查看：

- section：创建新的一级标题，序号从 $1$ 开始标记
- subsection：创建新的二级标题，序号在每个一级标题的基础上从 $1$ 开始标记
- subsubsection：创建新的三级标题，序号在每个二级标题的基础上从 $1$ 开始标记

现在给出小X记录的 $n$ 个标题及事件，请你根据小X的标题输出每个事件的标号及其名称。

### 输入格式
输入文件名：`note.in`。

第一行，一个整数 $n$ ，表示 $n$ 个标题及事件。

接下来n行，每行两个字符串，第一个为标题种类（`section`、`subsection`、`subsubsection`），第二个为事件名称，其中事件名称为不超过20个的小写字母组成。

### 输出格式
输出文件名：`note.out`。

共 $n$ 行，表示所有标题序号及其事件。

## 输入输出样例

### 输入样例 #1：

```
3
section eat
section drank
section sleep
```

### 输出样例 #1：

```
1 eat
2 drank
3 sleep
```

### 输入样例 #2：
```
4
section eat
subsection fish
subsection meat
subsubsection chicken
```

### 输出样例 #2：
```
1 eat
1.1 fish
1.2 meat
1.2.1 chicken
```

## 说明

数据范围：

- 对于 $100\%$ 的数据，保证 $1 \leq n \leq 100$。

# 三、时间(time)

## 题目描述
众所周知，我们采用 $24$ 小时制记录时刻，最早时刻为 $00:00$ ，最晚时刻为$23:59$ 。pupu家的时钟正是采用 $24$ 小时制。

一日睡醒后，pupu还有点迷糊，恍惚中看了一眼时间，只看到四个数字。请问给定pupu看到的四个数字，能够组成的最晚合法时刻是多少，按照`HH:MM`的格式进行输出！若无法构成合法时刻，则输出`Muddle`。

## 输入格式
输入文件名：`time.in`

输入只有一行：为四个空格隔开的一位数。表示pupu看到的四个数字。

## 输出格式
输出文件名：`time.out`

输出只有一行：如果能够组成合法时刻，输出组成的最晚合法时刻。按照`HH:MM`的格式输出。如果不能组成合法时刻，则输出`Muddle`。

## 输入输出样例

### 输入样例 #1：

```
1 2 3 4
```

### 输出样例 #1：

```
23:41
```

### 输入样例 #2：
```
6 6 6 6
```

### 输出样例 #2：
```
Muddle
```

## 说明
### 数据范围：

- 对于 $30\%$的数据范围：输入的四个数字相同。
- 对于 $100\%$ 的数据范围：无其他规则限制，保证输入的每个数字都是一位数。

# 四、围棋(go)

## 题目描述
又输了！已经不知道这是小A第几次败给小B了，果然围棋不是他的强项。

在收拾棋盘时，他发现自己的n个棋子散乱地放置在棋盘网格的点上，每个位置由坐标 $(x,y)$ 表示。小A想到了一个新的玩法，每次可以将一个棋子沿棋盘网格向上、下、左、右移动一步，但在任一时刻每个位置上只能有一个棋子。

现在希望通过移动棋子，使得所有棋子彼此相邻的处于同一条水平线内，即所有棋子的 $y$ 坐标相同并且 $x$ 坐标相邻。

请你计算满足要求的情况下，所有棋子的总移动次数最少是多少。

## 输入格式
输入文件名：`go.in`

第一行输入整数 $N$，代表棋子的数量。

接下来的 $N$ 行，每行输入两个整数 $x$ 和 $y$，分别代表一个棋子当前所在坐标位置 $(x,y)$。

## 输出格式
输出文件名：`go.out`

输出一个整数，代表所有棋子的总移动次数的最小值。

## 输入输出样例

### 输入样例 #1：
```
5
1 2
2 2
1 3
3 -2
3 3
```

### 输出样例 #1：
```
8
```

## 说明
### 【数据范围】

- 对于 $30\%$ 的数据，保证 $1≤n≤100，−100≤x,y≤100$。
- 对于 $50\%$ 的数据，保证 $1≤n≤1000，−1000≤x,y≤1000$。
- 对于 $100\%$ 的数据，保证 $1≤n≤10000，−10000≤x,y≤10000$。

## 题解

{% folding green::答案 %}
![样例#1如图所示](/images/cspjtest241020-1.png)

本题运用 __中位数__ 思想。

![图2](/images/cspjtest241020-2.png)

如 图2 所示，$y$ 轴分成 $3$ 个“梯队”，选哪个“梯队”作为水平线所在的 $y$ 轴呢？显然是选 $AB$ 所在的直线，因为 $AB$ 在三个“梯队”的中间，点 $A$ 和 点 $B$ 到 $AB$ 的距离为 $0$，点 $C$ 和 点 $E$ 到 $AB$ 的距离为 $1$, 点 $D$ 到 $AB$ 的距离为 $4$，共计移动 $6$ 次。

那么，选直线 $y=2$ 上的哪个区间作为水平线呢？

![图3](/images/cspjtest241020-3.png)


设 $k$ 为 $y=2$ 上的一点且为水平线的起点，那么对于点$i$，显然自己应该移动到 $k+i-1$ 上，移动距离为：

$|x_i-(k+i-1)-1|=|x_i-k-i|$

所有点的移动距离之和为：

$|x_1-k-1|+|x_2-k-2|+|x_3-k-3|+\ldots+|x_n-k-n|$

将 $-1,-2,-3,\ldots,-n$ 移到 $-k$ 前，得到：

$|(x_1-1)-k|+|(x_2-2)-k|+|(x_3-3)-k|+\ldots+|(x_n-n)-k|$

可以发现，当上式的值 __最小__ 时，$k$ 为 $(x_1-1) \sim (x_n-n)$的 __中位数__。


__总结一下，水平线的 $y$ 轴为 $y_1 \sim y_n$ 的中位数，$x$ 轴起点为 $(x_1-1) \sim (x_n-n)$ 的中位数。__

```c++
#include <bits/stdc++.h>
using namespace std;
int x[10001], y[10001];
int main() {
    freopen("go.in", "r", stdin);
    freopen("go.out", "w", stdout);

    int n;
    cin >> n;
    for(int i = 1; i <= n; i++) {
        cin >> x[i] >> y[i];
    }
    sort(x + 1, x + n + 1);     //x轴坐标排序（为了将x[1]~x[n]变为(x[1]-1)~(x[n]-n)）
    sort(y + 1, y + n + 1);     //y轴坐标排序（为了求中位数）

    for(int i = 1; i <= n; i++) {
        x[i] -= i;              //将x[1]~x[n]变为(x[1]-1)~(x[n]-n)
    }
    sort(x + 1, x + n + 1);     //将变化后的x轴坐标排序（为了求中位数）
    int mx = x[(n + 1) / 2];    //x轴起点
    int my = y[(n + 1) / 2];    //y轴中位数
    int ans = 0;
    for(int i = 1; i <= n; i++) {
        ans += abs(x[i] - mx) + abs(y[i] - my); //统计步数
    }

    cout << ans;
    return 0;
}
```

{% endfolding %}

# 五、加密(code)

## 题目描述

小A得到了一份机密文件，他要负责这个文件的加密。这份文件里的数据是这样的：数据有多行，每行都是一个字符串。每行的字符串中，每两个字符放在一起表示一个两位 $16$ 进制整数（每个整数的范围在 $0 \sim 255$ 之间，其中 $16$ 进制位的 $10 \sim 15$ 用大写字母 $A \sim F$来表示）。

现在小A的加密方式为：先统计每个整数的出现次数，然后取出出现次数最多的前 $16$ 个整数（出现次数相同按数值升序排序），将这 $16$ 个整数按顺序重新编号为 $16$ 进制的 $0 \sim F$，于是就得到了一串密钥。接下来，将原本的数据中的每个整数，根据密钥加密成对应的 $0 \sim F$ 内的编号，加密的规则为：把这个整数和密钥里 $16$个原本的整数值相减，选取绝对值最小的结果对应的编号作为加密后的编号，如果绝对值相同则选取较小的编号。

## 输入格式
输入文件：`code.in`

第一行输入一个正整数 $n$，表示有 $n$ 行数据。

接下来 $n$ 行，每行输入一个字符串。每行字符串长度相等，且每两个字符放在一起表示一个两位 $16$进制整数。

## 输出格式
输出文件：`code.out`

第一行输出一个字符串，按照顺序依次表示选定的密钥中的 $16$ 个整数的 $16$ 进制编码，每两个字符放在一起表示一个两位 $16$ 进制整数，其中 $16$ 进制位的 $10 \sim 15$用大写字母 $A \sim F$ 来表示。

接下来 $n$ 行，每行为加密后的数据，每个字符表示加密后的 $16$ 进制编号，用 $0 \sim F$ 表示。

## 输入输出样例

### 输入样例 #1：
```
10
00FFCFAB00FFAC09071B5CCFAB76
00AFCBAB11FFAB09981D34CFAF56
01BFCEAB00FFAC0907F25FCFBA65
10FBCBAB11FFAB09981DF4CFCA67
00FFCBFB00FFAC0907A25CCFFC76
00FFCBAB1CFFCB09FC1AC4CFCF67
01FCCBAB00FFAC0F071A54CFBA65
10EFCBAB11FFAB09981B34CFCF67
01FFCBAB00FFAC0F071054CFAC76
1000CBAB11FFAB0A981B84CFCF66
```

### 输出样例 #1：
```
ABCFFF00CB09AC07101198011B6776FC
321032657CD10E
36409205ACC16D
B41032657FD16D
8F409205ACF14D
324F326570D1FE
3240C245FC411D
BF4032687CD16D
8F409205ACC11D
B240326878D16E
83409205ACE11D
```

## 说明
### 样例说明：

整数 $AB$、$CF$ 和 $FF$ 出现 $14$ 次，$00$ 出现 $10$ 次， $CB$ 出现$9$次， $09$ 出现 $7$ 次， $AC$ 出现 $6$ 次， $07$ 出现 $5$ 次， $10$ 、 $11$ 和 $98$ 出现 $4$ 次，$01$ 、 $1B$ 、 $67$ 、 $76$ 和 $FC$ 出现 $3$ 次。

### 数规模与约定：

- 对于 $100\%$ 的数据：$10 \leq n \leq 20$，保证至少有 $16$种不同的整数，且每行最多 $20$ 个整数。