---
title: 拓扑排序(Topological Sorting)
date: 2024-08-21 22:42:03
categories:
    - [数据结构,图]
    - [《算法竞赛》,第十章]
    - [CSP,CSP-S,非课程]
excerpt: 现实生活中，我们经常要做一连串的事情，这些事情有依赖关系或顺序关系，即做一件事之前要先做另一件事。如：穿衣服的先后、课程学习的顺序。这些事情在图中抽象为拓扑排序(Topological Sorting)问题
tags: 
    - C++
    - CSP提高组
---

# 引入
{% notel default fa-arrow-up-right-from-square 通俗讲法%}
现实生活中，我们经常要做一连串的事情，这些事情有依赖关系或顺序关系，即做一件事之前要先做另一件事。如：穿衣服的先后、课程学习的顺序。这些事情在图中抽象为 __拓扑排序(Topological Sorting)__ 问题。
{% endnotel %}

# 概念

## 举例
设有$a、b、c、d$等事情，其中 $a$的优先级最高，$b$和$c$的优先级相同，$d$的优先级最低，表示为 $a \rightarrow (b,c) \rightarrow d$。那么，*abcd*和*acbd*都是可行的排序。

## 定义
把 *事情* 看作图中的 __点__ ，把 *先后关系* 看作是 __有向边__，问题边转化为 __在图中求一个有先后关系的排序__，即拓扑排序。

## 性质
![](https://cdn.luogu.com.cn/upload/image_hosting/nwjthb06.png)

1. 在拓扑排序中，图必须是 __有向无环图(DAG)__；有向无环图必然能拓扑排序。

2. 当图中有环时，拓扑排序可以找到环；当图是无向图时，可以将其看作有向图来拓扑排序。

3. 一个图的拓扑排序可以有多个。

4. 当没有$\mathbf{e}(u,v)$时，在这个图的拓扑排序中$u,v$的位置可以调换。

5. 拓扑排序是简单的图遍历，可以用BFS和DFS实现

## 需要掌握的知识
- 入度(Indegree)：以$v$为 __终点__ 的边的数量，称为$v$的 __入度__。
- 出度(Outdegree)：以$u$为 __起点__ 的边的数量，称为$u$的 __出度__。

一个点的入度和出度，体现了这个点与其他点的先后关系：
- 一个点入度为$0$，说明它是最 __优先__ 的。
- 一个点出度为$0$，说明它是优先级最 __低__ 的。

## 实现

### 广度优先搜索(__B__ readth-__F__ irst __S__ earch)
有两种思路：无前驱的顶点优先(A)、无后继的节点优先(B)

#### 思路(A)
1. 先找入度为$0$的点让它（们）入队。如果找不到，则说明这个图有环，不存在拓扑排序
2. 弹出队首($a$)，让($a$)的所有邻居节点入度减1，入度减为0的邻居节点入队。
3. 重复1、2，直到队列为空

无解判断：若队列已经空了，但是还有入度不为0的节点未入队，没有入队的点就是环上的点。

```c++
int indegree[N];
vector<int> ans;

void AddEdge(int from, int to, int weight) { //修改AddEdge()，统计indegree[]
    edges[cnt] = (Edge_t) {from, to, head[from], weight};
    head[from] = cnt++;
    indegree[to]++;
}

void TopologicSorting() {
    queue<int> Q;
    for(int i = 1; i <= n; i++) {
        if(!indegree[i]) Q.push(i);
    }
    while(!Q.empty()) {
        int from = Q.front();   //1
        ans.push_back(from);
        Q.pop();    
        for(int i = head[from]; i != -1; i = edges[i].next) { //2
            indegree[edges[i].to]--;
            if(!indegree[edges[i].to]) Q.push(edges[i].to);
        } 
        //3
    }
    if(ans.size() == n) {
        for(int i : ans) cout << i << " ";
        cout << endl;
    } else cout << "No topologic sortings.\n";
}
```