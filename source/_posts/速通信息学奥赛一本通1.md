---
title: 速通信息学奥赛一本通（一）
date: 2024-10-12 22:15:26
tags: 
    - CSP入门组
    - C++
excerpt: 高精度算法
---

# 高精度算法

## 加法

对于正整数 $a,b$，求 $a + b$

```c++
//倒序存储略（下标从1开始）
//lena为a的长度，lenb为b的长度
int len = 1;
while(len <= lena || len <= lenb) {
    sum[len] = a[len] + b[len];         //模拟竖式加法
    sum[len+1]+=sum[len]/10;            //进位
    sum[len++]%=10;
}
while(len > 1 && sum[len] == 0) len--;  //去除前导零

```

## 减法

对于正整数 $a,b$，求 $a - b$

### 当被减数大于等于减数时：

```c++
//倒序存储略（下标从1开始）
//lena为a的长度，lenb为b的长度
int len = 1;
while((len <= lena) || (len <= lenb)) {
    if(a[len] < b[len]) {           //模拟借位
        a[len] += 10;
        a[len + 1]--;
    }
    ans[len] = a[len] - b[len];     //模拟竖式相减
    len++;
}
while(len > 1 && ans[len] == 0) len--;  //去除前导零

```

### 当被减数小于减数时：

在做高精度之前交换 $a$ 和 $b$，建立标记变量标记为负数即可。

## 乘法

对于正整数 $a,b$，求：$a \cdot b$

```c++
//倒序存储略（下标从1开始）
//lena为a的长度，lenb为b的长度
int len = 0;
for(int i = 1; i <= lena; i++) {            //枚举a[i]
    int x = 0;
    for(int j = 1; j <= lenb; j++) {        //枚举b[j]
        ans[i + j - 1] += a[i] * b[j] + x;  //模拟竖式乘法
        x = ans[i + j - 1] / 10;            //进位
        ans[i + j - 1] %= 10;
    }
    ans[i + lenb] = x;
}
len = lena + lenb;
while(len > 1 && ans[len] == 0) len--;  //去除前导零
```

## 除法

对于正整数 $a,b (b \leq 2^{31} - 1)$，求：$a \div b$

```c++
//正序存储略（下标从1开始）
int x = 0;  //余数
for(int i = 1; i <= lena; i++) {
    ans[i] = (x * 10 + a[i]) / b;
    x = (x * 10 + a[i]) % b;
}
int len = 1;
while((ans[len] == 0) && len < lena) len++;
```
