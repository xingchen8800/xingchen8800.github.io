---
title: 速通信息学奥赛一本通（二）
date: 2024-10-18 22:04:50
excerpt: 包含排序和递归
categories:
    - [信息学奥赛一本通, 基础算法]
tags: CSP入门组
---

# 排序

## 选择排序

{% note blue fa-lightbulb %}
__思路：__ 每次从待排序数组中选出一个 __最小的__ 数放到最前面。
{% endnote %}

```c++
for(int i = 1; i <= n; i++) {
    int mini = i;
    for(int j = i + 1; j <= n; j++) {
        if(a[j] < a[mini]) mini = j;    //找最小的
    }
    if(mini != i) swap(a[i], a[mini]);
}
```

## 冒泡排序

{% note green fa-lightbulb %}
__思路：__ 每次扫描一遍待排序数组，交换 __逆序对__，然后缩小范围
{% endnote %}

```c++
for(int i = n; i > 1; i--) {   //范围[1,i]，逐渐缩小范围
    bool isSwap = false;
    for(int j = 1; j < i; j++) { 
        if(a[j] > a[j + 1]) {   //逆序对
            swap(a[j], a[j + 1]);
            isSwap = true;
        }
    }
    if(!isSwap) break;  //无需交换
}
```

## 插入排序

{% note blue fa-lightbulb %}
__思路：__ 每次读入时将数插入到有序数组中的正确位置。
{% endnote %}

```c++
for(int i = 1; i <= n; i++) {
    int j = i - 1;
    for(; j >= 1; j--) {
        if(a[j] <= a[i]) break; //找到合适位置（a[j] <= a[i] < a[j + 1]）
    }
    if(j != i - 1) {
        int tmp = a[i];
        for(int k = i - 1; k > j; k--) {    //[j, i-1]区间右移
            a[k + 1] = a[k];
        }
        a[i] = tmp;         //“插入”a[i]
    }
}
```

## 桶排序

{% note blue fa-lightbulb %}
__思路：__ 当数据范围在 $10^6$ 以内时，可以建立一个桶数组 $b$，$b_i$ 代表 $i$ 出现的次数。
{% endnote %}

```c++
int b[100001] = {0};
//...
for(int i = 1; i <= n; i++) {   //遍历a数组
    b[a[i]]++;                  //放入桶
}
for(int i = 0; i <= 100001; i++) {  //遍历桶
    for(int j = 1; j <= b[i]; j++) {//桶中有数就输出
        cout << i << " ";
    }
}
cout << endl;
```

## 快速排序

{% note blue fa-lightbulb %}
__思路：__ 改进冒泡排序，通过一趟排序将待排序序列分成两部分；其中，左侧序列的关键字均小于右侧序列的关键字；递归对左右两个序列进行排序。
{% endnote %}

快速排序在1:52。

<div style="position: relative; padding: 30% 45%;">

<iframe style="position: absolute; width: 100%; height: 100%; left: 0; top: 0;" src="https://player.bilibili.com/player.html?isOutside=true&aid=1706254336&bvid=BV1rT421k7Hc&cid=1628933574&p=1&as_wide=1&high_quality=1&danmaku=0" frameborder="no" scrolling="no">

</iframe>
</div>

```c++
void QuickSort(int l, int r) {  //对[l,r]进行排序
    int i, j, mid;
    i = l, j = r;               //初始区间[l,r]
    mid = a[l + ((r-l) >> 1)];    //关键字mid，作为分割左右两序列的标准
    
    do {                        //将<=mid的数都放到左边，>mid的数都放到右边
        while(a[i] < mid) i++;  //左侧[l,i]序列的数都不大于mid
        while(a[j] > mid) j--;  //右侧[j,r]序列的数都不小于mid
        if(i <= j) {            //a[i]为a中第一个大于等于mid的数，a[j]为a中最后一个小于等于mid的数          
            swap(a[i], a[j]);   //找到<=mid的数不在左边或>mid的数不在右边，就交换
            i++, j--;           //跳过
        }
    } while(i <= j)

    if(l < j) QuickSort(l ,j);  //递归搜索左右区间
    if(i < r) QuickSort(i, r);
}
```

## 归并排序

{% note blue fa-lightbulb %}
__思路：__ 每次将序列划分成两个部分；直到只剩下一个元素时，开始两两合并小序列；合并时，保证合并后的序列有序。
{% endnote %}

```c++
//int ans = 0;  //逆序对数量
void msort(int l, int r) {
    if(l == r) return;  //只剩一个数字
    int mid = l + ((r-l) >> 1);
    msort(l, mid); msort(mid + 1, r);   //对左、右区间分别排序

    int i = l, j = mid + 1, k = l;

    while(i <= mid && j <= r) { //左、右区间均有剩余的数
        if(a[i] <= a[j]) {          //左边的数小
            t[k] = a[i]; i++, k++;  //插入左边的数    
        } else {                    //逆序对
            t[k] = a[j]; j++, k++;  //插入右边的数
            //ans += mid - i + 1;   //[i,mid]的序列中的为逆序对中的一个数
        }
    }
    while(i <= mid) { t[k++] = a[i++]; }    //复制剩余序列
    while(j <= r) { t[k++] = a[j++]; }        //复制剩余序列

    memcpy(a + l, t, k);                    //将t数组复制给a
}
```

# 递推

## [1944. 吃糖果](http://noi.openjudge.cn/ch0206/1944/)

### 描述
名名的妈妈从外地出差回来，带了一盒好吃又精美的巧克力给名名（盒内共有 $N$ 块巧克力，$20 > N > 0$）。妈妈告诉名名每天可以吃一块或者两块巧克力。假设名名每天都吃巧克力，问名名共有多少种不同的吃完巧克力的方案。例如：如果 $N=1$，则名名第1天就吃掉它，共有1种方案；如果 $N=2$，则名名可以第 $1$ 天吃 $1$ 块，第 $2$ 天吃 $1$ 块，也可以第 $1$ 天吃 $2$ 块，共有 $2$ 种方案；如果 $N=3$ ，则名名第 $1$ 天可以吃 $1$ 块，剩 $2$ 块，也可以第 $1$ 天吃 $2$ 块剩 $1$ 块，所以名名共有 $2+1=3$ 种方案；如果 $N=4$ ，则名名可以第 $1$ 天吃 $1$ 块，剩 $3$ 块，也可以第 $1$ 天吃 $2$ 块，剩 $2$ 块，共有 $3+2=5$ 种方案。现在给定 $N$，请你写程序求出名名吃巧克力的方案数目。

### 输入

输入只有1行，即整数 $N$。

### 输出

输出只有1行，即名名吃巧克力的方案数。

### 样例输入
```
4
```

### 样例输出
```
5
```

### 题解

设`f[i]`为吃 $i$ 个糖果的方案数，可以发现：若第一天吃了 $1$ 个，剩下 $i - 1$ 个；若第一天吃了 $2$ 个，剩下 $i - 2$ 个。综合上述推理，得：`f[i] = f[i - 1] + f[i - 2]`。

```c++
int solve(int i) {
    if(i <= 1) return 1;
    if(i == 2) return 2;
    return solve(i - 1) + solve(i - 2);
}
```

`solve(N)`即为答案。

## [2718. 移动路线](http://noi.openjudge.cn/ch0206/2718/)

### 【题目描述】
X桌子上有一个 $m$ 行 $n$ 列的方格矩阵，将每个方格用坐标表示，行坐标从下到上依次递增，列坐标从左至右依次递增，左下角方格的坐标为 $(1,1)$ ，则右上角方格的坐标为 $(m,n)$ 。

小明是个调皮的孩子，一天他捉来一只蚂蚁，不小心把蚂蚁的右脚弄伤了，于是蚂蚁只能向上或向右移动。小明把这只蚂蚁放在左下角的方格中，蚂蚁从左下角的方格中移动到右上角的方格中，每步移动一个方格。蚂蚁始终在方格矩阵内移动，请计算出不同的移动路线的数目。

对于1行1列的方格矩阵，蚂蚁原地移动，移动路线数为 $1$ ；对于 $1$ 行 $2$ 列（或 $2$ 行 $1$ 列）的方格矩阵，蚂蚁只需一次向右（或向上）移动，移动路线数也为 $1 \ldots$ 对于一个 $2$ 行 $3$ 列的方格矩阵，如下图所示：

```
(2,1)	(2,2)	(2,3)
(1,1)	(1,2)	(1,3)
```

蚂蚁共有 $3$ 种移动路线：

```
路线1：(1,1) → (1,2) → (1,3) → (2,3)
路线2：(1,1) → (1,2) → (2,2) → (2,3)
路线3：(1,1) → (2,1) → (2,2) → (2,3)
```

### 【输入】
输入只有一行，包括两个整数 $m$ 和 $n$（ $0 < m+n \leq 20$ ），代表方格矩阵的行数和列数，$m、n$之间用空格隔开。

### 【输出】
输出只有一行，为不同的移动路线的数目。

### 【输入样例】
```
2 3
```

### 【输出样例】
```
3
```

### 【题解】


1. 状态设计：设`dp[i][j]`是从 $(1,1)$ 到 $(i,j)$ 的方案数，自然地，`dp[m][n]`即为答案。
2. 状态转移：由于蚂蚁能向上或向右走，则可以从 $(i,j-1)$ 和 $(i-1,j)$ 走过来，共有`dp[i][j-1]+dp[i-1][j]`种方案
3. 边界条件：$(1,1) \rightarrow (1,1)$ 只有一种方案， $(1,1) \rightarrow (i,1)$ 只能沿第一列走，$(1,1) \rightarrow (1,j)$ 只能沿着第一行走，故 `dp[1][1]=0,dp[i][1]=1,dp[1][j]=1`

```c++
#include <iostream>
using namespace std;

int n, m;
int dp[21][21];

int main() {
    cin >> m >> n;
    for(int i = 1; i <= m; i++) {
        for(int j = 1; j <= n; j++) {
            if(i == 1 || j == 1) dp[i][j] = 1;
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
        }
    }
    cout << dp[m][n] << endl;
    return 0;
}
```

## [4982. 踩方格](http://noi.openjudge.cn/ch0206/4982/)

### 描述

有一个方格矩阵，矩阵边界在无穷远处。我们做如下假设：

1. 每走一步时，只能从当前方格移动一格，走到某个相邻的方格上；
2. 走过的格子立即塌陷无法再走第二次；
3. 只能向北、东、西三个方向走。

请问：如果允许在方格矩阵上走 $n$ 步，共有多少种不同的方案。 $2$ 种走法只要有一步不一样，即被认为是不同的方案。

### 输入
允许在方格上行走的步数 $n(n \leq 20)$

### 输出
计算出的方案数量

### 样例输入
```
2
```

### 样例输出
```
7
```

### 题解

![示例图](/images/速通信息学奥赛1-1.png)

设走 $i$ 步，最后一步向左走的走法有 $l_i$ 种，向上走有 $u_i$ 种，向右走有 $r_i$ 种，则共有 $f_i = l_i + r_i + u_i$ 种走法。

- 先看 $l_i$ 如何递推：不难发现，只有最后一步是向左或向上时才能继续向左走，即：$l_i = l_{i-1} + u_{i-1}$；
- 再看 $r_i$ ：只有最后一步是向右或向上时才能向右走，即：$r_i = r_{i-1} + u_{i-1}$ ；
- 最后看 $u_i$ ：无论上一步怎么走能向上走，即：$u_i = l_{i-1} + r_{i-1} + u_{i-1}$ 。

综合一下：
$$
f_i=l_i+r_i+u_i
$$

$$
=l_{i-1}+u_{i-1}+r_{i-1}+u_{i-1}+l_{i-1}+r_{i-1}+u_{i-1}
$$

$$
=2(l_{i-1}+u_{i-1}+r_{i-1})+u_{i-1}
$$

$$
=2f_{i-1} + l_{i-2} + r_{i-2} + u_{i-2}
$$

$$
=2f_{i-1}+f_{i-2}
$$

递归边界：$f_0=1, f_1=3$

```c++
#include <iostream>
using namespace std;

int main() {
    int n; cin >> n;
    int dp[25] = { }; dp[1] = 3, dp[2] = 7;
    for(int i = 3; i <= n; i++) {
        dp[i] = 2 * dp[i-1] + dp[i-2];
    }
    cout << dp[n] << endl;
    return 0;
}
```

## [7624. 山区建小学](http://noi.openjudge.cn/ch0206/7624/)

### 题目描述

政府在某山区修建了一条道路，恰好穿越总共 $n$ 个村庄的每个村庄一次，没有回路或交叉，任意两个村庄只能通过这条路来往。已知任意两个相邻的村庄之间的距离为 $d_i$（$d_i$ 为正整数），其中，$0<i<n$。为了提高山区的文化素质，政府又决定从 $n$ 个村中选择 $m$ 个村建小学。请根据给定的 $n$、$m$ 以及所有相邻村庄的距离，选择在哪些村庄建小学，才使得所有村到最近小学的距离总和最小，计算最小值。

### 输入格式

第一行为 $n$ 和 $m$，其间用空格间隔。

第二行为 $n-1$ 个整数，依次表示从一端到另一端的相邻村庄的距离，整数之间以空格间隔。

例如

```
10 3
2 4 6 5 2 4 3 1 3
```

表示在 $10$ 个村庄中建 $3$ 所学校。第 $1$ 个村庄与第 $2$ 个村庄距离为 $2$，第 $2$ 个村庄与第 $3$ 个村庄距离为 $4$，第 $3$ 个村庄与第 $4$ 个村庄距离为 $6$，...，第 $9$ 个村庄到第 $10$ 个村庄的距离为 $3$。

### 输出格式

各村庄到最近学校的距离之和的最小值。

### 样例 #1

#### 样例输入 #1

```
10 2
3 1 3 1 1 1 1 1 3
```

#### 样例输出 #1

```
18
```

### 提示

$1 \le m \le n < 500$，$1 \le d_i \le 100$。

### 题解

设`dp[i][j]`表示在前 $i$ 的村庄中建设 $j$ 座小学的最小距离和，$k$ 为最靠右的有小学的村庄编号（$k \in [j-1,i]$），易得：$dp[i][j]=\operatorname{min}(dp[k][j-1]+在(k,i]区间建一座小学的最小距离和)$ ，枚举 $i$，$j$，$k$。`dp[n][m]`即为答案。

根据七年级的知识，易证在 $n$ 个村庄中，将小学建在两端村庄所构成的线段的中点上，所有村庄到小学的距离和最短。设 `dis[k][j]`表示在 $[k,j]$ 区间建一座小学的最小距离和，则 $dis[k][j]=\sum^{j}_{i=k}{|a_{\frac{(k+j)}{2}} - a_i|}$

```c++
#include <bits/stdc++.h>
using namespace std;

int dp[501][501] = {};
int dis[501][501] = {};
int d[501] = {};
int n, m;

int main() {
    cin >> n >> m;
    for(int i = 2; i <= n; i++) {
        cin >> d[i];
        d[i] += d[i - 1];   //获得真实坐标
    }

    for(int i = 1; i <= n; i++) {
        for(int j = i; j <= n; j++) {
            int mid = (i + j) >> 1;
            for(int k = i; k <= j; k++) {
                dis[i][j] += abs(d[mid] - d[k]);
            }
        }
    }
    memset(dp, 0x3f, sizeof dp);
    dp[0][0] = 0;
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++) {
            if(j > i) {
                dp[i][j] = 0;
                continue;
            }
            for(int k = j - 1; k <= i; k++) {   //上一个建小学的村庄
                dp[i][j] = min(dp[k][j - 1] + dis[k + 1][i], dp[i][j]);
            }
        }
    }

    cout << dp[n][m] << endl;
    
    return 0;
}
```

# 递归

## [2705. 括号匹配问题](http://noi.openjudge.cn/ch0202/2705/)

### 【题目描述】
在某个字符串（长度不超过 $100$ ）中有左括号、右括号和大小写字母；规定（与常见的算数式子一样）任何一个左括号都从内到外与在它右边且距离最近的右括号匹配。写一个程序，找到无法匹配的左括号和右括号，输出原来字符串，并在下一行标出不能匹配的括号。不能匹配的左括号用`$`标注,不能匹配的右括号用`?`标注。

### 【输入】
输入包括多组数据，每组数据一行，包含一个字符串，只包含左右括号和大小写字母，字符串长度不超过 $100$。

### 【输出】
对每组输出数据，输出两行，第一行包含原始输入字符，第二行由`$`,`?`和空格组成，`$`和`?`表示与之对应的左括号和右括号不能匹配。

### 【输入样例】
```
((ABCD(x)
)(rttyy())sss)(
```

### 【输出样例】
```
((ABCD(x)
$$
)(rttyy())sss)(
?            ?$
```

### 【题解】

我们考虑遍历整个字符串，对于每个左括号，尝试找到有括号的同时并标记。

```c++
string sign;

int find(int pos) {
    int l = pos;        //记录左括号的位置
    int r = pos + 1;    
    while(r < len) {    //向右找右括号
        if(s[r] == ')') return r;         //找到右括号
        else if(s[r] == '(') r = find(r); //找下一个左括号对应的右括号
        r++;
    }
    sign[l] = '$';
}
```

main函数：
```c++
int main() {
    string s;
    while(cin >> s) {
        sign(s.size() - 1, ' ');
        int i = 0;
        while(i < s.size()) {                   //遍历字符串
            if(s[i] == ')') sign[i] = '?';      //直接遇到右括号
            else if(s[i] == '(') i = find(i);   //遇到左括号，开始查找
            i++;                                //下一个字符
        }
        cout << s << endl << sign;
    }
}
```

完整代码：
```c++
#include <bits/stdc++.h>
using namespace std;

string sign;

int find(int pos) {
    int l = pos;        //记录左括号的位置
    int r = pos + 1;    
    while(r < len) {    //向右找右括号
        if(s[r] == ')') return r;         //找到右括号
        else if(s[r] == '(') r = find(r); //找下一个左括号对应的右括号
        r++;
    }
    sign[l] = '$';
}

int main() {
    string s;
    while(cin >> s) {
        sign(s.size() - 1, ' ');
        int i = 0;
        while(i < s.size()) {                   //遍历字符串
            if(s[i] == ')') sign[i] = '?';      //直接遇到右括号
            else if(s[i] == '(') i = find(i);   //遇到左括号，开始查找
            i++;                                //下一个字符
        }
        cout << s << endl << sign;
    }
}
```

# ✨✨提高拓展部分

## 逆序对

给定 $n$ 个整数，求其中共有几对逆序对（$a_i>a_j$ 且 $i<j$）。

### 朴素方式——冒泡排序

{% note default fa-clock %}
时间复杂度 $\mathbf{O}(n^2)$
{% endnote %}

{% note default fa-keyboard %}
编程复杂度：⭐
{% endnote %}

回想冒泡排序的思路，发现冒泡排序的核心方式就是 __交换逆序对__。

```c++
int cnt = 0;
for(int i = n; i > 1; i--) {   //范围[1,i]，逐渐缩小范围
    bool isSwap = false;
    for(int j = 1; j <= i; j++) { 
        if(a[j] > a[j + 1]) {   //逆序对
            swap(a[j], a[j + 1]);
            cnt++;
            isSwap = true;
        }
    }
    if(!isSwap) break;  //无需交换
}

cout << cnt;
```

### 进阶方案——归并排序

{% note default fa-clock %}
时间复杂度 $\mathbf{O}(n log_2n)$
{% endnote %}

{% note default fa-keyboard %}
编程复杂度：⭐⭐⭐
{% endnote %}

由于归并排序是冒泡排序的优化，所以可以替代冒泡排序。

```c++
//...
int cnt = 0;
void msort(int l, int r) {
    if(l == r) return;
    int mid = l + (r-l) >> 1;
    int i = l, j = mid + 1, k = l;
    msort(i, mid); msort(mid + 1, r);

    while(i <= mid && j <= r) {
        if(a[i] <= a[j]) t[k++] = a[i++];
        else {                      //发现逆序对
            t[k++] = a[j++];
            cnt += (mid - i + 1);   //由于a[i~mid]有序，a[i~mid]的都能与a[j]组成逆序对
        }
    }

    while(i <= mid) t[k++] = a[i++];
    while(j <= r) t[k++] = a[j++];

    for(int pos = l; pos <= r; pos++) a[pos] = r[pos];
}

//in main:
    msort(l, r);
    cout << cnt;
```

### 最优方案——[树状数组](https://xingchen8800.github.io/2024/08/17/d10/)+[离散化](https://xingchen8800.github.io/2024/10/19/离散化/)

{% note default fa-clock %}
时间复杂度 $\mathbf{O}(n log_2n)$
{% endnote %}

{% note default fa-keyboard %}
编程复杂度：⭐⭐
{% endnote %}

先说说离散化：对于一串差很大的数据，如 ${1, 999, 1145, 3}$，若用桶存储，需要用掉至少 $1146$ 个byte。但我们对其按大小分配相对数值，就变为 ${1, 3, 4, 2}$，若用桶存储，只需要用掉至少 $5$ 个byte，空间复杂度大大降低。

对于每个数 $i$，我们都要求他之前的比它小的数的个数，当我们将树状数组中的`sum(1,i-1)`作为查询有多少个比 $i$ 小的数时，只需要每次查询`sum(1,i-1)`并累加，将树状数组作为桶维护树状数组即可。

```c++
#include <bits/stdc++.h>
using namespace std;

int a[100001], rank[100001], t[100001];	//rank是离散化后的结果，rank[i]中，i为离散化结果，rank[i]为对应元素
int n;

bool cmp(int x, int y) {
	if(a[x] == a[y]) return x > y;	//元素相同按下标 
	return a[x] > a[y];				//元素不同按大小 
} 

int lowbit(int x) { 
	return x & -x;
}

void update(int x, int k) {
	while(x <= n) {
		t[x] += k;
		x += lowbit(x);
	}
}

int sum(int x, int y) {
	if(x == 1) {
		while(y >= 1) {
			result += t[y];
			y -= lowbit(y);
		}
		return result;
	} else return sum(1, y) - sum(1, x - 1);
}

int main() {
	cin >> n;
	for(int i = 1; i <= n; i++) {
		cin >> a[i];
		rank[i] = i; 
	}	
	sort(rank + 1, rank + 1 + n, cmp);
	
	int cnt = 0;
	for(int i = 1; i <= n; i++) {
		update(rank[i], 1);         //把树状数组当作桶，标记rank[i]已经存在
		cnt += sum(1, rank[i] - 1);	//求下标比rank[i]靠前且比rank[i]小的数有多少 
	}
	cout << cnt; 
}
```