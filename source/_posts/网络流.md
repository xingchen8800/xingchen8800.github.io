---
title: 网络流
date: 2024-11-10 17:07:37
tags: CSP-S
excerpt: 研究网络上的问题：最大流、最小割、费用流、上下界网络流
---

# 介绍

网络流研究一系列网络上的问题，如：


- 最大流
- 最小割
- 费用流
- 上下界网络流

# 最大流(MaxFlow)

## 引入

给定一个有向图，图上每条边都有自己的容量 $c$，记 $u \rightarrow v$ 的容量为 $c(u,v)$。图中，有一个 __源点__，一个 __汇点__。有 $∞$ 条水流从 __源点__ 出发，经过有向图上的各条边，每条边 $u \rightarrow v$ 最多只能承担 $c(u,v)$ 条水流，求最终流到 __汇点__ 的水流 __最多__ 有多少条。

__增广路__： 一条从 __源点__ 到 __汇点__ 的所经边容量均不为 $0$ 的路径。

__瓶颈__： 对于一条 __增广路__，其单边容量 __最小值__ 即为 __瓶颈__。

## 计算方法

### 朴素思想-dfs

我们考虑通过不断地 __找增广路__，每次在增广路上放置尽可能多的（即其瓶颈）水流，计算 __最大流__。由于增广路是一条 __源点__ 到 __汇点__ 的路径，所以用 $dfs$ 来做。

```c++
//当前在节点u，增广路流数剩余cur，dfs(u,cur)求从u到T剩cur流的最大流。
int dfs(int u, int cur) {
    int sum = 0, d;
    if(u == T) return cur;
    for(int i = head[u], v, c; i; i = l[i].nxt) {   //遍历邻边
        v = l[i].v, c = l[i].c;
        if(c > 0) {                                 //邻边还有容量
            d = dfs(v, min(cur, c));                //流出d流，min起到计算瓶颈的作用
            l[i].c -= d, sum += d, cur -= d;        //容量-d，最大流+d，当前流数-d
            if(!cur) return sum;                    //当前增广路遇到瓶颈
        }
    }
    return sum;
}
```

### 修正错误-反向弧

但是，$dfs$ 的搜索顺序 __会影响__ 最终的结果。有时让一流从另一条 __增广路__ 走可能会得到更大的流量；反之会堵塞别的 __增广路__。

此时，我们引入 __反向弧__：与放下的流 __方向相反__，容量 __相同__ 的边。这样，我们就可以通过走反向弧的方式来 “撤销” 之前的操作。

反向弧怎样存呢？

```c++
struct Edge {
    int v, c, nxt;
} l[M];
int head[N], cnt = 1;
```

这里 $cnt$ 初始化为 $1$ 时为了通过异或操作查找边对应的另一边（对于一条正向边 $i$，与其对应的反向弧为 $i \oplus 1$，反之亦然）。

```c++
void AddEdge(int u, int v, int c) {
    Edge[++cnt] = {v, c, head[u]};
    head[u] = cnt;
    Edge[++cnt] = {u, 0, head[v]};
    head[v] = cnt;
}
```

`AddEdge()` 函数起到添加正反边的作用。


### 走向更优-ISAP算法

加入了反向弧，我们的确解决了 __正确性__ 问题，但是如果遇到下图这种情况，效率可能会 __很低__:

![反例](/images/NetworkStream-1.png)

- 如图所示，~~一眼可以看出最大流为198。~~如果 $dfs$ 选择了 $1 \rightarrow 3 \rightarrow 4$ 这条增广路，生成反向弧后，会不断交替地走 $1 \rightarrow 3 \rightarrow 2 \rightarrow 4$ 和 $1 \rightarrow 3 \rightarrow 4$ 这两条增广路，让 $2 \rightarrow 3$ 这条边反复 __被选__ 与 __被退流__，最大流每次 $+1$，要跑 $198$ 次才能结束。
- 显然，如果直接走 $1 \rightarrow 2 \rightarrow 4$ 和 $1 \rightarrow 3 \rightarrow 4$，两次就可解决。

我们引入 __分层__ 概念：

- `dis[]` 数组记录点 $i$ 对应的层数
- `gap[]` 数组记录每个层数上点的数量

1. 初始化 `dis[]` 数组为 $0$，即所有边都在 $0$ 层上；
2. 在找增广路的过程中为图分层；
3. 只有两个点的 `dis[]` 值相差为 $1$ 时，才能产生一条增广路；否则认为 __出现断层__， 这条路上 __不__ 存在新的增广路；
4. 当某个 `gap[]` 被减成 $0$ 时，一定 __出现断层__，需要结束算法。

```c++
//建议的操作：将int改为long long
#define int long long
int tot;    //总点数
int S, T;   //源点编号，汇点编号
const int INF = 0x3f3f3f3f;

int Stream(int u, int cur);

int Sap() {
    int ans = 0;
    memset(gap, 0, sizeof gap);
    memset(dis, 0, sizeof dis);
    gap[0] = tot;
    while(dis[S] < tot) ans += Stream(S, INF);
    return ans;
}
int Stream(int u, int cur) {
    int sum = 0, d;
    if(u == T) return cur;              //到达汇点
    for(int i = head[u], v; i; i = l[i].nxt) {
        v = l[i].v;
        if(l[i].c > 0 && dis[v] + 1 == dis[u]) {    //没有断层
            d = Stream(v, min(cur, l[i].c));        //流出d流
            l[i].c -= d; l[i ^ 1].c += d;           //更新
            sum += d; cur -= d;                     //更新
            if(dis[S] == tot || !cur) return sum;   //流完了
        }
    }
    if(!(--gap[dis[u]])) dis[S] = tot;  //断层，结束
    gap[++dis[u]]++;                    //分层
    return sum;
} 
```

## 题目

### 【模板题】 [草地排水](https://www.luogu.com.cn/problem/P2740)

#### 题目背景

在农夫约翰的农场上，每逢下雨，贝茜最喜欢的三叶草地就积聚了一潭水。这意味着草地被水淹没了，并且小草要继续生长还要花相当长一段时间。因此，农夫约翰修建了一套排水系统来使贝茜的草地免除被大水淹没的烦恼（不用担心，雨水会流向附近的一条小溪）。作为一名一流的技师，农夫约翰已经在每条排水沟的一端安上了控制器，这样他可以控制流入排水沟的水流量。

#### 题目描述

农夫约翰知道每一条排水沟每分钟可以流过的水量，和排水系统的准确布局（起点为水潭而终点为小溪的一张网）。需要注意的是，有些时候从一处到另一处不只有一条排水沟。

根据这些信息，计算从水潭排水到小溪的最大流量。对于给出的每条排水沟，雨水只能沿着一个方向流动，注意可能会出现雨水环形流动的情形。

#### 输入格式

第一行：两个用空格分开的整数 $N$（$0 \le N \le 200$）和 $M$（$2 \le M \le 200$）。$N$ 是农夫 John 已经挖好的排水沟的数量，$M$ 是排水沟交叉点的数量。交点 $1$ 是水潭，交点 $M$ 是小溪。

第二行到第 $N + 1$ 行：每行有三个整数，$S_i, E_i, C_i$。$S_i$ 和 $E_i$（$1 \le S_i, E_i \le M$）指明排水沟两端的交点，雨水从 $S_i$ 流向 $E_i$。$C_i$（$0 \le C_i \le {10}^7$）是这条排水沟的最大容量。

#### 输出格式

输出一个整数，即排水的最大流量。

#### 样例 #1

##### 样例输入 #1

```
5 4
1 2 40
1 4 20
2 4 20
2 3 30
3 4 10
```

##### 样例输出 #1

```
50
```

#### 提示

题目翻译来自NOCOW。

USACO Training Section 4.2

**【数据范围】**

对于 $100 \%$ 的数据，$0 \le N, M \le 200$，$0 \le C_i \le {10}^7$。

#### 【题解】

这题~~几乎~~不用建模，题目本身就是一个网络图，我们只需建图并跑个 $ISAP$ 即可。

```c++
#include <bits/stdc++.h>
#define int long long
using namespace std;

//N边 M点
const int N = 201, M = 201, INF = 0x3f3f3f3f;
struct Edge {
    int v, c, nxt;
} l[N * 2];
int h[M], cnt = 1;
int S, T, tot;

void AddEdge(int u, int v, int c) {
    l[++cnt] = {v, c, h[u]}; h[u] = cnt;
    l[++cnt] = {u, 0, h[v]}; h[v] = cnt; 
}

int dis[M], gap[M];
int Stream(int u, int cur) {
    int sum = 0, d;
    if(u == T) return cur;
    for(int i = h[u], v; i; i = l[i].nxt) {
        v = l[i].v;
        if(l[i].c > 0 && dis[v] + 1 == dis[u]) {
            d = Stream(v, min(l[i].c, cur));
            l[i].c -= d, l[i^1].c += d;
            sum += d, cur -= d;
            if(dis[S] == tot || !cur) return sum;
        }
    }
    if(!(--gap[dis[u]])) dis[S] = tot;
    gap[++dis[u]]++;
    return sum;
}

int Sap() {
    int ans = 0;
    memset(dis, 0, sizeof dis);
    memset(gap, 0, sizeof gap);
    gap[0] = tot;
    while(dis[S] < tot) ans += Stream(S, INF);
    return ans;
}

#undef int

int main() {
    int n, m; cin >> n >> m;
    //建图
    for(int i = 1, s, e, c; i <= n; i++) {
        cin >> s >> e >> c;
        AddEdge(s, e, c);
    }
    //定义源点、汇点和总点数
    S = 1, T = m, tot = m;
    cout << Sap();  //ISAP算法出结果
    return 0;
}
```

### 【思维提升题】 [SCOI2007-蜥蜴](https://www.luogu.com.cn/problem/P2472)

#### 题目描述

在一个 $r$ 行 $c$ 列的网格地图中有一些高度不同的石柱，第 $i$ 行 $j$ 列的石柱高度为 $h_{i,j}$。

一些石柱上站着一些蜥蜴，你的任务是让尽量多的蜥蜴逃到边界外。

每行每列中相邻石柱的距离为 $1$，蜥蜴的跳跃距离是 $d$，即蜥蜴可以跳到**平面距离**不超过 $d$ 的任何一个石柱上。

石柱都不稳定，每次当蜥蜴跳跃时，所离开的石柱高度减 $1$（如果仍然落在地图内部，则到达的石柱高度不变）。

如果该石柱原来高度为 $1$，则蜥蜴离开后消失，以后其他蜥蜴不能落脚。

任何时刻不能有两只蜥蜴在同一个石柱上。

#### 输入格式

###### 输入格式
输入第一行为三个整数 $r,c,d$，即地图的规模与最大跳跃距离。

接下来 $r$ 行每行 $c$ 个数字为石柱的初始状态，$0$ 表示没有石柱，否则表示石柱的初始高度 $h_{i,j}$。

接下来 $r$ 行每行 $c$ 个字符为蜥蜴位置，`L` 表示蜥蜴，`.` 表示没有蜥蜴。

#### 输出格式

输出仅一行，包含一个整数，即无法逃离的蜥蜴总数的最小值。

#### 样例 #1

##### 样例输入 #1

```
5 8 2
00000000
02000000
00321100
02000000
00000000
........
........
..LLLL..
........
........
```

##### 样例输出 #1

```
1
```

#### 提示

对于 $100\%$ 的数据满足：$1\le r,c\le20$，$1\le d\le 4$，$1\le h\le 3$。

#### 题解

{% note red fa-star %}
本题 __难点__：建图。
{% endnote %}

为了方便解题，我们将题意转换一下：没逃出的蜥蜴数 $\rightarrow$ 总蜥蜴数 - 跳出的蜥蜴数

首先，我们可以将蜥蜴看作网络中的 __流__，将蜥蜴跳跃的过程看作是流动的过程，那么求跳出的蜥蜴数就是且网络的 __最大流__。

怎样建图呢？由于初始有多个蜥蜴在不同的石柱上，我们考虑建立一个 __虚拟源点__，将虚拟源点与各个石柱连一条容量为 $∞$ 的边，以便模拟多个蜥蜴在不同石柱上的情况。我们还要建立一个 __虚拟汇点__，对于每个可以直接跳出的石柱，我们连一条容量为 $∞$ 到虚拟汇点。

![虚拟源点](/images/NetworkStream-2.png)

对于每个石柱，我们希望它可以实现只能被跳上 $h_{i,j}$ 次。我们可以建立 __两个点__ 来描述一个石柱，称为 __入点__ 和 __出点__，入点和出点之间有且仅有一条容量为 $h_{i,j}$ 的边，入点的出度为 $1$，出点的入度为 $1$，就达成了限制次数的目的。

![石柱模拟图](/images/NetworkStream-3.png)

石柱与石柱之间通过一条容量为 $∞$ 的边，表示可以相互通行。

总结一下建图思路： __1.建虚拟源点和虚拟汇点；2.用两个点描述石柱；3.将有蜥蜴的石柱和源点相连；4.连接各个石柱；5.将可以跳出的石柱和汇点相连__

建完图，这题就没有难度了，跑个 $ISAP$ 完事。

__本题仅提供建图代码！__
```c++
//计算平面距离
int GetDis(int x_1, int y_1, int x_2, int y_2) {
    return (x_1 - x_2) * (x_1 - x_2) + (y_1 - y_2) * (y_1 - y_2);
}

//判断是否可以跳出
bool CanJumpOut(int x, int y) {
    if(x <= d || y <= d) return true;
    if(r - (x - 1) <= d || c - (y - 1) <= d) return true;
    return false;
}

//建图
void Build() {
    //模拟石柱
    for(int i = 1; i <= r; i++) {
        for(int j = 1; j <= c; j++) {
            in[i][j] = ++tot;       //入点编号
            out[i][j] = ++tot;      //出点编号
        }
    }
    S = ++tot, T = ++tot;   //虚拟源点和虚拟汇点
    for(int i = 1; i <= r; i++) {
        for(int j = 1; j <= c; j++) {
            AddEdge(in[i][j], out[i][j], h[i][j]);      //模拟石柱
            if(mp[i][j] == 'L') {   //有蜥蜴
                AddEdge(S, in[i][j], INF);  //与源点连边
            }
            //与所有可以跳到的石柱连边
            for(int x = 1; x <= r; x++) {
                for(int y = 1; y <= c; y++) {
                    if(GetDis(i, j, x, y) <= d*d) {
                        AddEdge(Out[i][j], In[x][y], INF);
                    }
                }
            }
            if(CanJumpOut(x, y)) {
                AddEdge(Out[i][j], T, INF);
            }
        }
    }
}

//...
    Build();
    cout << LizardCnt - Sap() << endl;
//...
```

# 最小割(MinCut)

## 引入

在网络图中，我们可以通过割断一些边的方式来切断源点与汇点。但是，有些边的权值特别大，有些边的权值特别小，怎样割才能使割掉的边的权值和最小呢？这便是 __最小割__ 研究的问题。

## 求解

注意到，最大流和最小割有两个共性：__1.都是求最值；2.终止条件都是不能连通__

由于最小割对应的流为 $f$，其流量等于最小割，若 $f$ 不是最大流，则一定能找到不属于 $f$ 的边，使其能构成新的连通路径到达汇点，才能增加流量值。但最小割的边集合全在流 $f$ 中，意味着，目前去掉最小割的边后，图已经不连通，则添加非最小割边不能改变图的连通性，即目前已经无法增加流量。所以最小割对应的流的流量已经达到最大，即 __最大流__。[（摘自@PandasRan的博客）](https://blog.csdn.net/jy02660221/article/details/83471968)

所以：__最小割__ $=$ __最大流__

## 题目

### [Dual Core CPU](http://poj.org/problem?id=3469)

### [文理分科](https://www.luogu.com.cn/problem/P4313)

### [最大获利](https://www.luogu.com.cn/problem/P4174)

### [解雇](https://www.luogu.com.cn/problem/P4174)