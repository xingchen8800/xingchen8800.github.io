---
title: 动态规划DP
date: 2024-09-25 22:21:41
tags: C++
categories: 
- [算法,动态规划]
---

# [租用游艇](https://www.luogu.com.cn/problem/P1359)

## 题目描述

长江游艇俱乐部在长江上设置了 $n$ 个游艇出租站 $1,2,\cdots,n$。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站 $i$ 到游艇出租站 $j$ 之间的租金为 $r(i,j)$（$1\le i\lt j\le n$）。试设计一个算法，计算出从游艇出租站 $1$ 到游艇出租站 $n$ 所需的最少租金。

## 输入格式

第一行中有一个正整数 $n$，表示有 $n$ 个游艇出租站。接下来的 $n-1$ 行是一个半矩阵 $r(i,j)$（$1\le i<j\le n$）。

## 输出格式

输出计算出的从游艇出租站 $1$ 到游艇出租站 $n$ 所需的最少租金。

## 样例 #1

### 样例输入 #1

```
3
5 15
7
```

### 样例输出 #1

```
12
```

## 提示

$n\le 200$，保证计算过程中任何时刻数值都不超过 $10^6$。

## 题解

1. 设计状态：由于题目要求到游艇出租站 $n$ 所需的最少租金，则设`dp[i]`为从 $1$ 到 $i$ 的最少租金，`dp[n]`即为答案。
2. 初始状态：从 $1$ 到 $1$ 花费为 $0$，`dp[1] = 0`
3. 状态转移：可以发现，$n$ 可以从 $1$ 到 $n-1$ 之间的所有出租站过来，则遍历 $1$ 到 $n-1$ 之间的所有出租站为中转点，租过来即可。每次去最小值，即`dp[i] = min(dp[i], dp[j] + r[j][i])`

```c++
#include <bits/stdc++.h>
using namespace std;

int main() {
    int n;
    int r[201][201];
    cin >> n;
    for(int i = 1; i <= n; i++) {
        for(int j = i + 1; j <= n; j++) {
            cin >> r[i][j];
        }
    }
    int dp[201];
    memset(dp, 0x3f, sizeof dp);
    dp[1] = 0;
    
    for(int to = 2; to <= n; to++) {            //遍历所有的i
        for(int from = 1; from <= to; from++) { //遍历所有的出租站为中转点
            dp[to] = min(dp[to] /*本身*/, dp[from] + r[from][to] /*从from到to*/);   //取最小值
        }
    }
    cout << dp[n] << endl;
    return 0;
}
```

# [[NOIP2006 普及组] 开心的金明](https://www.luogu.com.cn/problem/P1060)

## 题目描述

金明今天很开心，家里购置的新房就要领钥匙了，新房里有一间他自己专用的很宽敞的房间。更让他高兴的是，妈妈昨天对他说：“你的房间需要购买哪些物品，怎么布置，你说了算，只要不超过 $N$ 元钱就行”。今天一早金明就开始做预算，但是他想买的东西太多了，肯定会超过妈妈限定的 $N$ 元。于是，他把每件物品规定了一个重要度，分为 $5$ 等：用整数 $1-5$ 表示，第 $5$ 等最重要。他还从因特网上查到了每件物品的价格（都是整数元）。他希望在不超过 $N$ 元（可以等于 $N$ 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。

设第$j$件物品的价格为 $v_j$，重要度为 $w_j$，共选中了 $k$ 件物品，编号依次为 $j_1,j_2,…,j_k$，则所求的总和为：

$$v_{j_1} \times w_{j_1}+v_{j_2} \times w_{j_2} …+v_{j_k} \times w_{j_k}$$

请你帮助金明设计一个满足要求的购物单。

## 输入格式

第一行，为 $2$ 个正整数，用一个空格隔开：$n,m$（$n<30000,m<25$）其中 $n$ 表示总钱数，$m$ 为希望购买物品的个数。

从第 $2$ 行到第 $m+1$ 行，第 $j$ 行给出了编号为 $j-1$ 的物品的基本数据，每行有 $2$ 个非负整数 $v,p$（其中 $v$ 表示该物品的价格 $(v \le 10000)$，$p$ 表示该物品的重要度（$1\le p\le5$）。

## 输出格式

$1$ 个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（$<100000000$）。

## 样例 #1

### 样例输入 #1

```
1000 5
800 2
400 5
300 5
400 3
200 2
```

### 样例输出 #1

```
3900
```

## 提示

NOIP 2006 普及组 第二题

## 题解
典型的 __0/1背包__ 问题。套模板即可。

```c++
#include <bits/stdc++.h>
using namespace std;

int n, m;
int dp[26][30001];
int v[30001], w[30001];

int main() {
    cin >> n >> m;
    for(int i = 1; i <= m; i++) {
        cin >> v[i] >> w[i];
    }

    memset(dp, 0, sizeof dp);
    for(int i = 1; i <= m; i++) {
        for(int j = n; j >= 0; j--) {
            if(j >= v[i]) {
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - v[i]] + v[i] * w[i]);
            } else {
                dp[i][j] = dp[i - 1][j];
            }
        }
    }
    cout << dp[m][n];
    return 0;
}
```

# [5 倍经验日](https://www.luogu.com.cn/problem/P1802)

## 题目背景

现在乐斗有活动了！每打一个人可以获得 5 倍经验！absi2011 却无奈的看着那一些比他等级高的好友，想着能否把他们干掉。干掉能拿不少经验的。

## 题目描述

现在 absi2011 拿出了 $x$ 个迷你装药物（嗑药打人可耻…），准备开始与那些人打了。

由于迷你装药物每个只能用一次，所以 absi2011 要谨慎的使用这些药。悲剧的是，用药量没达到最少打败该人所需的属性药药量，则打这个人必输。例如他用 $2$ 个药去打别人，别人却表明 $3$ 个药才能打过，那么相当于你输了并且这两个属性药浪费了。

现在有 $n$ 个好友，给定失败时可获得的经验、胜利时可获得的经验，打败他至少需要的药量。

要求求出最大经验 $s$，输出 $5s$。

## 输入格式

第一行两个数，$n$ 和 $x$。

后面 $n$ 行每行三个数，分别表示失败时获得的经验 $\mathit{lose}_i$，胜利时获得的经验 $\mathit{win}_i$ 和打过要至少使用的药数量 $\mathit{use}_i$。

## 输出格式

一个整数，最多获得的经验的五倍。

## 样例 #1

### 样例输入 #1

```
6 8
21 52 1
21 70 5
21 48 2
14 38 3
14 36 1
14 36 2
```

### 样例输出 #1

```
1060
```

## 提示

**【Hint】**

五倍经验活动的时候，absi2011 总是吃体力药水而不是这种属性药。

**【数据范围】**

- 对于 $10\%$ 的数据，保证 $x=0$。
- 对于 $30\%$ 的数据，保证 $0\le n\le 10$，$0\le x\le 20$。
- 对于 $60\%$ 的数据，保证 $0\le n,x\le 100$， $10<lose_i,win_i\le 100$，$0\le use_i\le 5$。
- 对于 $100\%$ 的数据，保证 $0\le n,x\le 10^3$，$0<lose_i\le win_i\le 10^6$，$0\le use_i\le 10^3$。

**【题目来源】**

fight.pet.qq.com

absi2011 授权题目

## 题解

这是一道简单的 __0/1背包__ 变形题。（变形点：由 __一个价值__ 变为 __两个价值__ ）

先设计状态，`dp[i][j]`表示前 $i-1$ 个中磕了 $j$ 瓶药的经验最大值。考虑对于第 $i$ 个人，可以选择打或是不打，不打就要从 `dp[i-1][j]`转移，打就要从`dp[i-1][j-use[i]]`转移，即：`dp[i][j]=max(dp[i-1][j]+lose[i],dp[i-1][j-use[i]]+win[i])`

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1001;
int n, x;
int lose[N], win[N], use[N];
int dp[N][N];

int main() {
    cin >> n >> x;
    for(int i = 1; i <= n; i++) scanf("%d %d %d", &lose[i], &win[i], &use[i]);
    memset(dp, 0, sizeof dp);

    for(int i = 1; i <= n; i++) {
        for(int j = x; j >= 0; j--) {
            if(j >= use[i]) dp[i][j] = max(dp[i-1][j] + lose[i], dp[i-1][j-use[i]] + win[i]);
            else dp[i][j] = dp[i-1][j] + lose[i];
        }
    }
    printf("%lld", (unsigned long long)dp[n][x]*5);
    return 0;
}
```

# [[NOIP2001 普及组] 装箱问题](https://www.luogu.com.cn/problem/P1049)

## 题目描述

有一个箱子容量为 $V$，同时有 $n$ 个物品，每个物品有一个体积。


现在从 $n$ 个物品中，任取若干个装入箱内（也可以不取），使箱子的剩余空间最小。输出这个最小值。

## 输入格式

第一行共一个整数 $V$，表示箱子容量。

第二行共一个整数 $n$，表示物品总数。

接下来 $n$ 行，每行有一个正整数，表示第 $i$ 个物品的体积。

## 输出格式

- 共一行一个整数，表示箱子最小剩余空间。

## 样例 #1

### 样例输入 #1

```
24
6
8
3
12
7
9
7
```

### 样例输出 #1

```
0
```

## 提示

对于 $100\%$ 数据，满足 $0<n \le 30$，$1 \le V \le 20000$。

**【题目来源】**

NOIP 2001 普及组第四题

## 题解

__0/1背包__ 变式题，变式点：去除了价值概念（~~其实价值就是重量~~）

```c++
#include <bits/stdc++.h>
using namespace std;

int n, V;
int w[31], dp[31][20001] = {};

int main() {
    cin >> V >> n;
    for(int i = 1; i <= n; i++) cin >> w[i];

    for(int i = 1; i <= n; i++) {
        for(int j = V; j >= 0; j--) {
            //w[i]就是价值
            if(j >= w[i]) dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i]] + w[i]);
            else dp[i][j] = dp[i-1][j];
        }
    }
    cout << V - dp[n][V];
    return 0;
}
```

可以优化，将`dp`优化成一维数组。

```c++
#include <bits/stdc++.h>
using namespace std;

int n, V;
int w[31], dp[20001] = {};

int main() {
    cin >> V >> n;
    for(int i = 1; i <= n; i++) cin >> w[i];

    for(int i = 1; i <= n; i++) {
        for(int j = V; j >= w[i]; j--) {
            dp[j] = max(dp[j-w[i]]+w[i],dp[j]);
        }
    }
    cout << V - dp[V];
    return 0;
}
```