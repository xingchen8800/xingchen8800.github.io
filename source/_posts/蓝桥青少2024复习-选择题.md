---
title: 蓝桥杯复习-选择题
date: 2024-08-24 12:23:06
categories:
    - [蓝桥杯,蓝桥青少]
    - [数据结构,C++语言基础,指针]
tags: C++
---

# 选择题练习组1
本组共4题，考察内容：指针

1. 下列指针的用法中哪一个不正确

    1. `int i;int *p=&i;`
    2. `int i;int *p;i=*p;`
    3. `int *p;p=0;`
    4. `int i=5;int *p;p=&i;`

{% folding green::答案 %}
**B** 

{% tabs 1-1 %}
<!-- tab 选项A -->
**A**
代码：
```c++
int i;          //定义i
int *p = &i;    //将i的地址赋给指针p
```
<!-- endtab -->

<!-- tab 选项B -->
**B**
代码：
```c++
int i;          //定义i
int *p;         //定义指针p（野指针）
i = *p;         //错误：p为野指针，不能解引用
```
<!-- endtab -->

<!-- tab 选项C -->
**C**
代码：
```c++
int *p;         //定义指针p
p = 0;          //将地址0赋给p（虽然p没用，但没错）
```
<!-- endtab -->

<!-- tab 选项D -->
**D**
代码：
```c++
int i = 5;      //定义i
int *p;         //定义指针p
p = &i;         //将i的地址赋给p
```
<!-- endtab -->
{% endtabs %}

{% endfolding %}

2. 已知 int i[5],*p=i;那么执行 cout<<p+2;语句后，可以输出

    1. `i[2]`的值;
    2. `i[2]`的地址
    3. `i[3]`的值
    4. `i[5]`的地址

{% folding green::答案 %}
**B** 
{% endfolding %}

3. 下列对`int *p[3]`描述正确的是

    1. `p[3]`表示数组的第$3$个元素的值，是`int`类型的值
    2. `p`是一个具有$3$个元素的指针数组，每个元素是一个`int`类型的指针
    3. `p`是一个指向数组的指针，所指向的数组是$3$个`int`类型元素
    4. `p`是一个指向某数组中第$3$个元素的指针，该元素是`int`类型的变量

{% folding green::答案 %}
**B** 
{% endfolding %}

4. 若二维数组$a$有$n$列，则在`a[i][j]`前的元素个数为

    1. $i \cdot n+j-1$
    2. $i \cdot n+j$
    3. $j \cdot n+i$
    4. $i \cdot n+j+1$

{% folding green::答案 %}
**B** 

思路：

已知`a[i][j]`同`a + (i * n + j)`，则前一位为`a + (i * n + j - 1)`，前面有`a + i * n + j - 1 - (a - 1)`即`i * n + j`个。
{% endfolding %}

# 选择题练习组2
本组共4题，内容：C++基础

1. 若有如下语句:`int a,b,c;a=b=c=5`;则执行语句:`b+=++a&&++c>b;`后$a、b、c$的值分别为

    1. 6,7,6

    2. 6,6,6

    3. 6,6,5

    4. 6,1,6

{% folding green::答案 %}
**B** 

思路：将`b+=++a&&++c>b`拆分成`b+=``++a``&&``++c``>``b`：

- 显然：`++a`和`++c>b`应同时进行，即：`a=6,c=6,6>5=true`，则`++a&&++c>b`=`6&1`=`true`。
- `b+=1`，则`b=6`。
- 所以`a=6, b=6, c=6`。
{% endfolding %}


2. 设$x$为`int`型变量，则执行下列语句后，$x$的值为。
```c++
x=10;
x+=x-=x-x;
```

    1. $10$

    2. $20$

    3. $30$

    4. $40$

{% folding green::答案 %}
**B**

分析：在`C++`，赋值传递 __从右往左__。

- `x - x`得$0$
- `x -= 0`，得$10$
- `x += 10`，得$20$
{% endfolding %}

3. 对于`int *pa[5];`的描述中，正确的是

    1. `pa`是一个指向数组的指针，所指向的数组是$5$个`int`型元素

    2. `pa`是一个指向某数组中第$5$个元素的指针，该元素是`int`型变量

    3. `pa[5]`表示数组的第$5$个元素的值，是`int`型的值

    4. `pa`是一个具有$5$个元素的指针数组，每个元素是一个`int`型指针

{% folding green::答案 %}
**D**

这里的表达式~~有点坑~~应为：`int* pa[5]`，意为：定义一个长度为5的`int*`型数组
{% endfolding %}

4. 用$0、1、2、3、4$这五个数字，能组成多少个没有重复数字的多位偶数?

    1. 144

    2. 147

    3. 160

    4. 163

{% folding green::答案 %}
**C**

步骤：
<!--
1. 两位偶数

    - 个位：只能为偶数$0、2、4$
    - 十位：不能有前导零$1、2、3、4$

    当十位为
-->
疑似题目有误
{% endfolding %}

# 选择题练习组3
本组共4题

1. 以下叙述正确的是。

    1. break 语句只能用于 switch 语句体中

    2. continue 语句的作用是使程序的执行流程跳出包含它的所有循环 

    3. break 语句只能用在循环体内和 switch 语句体内

    4. 在循环体内使用 break 语句和 continue 语句的作用相同

{% folding green::答案 %}
**C**
{% endfolding %}


2. 设有 100 个元素，利用二分法查找时，最大比较次数是。 

    1. 50

    2. 10

    3. 25

    4. 7

{% folding green::答案 %}
**D**

因为将一个长度为$n$的有序序列通过二分将区间缩小到1的最多次数为$log_2n$向上取整，本题计算$log_2{100} \approx 7$。
{% endfolding %}

3. 有一个由 4000 个整数构成的顺序表，假定表中的元素已经按升序排列，采用二分查找定
位一个元素。则最多需要几次比较就能确定是否存在所查找的元素。

    1. 11

    2. 12
    
    3. 13
    
    4. 14

{% folding green::答案 %}
**B**

因为将一个长度为$n$的有序序列通过二分将区间缩小到1的最多次数为$log_2n$向上取整，本题计算$log_2{4000} \approx 12$。
{% endfolding %}



4. 在顺序表$2，5，7，10，14，15，18，23，35，41，52$中，用二分法查找 12，所需的关键码比较的次数为。
   
    1. 2

    2. 3
    
    3. 4
    
    4. 5

{% folding green::答案 %}
**C**

- 第一次：`left = 1, right = 11, mid = 6`，`a[mid] = 18 > 16`，`right = mid - 1 = 5`
- 第二次：`left = 1, right = 5, mid = 3`，`a[mid] = 7 < 12`，`left = mid + 1 = 4`
- 第三次：`left = 4, right = 5, mid = 4`, `a[mid] = 10 < 12`，`left = mid + 1 = 5`
- 第四次：`left == right`结束
{% endfolding %}

# 选择题练习组4
本组共4题。

1. 以下关于结构体的说法中，正确的一项是?

    1. 结构体中只能包含成员变量，不能包含成员函数

    2. 结构体不能从另一个结构体继承

    3. 结构体里面可以包含静态成员变量

    4. 结构体中里面不能包含函数

{% folding green::答案 %}
**C**

静态成员是当在结构体定义中声明某个成员的存储类型为静态时，它不再与结构体实例绑定，而是所有结构体变量共享的特性，所以不能用“包含”。
{% endfolding %}

2. 在面向对象的程序中，不属于对象特点的是

    1. 多态性

    2. 抽象性

    3. 封装性

    4. 继承性

{% folding green::答案 %}
**B**

抽象性不属于对象，因属于类
{% endfolding %}

3. C++中，class 类成员的默认访问属性是
    
    1. protected
    
    2. private
    
    3. public
    
    4. Friend

{% folding green::答案 %}
**B**
{% endfolding %}

4. 下列关于类中声明的变量描述正确的是

    1. 只属于该类

    2. 属于全局变量

    3. 任何情况下都可被该类所有实例共享

    4. 属于该类，某些情况下也可以被该类不同实例所共享

{% folding green::答案 %}
**D**

例如：静态成员变量
{% endfolding %}

# 选择题练习组5
本组共4题。

1. 下列函数中哪一个不能重载

    1. 构造函数

    2. 析构函数

    3. 成员函数

    4. 非成员函数

{% folding green::答案 %}
**B**

析构函数可以委托、继承，不能重载，只有`Example::~Example()`一种。
{% endfolding %}

2. 以下关于 C++类的说法，正确的是

    1. 析构函数和构造函数一样可以进行重载

    2. 析构函数是不能使用 return 语句

    3. 构造函数不需要返回值时，需要定义为返回 void 类型

    4. 如果自定义构造函数的参数都是默认参数，则不能再定义一个无参数的构造函数

{% folding green::答案 %}
**B**

{% tabs 5-2 %}
<!-- tab 选项A -->
**A**
上题说了，析构函数不能重载
<!-- endtab -->

<!-- tab 选项B -->
**B**
正确
<!-- endtab -->

<!-- tab 选项C -->
**C**
构造函数不能加返回值类型
<!-- endtab -->

<!-- tab 选项D -->
**D**
错误，默认调用无参构造函数
<!-- endtab -->
{% endtabs %}

{% endfolding %}

3. 关于运算符重载，下列表述中正确的是

    1. C++已有的任何运算符都可以重载

    2. 运算符函数的返回类型不能声明为基本数据类型

    3. 在类型转换符函数的定义中不需要声明返回类型

    4. 可以通过运算符重载来创建 c++中原来来没有的运算符

{% folding green::答案 %}
**C**
{% endfolding %}

4. 执行以下代码，输出的结果是
    ```c++
    #include <iostream>
    using namespace std;

    int func(int x) {
        if(x <= 3) return x * 2 - 1;
        else if(x >= 6) return func(x - 3) - 2;
        else return func(x + 1) + x;
    }

    int main() {
        cout << func(14);
        return 0;
    }
    ```
    1. 2
    
    2. 4

    3. 6

    4. -1
{% folding green::答案 %}
**A**
{% endfolding %}

# 选择题练习组6
本组共4题。

1. 8 位二进制数中去掉符号位，最大能表示的数值

    1. 127
    2. 128
    3. 255
    4. 256


{% folding green::答案 %}
**C**

$2^{8}-1=256-1=255$
{% endfolding %}

2. $[x]$补码=10011000，其原码为

    1. 011001111
    2. 11101000
    3. 11100110
    4. 01100101


{% folding green::答案 %}
**B**

已知：$[x]$的补码为反码+1，则$[x]$的原码就是$[x]$其补码减一取反。

$(10011000)_2 - (1)_2 = (10010111)_2$，取反码，得$(11101000)_2$
{% endfolding %}

3. 二进制数 11110110 和 00001111 进行逻辑异或运算的结果是

    1. 11111001
    2. 00000110
    3. 11111111
    4. 00001001

{% folding green::答案 %}
**A**

已知：$[x]$的补码为反码+1，则$[x]$的原码就是$[x]$其补码减一取反。

$(10011000)_2 - (1)_2 = (10010111)_2$，取反码，得$(11101000)_2$
{% endfolding %}

4. 以下 C++代码中`p`的值是多少
    ```c++
    #include <iostream>
    using namespace std;
    int main() {
        int p;
        bool a = true;
        bool b = false;
        int x = 10;
        int y = 5;
        p = ((x | y) + (a + b));
        cout << p;
        return 0;
    }
    ```
    1. 0
    2. 16
    3. 12
    4. 2

{% folding green::答案 %}
**B**

先算`x|y`得`15`，再算`a+b`得`1`，所以`p=15+1=16`。
{% endfolding %}

# 选择题练习组7
本组共有4题，考察内容：栈

1. 按照"先进后出"原则组织数据的结构是。
    1. 队列
    2. 栈
    3. 双向链表
    4. 二叉树

{% folding green::答案 %}
**B**
{% endfolding %}

2. 设栈$A$的初始状态为空，现有 5 个元素组成的序列$a,b,c,d,e$，对该序列在$A$栈上依次进行如下操作：进栈、进栈、进栈、出栈、进栈、出栈、进栈。试问出栈的元素序列是
    1. c,d
    2. b,a
    3. b,c
    4. a,b,e

{% folding green::答案 %}
**A**

1. a进栈

$$\def\arraystretch{1.2}
\begin{array}{|c|}\hline
\textsf{栈顶} \\ \hline
\verb!a! \\ \hline
\end{array}
$$

2. b进栈
    $$\def\arraystretch{1.2}
    \begin{array}{|c|}\hline
    \textsf{栈顶} \\ \hline
    \verb!b! \\ \hline
    \verb!a! \\ \hline
    \end{array}
    $$

3. c进栈
    $$\def\arraystretch{1.2}
    \begin{array}{|c|}\hline
    \textsf{栈顶} \\ \hline
    \verb!c! \\ \hline
    \verb!b! \\ \hline
    \verb!a! \\ \hline
    \end{array}
    $$

4. 栈顶出栈
    $$\def\arraystretch{1.2}
    \begin{array}{|c|}\hline
    \textsf{栈顶} \\ \hline
    \verb!b! \\ \hline
    \verb!a! \\ \hline
    \end{array}
    $$
    出栈序列：$c$

5. d入栈
    $$\def\arraystretch{1.2}
    \begin{array}{|c|}\hline
    \textsf{栈顶} \\ \hline
    \verb!d! \\ \hline
    \verb!b! \\ \hline
    \verb!a! \\ \hline
    \end{array}
    $$

6. 栈顶出栈
    $$\def\arraystretch{1.2}
    \begin{array}{|c|}\hline
    \textsf{栈顶} \\ \hline
    \verb!b! \\ \hline
    \verb!a! \\ \hline
    \end{array}
    $$
    出栈序列：$c,d$

7. e入栈
    $$\def\arraystretch{1.2}
    \begin{array}{|c|}\hline
    \textsf{栈顶} \\ \hline
    \verb!e! \\ \hline
    \verb!b! \\ \hline
    \verb!a! \\ \hline
    \end{array}
    $$


{% endfolding %}

3. 有六个元素 FEDCBA 从左至右依次顺序进栈，在进栈过程中会有元素被弹出栈。问下列哪一个不可能是合法的出栈序列?
    1. EDCFAB
    2. DECABF
    3. CDFEBA
    4. BCDAEF

{% folding green::答案 %}
**C**
{% endfolding %}

4. 元素$R_1、R_2、R_3、R_4、R_5$入栈的顺序为$R_1、R_2、R_3、R_4、R_5$。如果第$1$个出栈的是$R_3$，那么第$5$个出栈的不可能是。
    1. $R_1$
    2. $R_2$
    3. $R_4$
    4. $R_5$

{% folding green::答案 %}
**B**
{% endfolding %}

# 选择题练习组8
本组共4题，内容：队列和栈

1. 是一种先进先出的线性表。
    1. 栈
    2. 队列
    3. 数组
    4. 链表

{% folding green::答案 %}
**B**
{% endfolding %}

2. 队列是一种逻辑数据结构，使用队列存储数据时，数据的存取特点是?
    1. 先进先出
    2. 队首进出
    3. 先进后出
    4. 队尾进出
 
{% folding green::答案 %}
**A**
{% endfolding %}

3. 一个栈的输入顺序为$1、2、3、4、5$,下列序列中不可能是栈的输出序列是
A.2 3 4 1 5
B.5 4 1 3 2
C.2 3 1 4 5
D.1 5 4 3 2

{% folding green::答案 %}
**B**
{% endfolding %}

4. $8$颗子弹，编号为$1,2,3,4,5,6,7,8$,从编号$1$开始按序嵌入弹夹，以下不是正常的打出子弹的次序的是。
    1. 12345678
    2. 87654321
    3. 32154876
    4. 32164587

{% folding green::答案 %}
**D**
{% endfolding %}

# 选择题练习组9
本组共4题

1. 表达式'6'-'1'的值是。
    1. 整数 5
    2. 字符 5
    3. 表达式不合法
    4. 字符 6

{% folding green::答案 %}
**A**

$'6' - '1' = '0' + 6 - ('0' + 1) = 6 - 1 = 5$
{% endfolding %}

2. 下列$4$个不同进制表示的数中，最大的数是。
    1. $(220.1)_{10}$
    2. $(11011011.1)_2$
    3. $(334.1)_8$
    4. $(DC.1)_{16}$

{% folding green::答案 %}
**C**
{% endfolding %}


3. 若已知一个栈的入栈顺序是$1，2，3，\dots, n$，其输出序列为$P_1，P_2，P_3，\dots, P_n$，若$P_1$是n，则 $P_i$是。
    1. i
    2. n-i
    3. n-i+1
    4. 不确定

{% folding green::答案 %}
**C**

由于第一个出栈的是$n$，则说明$n$出栈前所有元素已经入栈，此时的栈状态：
$$\def\arraystretch{1.2}
\begin{array}{|c|}\hline
\textsf{栈顶} \\ \hline
\verb!n! \\ \hline
\verb!...! \\ \hline
\verb!3! \\ \hline
\verb!2! \\ \hline
\verb!1! \\ \hline
\end{array}
$$

所以，无论按什么顺序出栈，都是从上往下依次出栈，$P_i=n-(i-1)=n-i+1$。
{% endfolding %}

4. 线性表若采用链表存储结构，要求内存中可用存储单元地址。
    1. 必须连续
    2. 部分地址必须连续
    3. 一定不连续
    4. 连续不连续均可

{% folding green::答案 %}
**D**
{% endfolding %}

# 选择题练习组10
本组共4题。

1. 如果一棵二叉树的中序遍历是 BAC，那么它的先序遍历不可能是。
    1. ABC
    2. CBA
    3. ACB
    4. BAC

{% folding green::答案 %}
**C**

中序遍历是：左、根、右，则二叉树有可能是:
![图例](/images/lanqiaoqs-1.png)

遍历为：

- (a): ABC
- (b): BAC
- (c): CBA
{% endfolding %}

2.给定一棵二叉树，其前序遍历结果为:ABDECFG，中序遍历结果为:DEBACFG。请问这棵树的正确后序遍历结果是什么?
    1. EDBGFCA
    2. EDGBFCA
    3. DEBGFCA
    4. DBEGFCA

{% folding green::答案 %}
**A**

由题意绘出二叉树：
![图例](/images/lanqiaoqs-2.png)

其后续遍历为：EDBGFCA
{% endfolding %}

3. 已知一棵二叉树有 10 个节点，则其中至多有( )个节点有 2 个子节点。
    1. 4
    2. 5
    3. 6
    4. 7

{% folding green::答案 %}
**A**

在完全二叉树中，若有$n$个节点，若$i*2+1>n$，则第$i$个节点没有右孩子。$i$最大等于$4$，最小等于$1$，所以至多有$4$个。
{% endfolding %}

4. 设只含根结点的二叉树高度为 1，共有 62 个结点的完全二叉树高度为
    1. 4
    2. 5
    3. 6
    4. 7

{% folding green::答案 %}
**A**

$log_2{62}<6$，所以有6层
{% endfolding %}