---
title: CSP-J日常测试(241004mor)
date: 2024-10-04 11:00:00
tags: C++
categories: 
    - [CSP,J,课程]
    - [考试,CSP,J]
excerpt: 排名、进制棋盘、除以7、卡牌
---

# 一、排名（rank）

## 题目描述
GameZ为他们最新推出的游戏开通了一个网站。世界各地的玩家都可以将自己的游戏得分上传到网站上。分数一上传，玩家就可以看到自己在世界上的排名。

排名规则是这样的：

规则1：得分越高，排名就越靠前；

规则2：得分相同的玩家排名相同；

规则3：任一玩家的排名等于比他分数高的人数+1。

由于新游戏的火爆，网站服务器已经难堪重负。为此GameZ雇用了你来帮他们重新开发一套排名系统。

## 输入格式
输入文件名：rank.in

第1行：一个整数N，表示上传得分的玩家数量。

第2行：N个用空格分隔的整数，按照玩家上传顺序依次给出第i个玩家的游戏得分。

## 输出格式
输出文件名：rank.out

输出N行：每行一个整数，其中第i行的整数表示第i个玩家在上传他的游戏得分时，他在已上传得分的i个玩家中的排名。

## 样例

### 样例输入 #1
```
5
300 500 500 400 200
```

### 样例输出 #1
```
1
1
1
3
5
```

## 题解

### 暴力
先写出暴力代码：

```c++
for(int i = 1; i <= n; i++) {
    cin >> a[i];
    int cnt = 0;
    for(int j = i; j >= 0; j--) {
        if(a[i] < a[j]) cnt++;
    }
    cout << cnt + 1 << endl;
}
```

时间复杂度为 $\operatorname{O}(n^2)$

### 重点：优化双重for循环的方法

1. 桶
2. 二分答案
3. 尺取法
4. 数据结构优化
5. 数学优化

### 正解
用桶优化
```c++
int cnt[501];
//...
for(int i = 1; i <= n; i++) {
    cin >> a[i];
    int c = 0;
    cnt[a[i]]++;
    for(int j = 500; j >= a[i]; j--) {
        c += cnt[a[j]];
    }
    cout << c + 1 << endl;
}
```

## 最终代码
```c++
#include <iostream>
using namespace std;

long long x, cnt[100001];

int main() {
    freopen("rank.in", "r", stdin);
    freopen("rank.out", "w", stdout);
    int n;
    cin >> n;
    for(int i = 1; i <= n; i++) {
        cin >> x;
        cnt[x]++;
        int c = 0;
        for(int j = 500; j > x; j--) {
            c += cnt[j];
        }
        cout << c + 1 << endl;
    }
    return 0;
}
```

# 二、进制棋盘（chess）

## 题目描述

馒小头很喜欢下棋，这天他突发奇想，对于一个十进制数字是可以转换成二进制的，在将这个二进制数字在前面补 $0$ 可以补充成一个 $36$ 位的二进制数字。

例如 $(1234567)_10=(000000000000000100101101011010000111)_2$

这组二进制数字由 $0$ 和 $1$ 组成，馒小头把 $0$ 看成白子，$1$ 看成黑子，可以按照从左到右从上到下的顺序填入到一个 $6 \times 6$ 的棋盘中：

```
○ ○ ○ ○ ○ ○
○ ○ ○ ○ ○ ○
○ ○ ○ ● ○ ○
● ○ ● ● ○ ●
○ ● ● ○ ● ○
○ ○ ○ ● ● ●
```


用数字表示就是：


```
000000
000000
000100
101101
011010
000111
```

现给你一个 $x$ 进制整数 $n$，请输出 $n$ 转换成二进制后的进制棋盘矩阵。

## 输入格式
输入文件名：`chess.in`

第一行两个空格隔开的整数 $x$ 和 $n$，表示 $x$ 进制下的正整数 $n$

## 输出格式
输出文件名：`chess.out`

共 $6$ 行 $6$ 列，表示 $n$ 转换成二进制后组成的进制棋盘矩阵

## 样例

### 样例输入 #1
``` 
10 1234567
```

### 样例输出 #1
```
000000
000000
000100
101101
011010
000111
```

### 样例输入 #2
```
5 123412
```

### 样例输出 #2
```
000000
000000
000000
000001
001011
111001
```

## 题解

纯纯模拟题啊。

分析一下题意，可以发现题意就是：将 $x$ 进制数 $n$ 转成二进制并以 $6 \times 6$ 的格式输出。

__步骤：__
1. 将 $n$ 转为十进制数
2. 将十进制数转为二进制数
3. 补齐前导零并输出

```c++
//in main():
    //x进制转十进制
    unsigned long long dec = stoull(n, 0, x);

    //十进制转二进制
    stack<int> bin;
    while(dec) {
        bin.push(dec % 2);
        dec /= 2;
    }

    //补齐36位
    while(bin.size() < 36) {
        bin.push(0);
    }

    //输出
    for(int i = 1; i <= 6; i++) {
        for(int j = 1; j <= 6; j++) {
            cout << bin.top();
            bin.pop();
        }
        cout << endl;
    }
```

### 最终代码
```c++
#include <bits/stdc++.h>
using namespace std;

int x; 
string n;

int main() {
    freopen("chess.in", "r", stdin);
    freopen("chess.out", "w", stdout);
    
    cin >> x >> n;

    unsigned long long dec = stoull(n, 0, x);

    stack<int> bin;
    while(dec) {
        bin.push(dec % 2);
        dec /= 2;
    }
    while(bin.size() < 36) {
        bin.push(0);
    }

    for(int i = 1; i <= 6; i++) {
        for(int j = 1; j <= 6; j++) {
            cout << bin.top();
            bin.pop();
        }
        cout << endl;
    }
    return 0;
}
```

# 三、除以7（div） 

## 题目描述
输入 $n$ 组数据，每组给出两个整数 $x$ 和 $k$，求 $x$ 除以 $7$ 的第 $k$ 位小数。

## 输入格式
输入文件：`div.in`

第一行输入一个正整数 $n$。

接下来n行，每行输入两个整数 $x$ 和 $k$。

## 输出格式
输出文件：`div.out`

输出一行 $n$ 个整数，每个整数表示对应输入的每一行中 $x$ 除以 $7$ 的第 $k$ 位小数，相邻两个整数之间以一个空格隔开。

## 样例

### 样例输入 #1：
```
6
1 1
1 2
1 3
1 4
1 5
1 6
```

### 样例输出 #1：
```
1 4 2 8 5 7
```

### 样例输入 #2：
```
6
2 1
2 2
2 3
2 4
2 5
2 6
```

### 样例输出 #2：
```
2 8 5 7 1 4
```

## 题解
通过分析，可以发现：

- $1 \div 7$的小数部分是：$0. \dot 14285 \dot 7$
- $2 \div 7$的小数部分是：$0. \dot 28571 \dot 4$
- $3 \div 7$的小数部分是：$0. \dot 42857 \dot 1$
- $4 \div 7$的小数部分是：$0. \dot 57142 \dot 8$
- $5 \div 7$的小数部分是：$0. \dot 71428 \dot 5$
- $6 \div 7$的小数部分是：$0. \dot 85714 \dot 2$
- $8 \div 7$的小数部分是：$0. \dot 14285 \dot 7$
- ...

即：
- 当$x \mod 7 \equiv 1$是，其小数部分是 $142857$ 循环。
- 当$x \mod 7 \equiv 2$是，其小数部分是 $285714$ 循环。
- 当$x \mod 7 \equiv 3$是，其小数部分是 $428571$ 循环。
- 当$x \mod 7 \equiv 4$是，其小数部分是 $571428$ 循环。
- 当$x \mod 7 \equiv 5$是，其小数部分是 $714285$ 循环。
- 当$x \mod 7 \equiv 6$是，其小数部分是 $857142$ 循环。

可以打表解决：
```c++
int _div[7][7] = { 
    {0,0,0,0,0,0},      //整除
    {7,1,4,2,8,5},      //142857
    {4,2,8,5,7,1},      //285714
    {1,4,2,8,5,7},      //...
    {8,5,7,1,4,2},
    {5,7,1,4,2,8},
    {2,8,5,7,1,4}
};
```

则 $x \div 7$ 的小数部分的第 $k$ 位为 `div[x%7][(k+5)%6]`

### 最终代码
```c++
#include <iostream>
using namespace std;

int _div[7][7] = { 
    {0,0,0,0,0,0},
    {7,1,4,2,8,5},
    {4,2,8,5,7,1},
    {1,4,2,8,5,7},
    {8,5,7,1,4,2},
    {5,7,1,4,2,8},
    {2,8,5,7,1,4}
};

int main() {
    freopen("div.in", "r", stdin);
    freopen("div.out", "w", stdout);
    
 
    unsigned long long n;
    scanf("%lld", &n);
    unsigned long long x, k;
    while(n--) {
        scanf("%lld %lld", &x, &k);
        cout << _div[x % 7][k % 6] << " ";
    }
    return 0;
}
```

# 四、卡牌（card）

## 题目描述
在一组有序数字中，位于中间的数字我们称为中位数；比如 $\{1,5,4,2,3\}$ 的中位数是 $3$ ，当序列中有偶数个数字时，我们采用中间两位数字的平均值当做中位数，比如序列 $\{1,2,3,5,6,7\}$ 的中位数是 $(3+5) \div 2$ 。我们常用中位数表示一组数据的一般水平。

pupu最近收集了 $n$ 张卡牌，每张卡牌上有一个整数表示当前卡牌的战力，pupu可以通过施展魔法提升卡牌战力，每次施展魔法可以提升或降低某张卡牌一单位战力，同时消耗一单位体力。注意魔法可以多次作用在同一张卡牌上。

pupu希望通过施展魔法尽可能的提高手中卡牌的一般水平，这样看起来更有威慑力。请你帮助pupu计算在有限的体力下，pupu能够获得的最大中位数大小！

## 输入格式
输入文件名：`card.in`

输入共两行：

第一行：输入两个空格分隔的整数，  $n$ 和 $c$，分别表示卡牌数量与初始体力值。

第二行：输入 $n$ 个空格分隔的数字，表示每张卡牌的战力。

## 输出格式
输出文件名：`card.out`

输出只有一行：输出一个整数，表示pupu能够获得的最大中位数。

## 样例

### 样例输入 #1：
```
3 2
1 3 5
```

### 样例输出 #1：
```
5
```

### 输入样例 #2：
```
5 5
1 2 1 1 1
```

### 样例输出 #2：
```
3
```

### 样例输入 #3：
```
7 7
4 1 2 4 3 4 4
```

### 样例输出 #3：
```
5
```

## 说明

### 数据范围：

对于 $30\%$的数据：$1 \leq n,c \leq 5,1 \leq 卡牌战力 \leq 10$,且 $n$一定是奇数。

对于 $100\%$ 的数据：$1 \leq n \leq 200000，1 \leq c \leq 10^9，1 \leq 卡牌战力 \leq 10^9$，且 $n$ 一定是奇数。

### 【耗时限制】
1000ms 

### 【内存限制】
256MB

## 题解

可以发现，中位数的范围是$1 \leq mid \leq 2 \times 10^9$。考虑二分答案。

```c++
int l = 1, r = 2000000001;  //[l, r)
while(l < r) {
    int mid = (l + r) >> 1;
    if(check(mid)) l = mid + 1; //左闭
    else r = mid;               //右开 
}
```

先将 $n$ 张卡牌的战力排序，保证有序。因为枚举的是中位数，所以只要使中位数右侧的所有数都大于等于它即可。

```c++
bool check(int mid) {
    long long cnt = 0;
    for(int i = (n + 1) / 2; i <= n; i++) {
        if(a[i] < mid) cnt += (mid - a[i]); //将右侧的数补到>=x
        else break;                     //因为原数组有序，右侧单调
    }
    return cnt <= k;
}
```

### 最终代码
```c++
#include <bits/stdc++.h>
using namespace std;

int n, k;
int a[200001];

bool check(int mid) {
    long long cnt = 0;
    for(int i = (n + 1) / 2; i <= n; i++) {
        if(a[i] < mid) cnt += (mid - a[i]); //将右侧的数补到>=x
        else break;                     //因为原数组有序，右侧单调
    }
    return cnt <= k;
}

int main() {
    cin >> n >> k;
    for(int i = 1; i <= n; i++) cin >> a[i];
    int l = 1, r = 2000000001;  //[l, r)
    while(l < r) {
        int mid = (l + r) >> 1;
        if(check(mid)) l = mid + 1; //左闭
        else r = mid;               //右开 
    }
    cout << l - 1;
    return 0;
}
```