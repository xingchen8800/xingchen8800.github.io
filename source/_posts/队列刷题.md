---
title: 队列刷题
date: 2024-11-21 22:14:53
tags:
    - C++
    - CSP提高组
    - 题解
---

## 题目列表

1. $\color{yellow}{普及/提高-}$
   - [扫描](https://www.luogu.com.cn/problem/P2032)
   - [求 $m$ 区间最小值](https://www.luogu.com.cn/problem/P1440)
2. $\color{green}{普及+/提高}$
   - [切蛋糕](https://www.luogu.com.cn/problem/P1714)
   - [好消息，坏消息](https://www.luogu.com.cn/problem/P2629)
   - [良好的感觉](https://www.luogu.com.cn/problem/P2422)
  
## 扫描

### 题目描述

有一个 $1 \times n$ 的矩阵，有 $n$ 个整数。

现在给你一个可以盖住连续 $k$ 个数的木板。

一开始木板盖住了矩阵的第 $1 \sim k$ 个数，每次将木板向右移动一个单位，直到右端与第 $n$ 个数重合。

每次移动前输出被覆盖住的数字中最大的数是多少。

### 输入格式

第一行两个整数 $n,k$，表示共有 $n$ 个数，木板可以盖住 $k$ 个数。

第二行 $n$ 个整数，表示矩阵中的元素。

### 输出格式

共 $n - k + 1$ 行，每行一个整数。

第 $i$ 行表示第 $i \sim i + k - 1$ 个数中最大值是多少。

### 样例 #1

#### 样例输入 #1

```
5 3
1 5 3 4 2
```

#### 样例输出 #1

```
5
5
4
```

### 提示

对于 $20\%$ 的数据，$1 \leq k \leq n \leq 10^3$。

对于 $50\%$ 的数据，$1 \leq k \leq n \leq 10^4$。

对于 $100\%$ 的数据，$1 \leq k \leq n \leq 2 \times 10^6$，矩阵中的元素大小不超过 $10^4$ 并且均为正整数。

### 题解

单调队列模板题，本题的操作是正常顺序，即：

- 维护单调
- 入队
- 维护长度
- 输出答案

```c++
#include <iostream>
#include <stdio.h>
#include <queue>
using namespace std;

const int N = 2 * 1000000 + 1;
int a[N], n, k;
deque<int> dq;

int main() {
    scanf("%d %d", &n, &k);
    for(int i = 1; i <= n; i++) 
        scanf("%d", &a[i]);
    for(int i = 1; i <= n; i++) {
        //维护队列单调
        while(!dq.empty() && a[dq.back()] <= a[i]) dq.pop_back();
        //入队
        dq.push_back(i);
        //维护队列长度（只能盖住k个数，区间长度为i-front+1）
        while(!dq.empty() && i - dq.front() + 1 > k) dq.pop_front();
		if(i >= k) printf("%d\n", a[dq.front()]);
    }
    return 0;
}
```

## 求m区间内的最小值

### 题目描述

一个含有 $n$ 项的数列，求出每一项前的 $m$ 个数到它这个区间内的最小值。若前面的数不足 $m$ 项则从第 $1$ 个数开始，若前面没有数则输出 $0$。

### 输入格式

第一行两个整数，分别表示 $n$，$m$。

第二行，$n$ 个正整数，为所给定的数列 $a_i$。

### 输出格式

$n$ 行，每行一个整数，第 $i$ 个数为序列中 $a_i$ 之前 $m$ 个数的最小值。

### 样例 #1

#### 样例输入 #1

```
6 2
7 8 1 4 3 2
```

#### 样例输出 #1

```
0
7
7
1
1
3
```

### 提示

对于 $100\%$ 的数据，保证 $1\le m\le n\le2\times10^6$，$1\le a_i\le3\times10^7$。

### 题解

本题要求的是`a[i]` __前__ $m$ 个元素的最小值，所以在模板的基础上要先维护长度并输出答案。

```c++
#include <iostream>
#include <stdio.h>
#include <queue>
using namespace std;

const int N = 2 * 1000000 + 1;
int a[N], n, m;
deque<int> dq;

int main() {
    scanf("%d %d", &n, &m);
    a[0] = 0;
    dq.push_back(0);
    for(int i = 1; i <= n; i++) {
        scanf("%d", &a[i]);
        //维护队列的长度是 <=m 的(在加入a[i]前)
        while(!dq.empty() && i - dq.front() > m) dq.pop_front();
        //输出答案
        printf("%d\n", a[dq.front()]);
        //删除0（辅助下标）
        if(dq.front() == 0) dq.pop_front();
        //维护队列的单调性
        while(!dq.empty() && a[dq.back()] >= a[i]) dq.pop_back();
        //入队
        dq.push_back(i);
    }
    return 0;
}
```

## 切蛋糕

### 题目描述

今天是小 Z 的生日，同学们为他带来了一块蛋糕。这块蛋糕是一个长方体，被用不同色彩分成了 $n$ 个相同的小块，每小块都有对应的幸运值。

小 Z 作为寿星，自然希望吃到的蛋糕的幸运值总和最大，但小 Z 最多又只能吃 $m(m\le n)$ 小块的蛋糕。

请你帮他从这 $n$ 小块中找出**连续**的 $k(1 \le k\le m)$ 块蛋糕，使得其上的总幸运值最大。

**形式化地**，在数列 $\{p_n\}$ 中，找出一个子段 $ [l,r] (r-l+1\le m)$，最大化 $\sum\limits_{i=l}^rp_i$。

### 输入格式

第一行两个整数 $n,m$。分别代表共有 $n$ 小块蛋糕，小 Z 最多只能吃 $m$ 小块。

第二行 $n$ 个整数，第 $i$ 个整数 $p_i$ 代表第 $i$ 小块蛋糕的幸运值。

### 输出格式

仅一行一个整数，即小 Z 能够得到的最大幸运值。

### 样例 #1

#### 样例输入 #1

```
5 2
1 2 3 4 5
```

#### 样例输出 #1

```
9
```

### 样例 #2

#### 样例输入 #2

```
6 3
1 -2 3 -4 5 -6
```

#### 样例输出 #2

```
5
```

### 提示

#### 数据规模与约定

- 对于 $20\%$ 的数据，有 $1\le n\le100$。
- 对于 $100\%$ 的数据，有 $1\le n\le5\times 10^5$，$|p_i|≤500$。

保证答案的绝对值在 $[0,2^{31}-1]$ 之内。

### 题解

题目翻译：

> 在数列 $\{p_n\}$ 中，找出一个子段 $ [l,r] (r-l+1\le m)$，最大化 $\sum\limits_{i=l}^rp_i$。

这不就是最大子段和问题，单调队列板子吗！不懂的见 [这篇](/2024/队列) 中的 “滑动窗口” 问题。

```c++
#include <iostream>
#include <deque>
using namespace std;

const int N = 5e5+1;
int p[N], n, k ;

int main() {
    cin >> n >> k;
    for(int i = 1; i <= n; i++) cin >> p[i];
    
    //前缀和
    p[0] = 0;
    for(int i = 2; i <= n; i++) p[i] += p[i-1];

    deque<int> q;
    int maxS = -1;
    q.push_back(0);
    for(int i = 1; i <= n; i++) {
        //1.维护队列长度（相当于i-(q.front()-1) >= k，其中q.front()是实际点的前一位，相当于普通的q.front()-1）
        while(!q.empty() && i - q.front() > k) q.pop_front();
        //2.计算答案
        maxS = max(maxS, p[i] - p[q.front()]);
        //3.维护队列单调
        while(!q.empty() && p[q.back()] > p[i]) q.pop_back();
        //4.入队
        q.push_back(i);
    }
    cout << maxS << endl;
    return 0;
}
```

## 好消息，坏消息

### 题目描述

Uim 在公司里面当秘书，现在有 $n$ 条消息要告知老板。每条消息有一个好坏度，这会影响老板的心情。告知完一条消息后，老板的心情等于老板之前的心情加上这条消息的好坏度。最开始老板的心情是 $0$，一旦老板心情到了 $0$ 以下就会勃然大怒，炒了 Uim 的鱿鱼。

Uim 为了不被炒，提前知道了这些消息（已经按时间的发生顺序进行了排列）的好坏度，希望知道如何才能不让老板发怒。

Uim 必须按照事件的发生顺序逐条将消息告知给老板。不过 Uim 可以使用一种叫 “倒叙” 的手法，例如有 $n$ 条消息，Uim 可以按 $k,k+1,k+2,\ldots,n,1,2,\ldots,k-1$（事件编号）这种顺序通报。

他希望知道，有多少个 $k$，可以使从 $k$ 号事件开始通报到 $n$ 号事件然后再从 $1$ 号事件通报到 $k-1$ 号事件可以让老板不发怒。

### 输入格式

第一行一个整数 $n$（$1 \le n \le10^6$），表示有 $n$ 个消息。

第二行 $n$ 个整数，按时间顺序给出第 $i$ 条消息的好坏度 $A_i$（$-10^3\le A_i \le 10^3$）。

### 输出格式

一行一个整数，表示可行的方案个数。

### 样例 #1

#### 样例输入 #1

```
4
-3 5 1 2
```

#### 样例输出 #1

```
2
```

### 提示

**【样例解释】**

通报事件的可行顺序（用编号表示）为 $2\rightarrow3\rightarrow4\rightarrow1$ 或 $3\rightarrow4\rightarrow1\rightarrow2$（分别对应 $k=2$ 和 $k=3$）

通报事件的可行顺序（用好坏度表示）为 $5\rightarrow1\rightarrow2\rightarrow(-3)$ 或 $1\rightarrow2\rightarrow(-3)\rightarrow5$

**【数据范围】**

对于 $25\%$ 的数据，$n\le10^3$；  
对于 $75\%$ 的数据，$n\le10^4$；  
对于 $100\%$ 的数据，$1 \le n\le 10^6$。

### 题解

{% note red fa-book %} 
本题需要用到的技巧：拆环为链、前缀和、单调队列
{% endnote %}

首先，要实现“倒叙”，就要将事件的好坏程度连成一个环，但是环上的操作极不便于运用单调队列，所以我们考虑将环“拆”开，即将原序列复制一份加入到后面。“拆”完后，样例为：`-3 5 1 2 -3 5 1 2`。这样，我们就可以像“窗口”一样在序列中直接选取连续区间。

“拆”环代码：

```c++
for(int i = 1; i <= n; i++) {
    cin >> p[i]; p[i + n] = i;
}
```

我们来分析什么时候老板会生气。

> 一旦老板心情到了 $0$ 以下就会勃然大怒

即“窗口”中事件的好坏度的和 $< 0$ 时，老板会生气。为了快速求和，我们可以使用前缀和，利用相减的方式 $\bf{O}(1)$ 地求出某刻老板的心情。即：一个叙述顺序如果不会使老板生气，当且仅当其中的前缀和最小值减去左端点的前一位的前缀和 $\ge 0$。前缀和后，样例为：`0 -3 2 3 5 2 7 8 10`。

计算前缀和代码：

```c++
p[0] = 0;
for(int i = 1; i <= 2 * n; i++) p[i] += p[i - 1];
```

例如我们框选：`-3 [5 1 2 -3] 5 1 2` 时，最小前缀和为 `0 [-3 2 3 5 2] 7 8 10`，$2-(-3)=5$，即从 $5$ 报到 $-3$，老板的心情为 $5$。在已知区间最小值的情况下，左端点为 $i - n + 1$，心情最小值为 $\min s_j - s_{i-n}$。

可是，直接找最小值太慢了，我们考虑使用单调队列解题。

单调队列找最小值代码：

```c++
deque<int> q;
int cnt = 0;
for(int i = 1; i <= 2 * n - 1; i++) {
    //维护单调性
    while(!q.empty() && p[q.back()] > p[i]) q.pop_back();
    //入队
    q.push_back(i);
    //维护长度
    while(!q.empty() && i - q.front() + 1 > n) q.pop_front();
    //计算答案（仅当长度满足时），q.front()代表区间前缀和最小值
    if(i >= n && p[q.front()] - p[i - n] >= 0) cnt++; 
}
```

[完整代码](https://www.luogu.com.cn/record/190435072)：

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 1;
int p[N * 2], n;

int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) {
        cin >> p[i];
        p[i+n] = p[i];
    }
    //求前缀和 
    p[0] = 0;
    for(int i = 2; i <= n * 2; i++) {
        p[i] += p[i - 1];   
	}
    deque<int> q;
	int cnt = 0;
	for(int i = 1; i <= 2 * n - 1; i++) {
	    //维护单调性
	    while(!q.empty() && p[q.back()] > p[i]) q.pop_back();
	    //入队
	    q.push_back(i);
	    //维护长度
	    while(i >= n && !q.empty() && i - q.front() + 1 > n) q.pop_front();
	    //计算答案（仅当长度满足时），q.front()代表区间前缀和最小值
	    if(i >= n && p[q.front()] - p[i - n] >= 0) cnt++; 
	}
    cout << cnt << endl;
    return 0;
}
```
