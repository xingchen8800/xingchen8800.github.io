---
title: 图的存储
date: 2024-08-21 09:05:20
categories:
    - [《算法竞赛》,第十章]
    - [CSP,CSP-S,非课程]
    - [数据结构,图]
excerpt: 图的主要存储方式：邻接矩阵、邻接表、链式前向星
tags: C++
---

# 邻接矩阵（视情况使用）
{% notel default fa-note 定义*Definetion* %}
邻接矩阵在C++中一般以 __二维数组__ 存储，直接用`graph[N][N]`存储有$N$个点的图。其中，`graph[i][j]`表示从边$i \rightarrow j$的权值（连通性，其值为`INF`时表示$i$与$j$之间没有连边。
{% endnotel %}
    
1. 对于 __无向图__：
    1. 对于无权图，`graph[i][j]`表示点$i$与点$j$的连通性，`1`为连通，`graph[i][j] = graph[j][i]`；
    2. 对于有权图，`graph[i][j]`表示从点$i$到$j$的双向边权值，`graph[i][j] = graph[j][i]`。
2. 对于 __有向图__：
    1. 对于无权图，`graph[i][j]`表示在点$i$与点$j$之间边$i \rightarrow j$的存在性，`1`表示存在边$i \rightarrow j$，`graph[i][j] != graph[j][i]`；
    2. 对于有权图，`graph[i][j]`表示在点$i$与点$j$之间边$i \rightarrow j$的权值，`graph[i][j] != graph[j][i]`

![示例图](/images/graph-1.png)

对于上图的邻接矩阵：
```c++
#define INF 0x3f3f3f3f

int graph[8][8] = 
{
    {INF, INF, INF, INF, INF, INF, INF, INF },
    {INF, 0, 1, INF, 1, INF, INF, INF},
    {INF, 1, 0, 1, INF, INF, INF, INF},
    {INF, INF, 1, 0, 1, INF, 1, 1},
    {INF, 1, INF, 1, 0, 1, INF, INF},
    {INF, INF, INF, INF, 1, 0, 1, INF},
    {INF, INF, INF, 1, INF, 1, 0, 1},
    {INF, INF, INF, 1, INF, INF, 1, 0},
};
```

{% note green fa-star %}
优点：①编程简单直接；②找边快速方便（$\mathbf{O}(1)$）；③适合稠密图。
{% endnote %}

{% note red fa-ban %}
缺点：①对于稀疏图浪费空间；②不能两点间连多条边。
{% endnote %}

# 邻接表（不建议使用）
```c++
struct Edge_t {
    int from, to, weight;   //起始节点，终点节点，权值
    Edge(int u, int v, int w) {
        from = u;
        to = v;
        weight = w;
    }
}

vector<Edge_t> edges[N];    //e[i]存储第i个节点链接的所有边

void Init() {
    for(int i = 1; i <= n; i++) edges[i].clear();
}

void AddEdge(int u, int v, int w) {
    //存当前边
    edges[u].push_back(Edge_t(u, v, w));
}

void Find(int u) {
    //遍历节点u的所有邻居
    for(edge : edges[u]) {
        int v = edge.to;
        int w = edge.w;
    }
}
```

{% note green fa-star %}
优点：①空间复杂度最优（$\mathbf{O}(m+n)$）；②能两点间连多条边。
{% endnote %}

{% note red fa-ban %}
缺点：查找邻接点麻烦。
{% endnote %}

# 链式前向星（推荐使用）
链式前向星在 __邻接表__ 的基础之上增加了`head[]`数组，其中`head[u]`表示$u$的一个邻边在`edges`数组中的下标。

链式前向星还更改了`Edge_t`，在`Edge_t`中新增了成员变量`next`，`next`表示$u$的下一个邻接点的位置。

```c++
//N个点，M条边
int head[N], cnt = 1;   //cnt表示当前edges数组的存储位置
typedef struct {
    int from, to, next, weight;
} Edge_t;
Edge_t edges[M];

void Init() {
    for(int i = 1; i <= N; i++) head[i] = -1;
    for(int i = 1; i <= M; i++) edges[i].next = -1;
    cnt = 1;
}

void AddEdge(int from, int to, int weight) {
    edges[cnt] = (Edge_t) { from, to, head[from], weight };
    head[from] = cnt++;
}

//遍历节点u的所有邻居
for(int i = head[u]; ~i/*i != -1*/; i = edges[i].next) {
    edge[i].to; //就是邻居
}
```