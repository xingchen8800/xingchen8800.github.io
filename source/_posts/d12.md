---
title: 提高组第十二天（线段树）
date: 2024-08-26 22:38:36
categories:
    - [CSP,CSP-S,课程]
    - [数据结构,图,树]
tags: 
    - C++
    - CSP提高组
---

{% notel default fa-pen 介绍 %}
![线段树例图](/images/d12-1.png)

线段树中，每个节点的左孩子区间为$[l,mid]$，右孩子区间为$[mid+1,r]$，自己的区间为$[l,r]$。

对于节点$k$，它的左孩子编号为$2k$（`k<<1`），右节点编号为$2k+1$，根节点为$1$（`k<<1|1`）。
{% endnotel %}

## 普通版加减线段树

### 存储方式

{% tabs d12-1 %}
<!-- tab 数组 -->
首先，由于采用数组存储完全二叉树，每个节点内只需要存储自己的 *左右边界* 、*区间和* 以及 *延时记录*（不被访问就不下放，节省时间）

```c++
struct Node {
    struct Range {
        int l, r;

        /**
         * @brief 默认构造函数
         */
        Range() : l(-114514), r(-114514) { }
        /**
         * @brief 带有区间的构造函数
         * @param _l 左边界
         * @param _r 右边界
         */
        Range(int _l, int _r) : l(_l), r(_r) { }

        /**
         * @brief 截取左区间[l,mid]
         * @param mid 左区间的右边界
         */
        Range GetLSubRange(int mid) const { return Range(l, mid); }
        /**
         * @brief 截取右区间[mid + 1, r]
         * @param mid 左区间的右边界，右区间的左边界-1
         */
        Range GetRSubRange(int mid) const { return Range(mid + 1, r); }
        /**
         * @brief 查看_range是否完美包含在this内
         * @param _range 要检查的区间
         */
        bool InMe(Range& _range) const { return l <= _range.l && r >= _range.r; }
        /**
         * @brief 获得区间包含的整数个数
         * @return 区间包含的整数个数
         */
        int GetNodeCount() const { return r - l + 1; }
        /**
         * @brief 获得区间的中点
         * @return 区间中点
         */
        int GetMid() const { return (l + r) / 2; }
    } _range;
    unsigned long long _sum;
    unsigned long long _add;
} tree[MAXN << 4];
```
<!-- endtab -->
<!-- tab 动态 -->
```c++
struct Node {
    struct Range {
        int l, r;

        /**
         * @brief 默认构造函数
         */
        Range() : l(-114514), r(-114514) { }
        /**
         * @brief 带有区间的构造函数
         * @param _l 左边界
         * @param _r 右边界
         */
        Range(int _l, int _r) : l(_l), r(_r) { }

        /**
         * @brief 截取左区间[l,mid]
         * @param mid 左区间的右边界
         */
        Range GetLSubRange(int mid) const { return Range(l, mid); }
        /**
         * @brief 截取右区间[mid + 1, r]
         * @param mid 左区间的右边界，右区间的左边界-1
         */
        Range GetRSubRange(int mid) const { return Range(mid + 1, r); }
        /**
         * @brief 查看_range是否完美包含在this内
         * @param _range 要检查的区间
         */
        bool InMe(Range& _range) const { return l <= _range.l && r >= _range.r; }
        /**
         * @brief 获得区间包含的整数个数
         * @return 区间包含的整数个数
         */
        int GetNodeCount() const { return r - l + 1; }
        /**
         * @brief 获得区间的中点
         * @return 区间中点
         */
        int GetMid() const { return (l + r) / 2; }
    } _range;
    unsigned long long _sum, _add;
    Node *_lson, *_rson;
}
```
<!-- endtab -->
{% endtabs %}

### 建树

由于线段树的性质，建树时采用先序遍历（*根、左、右*）的顺序（~~其实后序又不是不行~~）。

1. 先将区间信息赋给当前节点
2. 判断节点区间内是否只有一个节点，如果是的，就说明是叶子节点，其值就是原数组中的对应值。
3. 如果不是叶子节点，就将区间二分，分成左、右子树分段建树。
4. 建完左、右子树后计算当前节点的和。

{% folding 代码实现 %}

```c++
/**
 * @brief 在range区间内以code为根节点建树
 * @param code 当前节点的编号
 * @param range 建树的区间
 */
void BuildTree(int code, const Node::Range& range) {
    //初始化当前节点
    tree[code]._range.l = range.l;
    tree[code]._range.r = range.r;
    tree[code]._add = 0;
    if(range.l == range.r) {
        tree[code]._sum = a[range.l];  //叶子节点
        return;
    }
    //递归建树
    int mid = range.GetMid();               //二分中间节点
    BuildTree(code * 2, range.GetLSubRange(mid));           //建树左子树
    BuildTree(code * 2 + 1, range.GetRSubRange(mid));   //建树右子树
    tree[code]._sum = tree[code * 2]._sum + tree[code * 2 + 1]._sum;    //计算左右子树和
}
```

{% endfolding %}

### 区间修改

区间修改同样遵循 *根、左、右* 的顺序，递归修改。

1. 判断当前节点的区间是否完美包含在要修改的区间内，若是（如图1），说明当前节点的区间中所有的元素都要修改，当前节点的区间和加上`元素个数*修改值` ，将`修改值`记录进当前节点的`延时记录`，随后停止递归；
    ![图1](/images/d12-2.png)
2. 若当前节点的区间并不完全包含在要修改的区间内，下发延时记录，将当前节点的区间二分（递归左、右子节点），若左/右子节点在区间内，将左/右子节点作为当前节点执行步骤1。
    ![图2](/images/d12-3.png)
3. 更新自己的区间和。

{% folding 实现%}

```c++
/**
 * @brief 将节点code的_add分发给其子节点
 * @param code 表示节点的编号
 */
void Push(int code) {
    if(tree[code]._add) {   //有延时记录
        const int& add = tree[code]._add;
        tree[code * 2]._sum += tree[code * 2]._range.GetNodeCount() * add;  //记录更改
        tree[code * 2]._add += add;     //下发给左子树
        tree[code * 2 + 1]._sum += tree[code * 2 + 1]._range.GetNodeCount() * add;  //记录更改
        tree[code * 2 + 1]._add += add; //下发给右子树
        tree[code]._add = 0;
    }
}

/**
 * @brief 从code开始给range中的元素加上d
 * @param code 节点编号
 * @param range 区间
 * @param d 值
 */
void Add(int code, const Node::Range& range, int d) {
    if(range.InMe(tree[code]._range)) {  //完美包含在区间内
        //修改区间和
        tree[code]._sum += tree[code]._range.GetNodeCount() * d;
        //延时记录（子节点会形成延时记录堆叠，可以提高效率）
        tree[code]._add += d;
        return;
    }
    //分发延时记录
    Push(code);

    int mid = tree[code]._range.GetMid();   //二分
    //递归修改（没有被完美包含，构造完美包含）
    if(range.l <= mid) Add(code * 2, range, d);         //左区间有
    if(range.r > mid) Add(code * 2 + 1, range, d);      //右区间有
    //保存修改
    tree[code]._sum = tree[code * 2]._sum + tree[code * 2 + 1]._sum;
}
```

{% endfolding %}

### 区间查询

1. 先判断当前节点维护的区间是否被完美包含，如果是，就返回当前的区间和为上一层递归作返回值。
2. 若没有被完美包含，则下发延时记录，并分左、右子节点，递归计算左、右子节点（如果区间包含）的区间和，然后将其相加并返回。

{% folding 实现 %}

```c++
/**
 * @brief 以code为根节点算range区间值
 * @param code 根节点编号
 * @param range 区间
*/
int GetSum(int code, const Node::Range& range) {
    if(range.InMe(tree[code]._range)) { //完美包含
        return tree[code]._sum;
    }
    Push(code);    //将延时标记下发

    //构造完美包含
    int mid = tree[code]._range.GetMid(), ans = 0;
    if(range.l <= mid) ans += GetSum(code * 2, range);
    if(range.r > mid) ans += GetSum(code * 2 + 1, range);
    return ans;
}
```

{% endfolding %}

### 完整实现

<iframe src="//player.bilibili.com/player.html?bvid=BV1md4y1Z7vC" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"></iframe>

```c++
#include <bits/stdc++.h>
using namespace std;

const int maxn = 100010;
struct Node {
    struct Range{
        int l, r;

        Range() : l(-114514), r(-114514) { }
        Range(int _l, int _r) : l(_l), r(_r) { }

        Range GetLSubRange(int mid) const { return Range(l, mid); }
        Range GetRSubRange(int mid) const { return Range(mid + 1, r); }
        bool InMe(Range& _range) const { return l <= _range.l && r >= _range.r; }
        int GetNodeCount() const { return r - l + 1; }
        int GetMid() const { return l + ((r - l) >> 1); }
    } _range;   //左右边界
    unsigned long long _sum;    //区间和
    unsigned long long _add;    //延时标记：向上传递区间修改和查询
} tree[maxn << 4];

int n, m, a[maxn];

/**
 * @brief 在range区间内以code为根节点建树
 * @param code 当前节点的编号
 * @param range 建树的区间
 */
void BuildTree(int code, const Node::Range& range) {
    //初始化当前节点
    tree[code]._range.l = range.l;
    tree[code]._range.r = range.r;
    tree[code]._add = 0;
    if(range.l == range.r) {
        tree[code]._sum = a[range.l];  //叶子节点
        return;
    }
    //递归建树
    int mid = range.GetMid();               //二分中间节点
    BuildTree(code * 2, range.GetLSubRange(mid));           //建树左子树
    BuildTree(code * 2 + 1, range.GetRSubRange(mid));   //建树右子树
    tree[code]._sum = tree[code * 2]._sum + tree[code * 2 + 1]._sum;    //计算左右子树和
}

/**
 * @brief 将节点code的_add分发给其子节点
 * @param code 表示节点的编号
 */
void Push(int code) {
    if(tree[code]._add) {   //有延时记录
        const int& add = tree[code]._add;
        tree[code * 2]._sum += tree[code * 2]._range.GetNodeCount() * add;  //记录更改
        tree[code * 2]._add += add;     //下发给左子树
        tree[code * 2 + 1]._sum += tree[code * 2 + 1]._range.GetNodeCount() * add;  //记录更改
        tree[code * 2 + 1]._add += add; //下发给右子树
        tree[code]._add = 0;
    }
}

/**
 * @brief 从code开始给range中的元素加上d
 * @param code 节点编号
 * @param range 区间
 * @param d 值
 */
void Add(int code, const Node::Range& range, int d) {
    if(range.InMe(tree[code]._range)) {  //完美包含在区间内
        //修改区间和
        tree[code]._sum += tree[code]._range.GetNodeCount() * d;
        //延时记录（子节点会形成延时记录堆叠，可以提高效率）
        tree[code]._add += d;
        return;
    }
    //分发延时记录
    Push(code);

    int mid = tree[code]._range.GetMid();   //二分
    //递归修改（没有被完美包含，构造完美包含）
    if(range.l <= mid) Add(code * 2, range, d);         //左区间有
    if(range.r > mid) Add(code * 2 + 1, range, d);      //右区间有
    //保存修改
    tree[code]._sum = tree[code * 2]._sum + tree[code * 2 + 1]._sum;
}

/**
 * @brief 以code为根节点算range区间值
 * @param code 根节点编号
 * @param range 区间
*/
int GetSum(int code, const Node::Range& range) {
    if(range.InMe(tree[code]._range)) { //完美包含
        return tree[code]._sum;
    }
    Push(code);    //将延时标记下发

    //构造完美包含
    int mid = tree[code]._range.GetMid(), ans = 0;
    if(range.l <= mid) ans += GetSum(code * 2, range);
    if(range.r > mid) ans += GetSum(code * 2 + 1, range);
    return ans;
}

int main() {
    cin >> n;   //n个值
    for(int i = 1; i <= n; i++) cin >> a[i];
    BuildTree(1, Node::Range(1, n)); //1号根节点, 左边界为1，右边界为n
    cin >> m;   //m次操作
    while(m--) {
        int x, y, z;
        cin >> x >> y >> z;
        if(x == 1) {
            int d;
            cin >> d;
            Add(1, Node::Range(y, z), d);
        } else {
            cout << GetSum(1, Node::Range(y, z)) << endl;
        }
    }
    return 0;
}
```

### 通用简易代码

可以通过洛谷线段树模板题。

```c++
#include <bits/stdc++.h>
using namespace std;

const long long N = 100001;
struct Node {
    long long l, r, s, a;
} t[N << 4];
long long a[N], n;

void Build(long long c, long long l, long long r) {
    t[c] = {l, r, 0, 0};
    if(l == r) {
        t[c].s = a[l];
        return;
    }
    long long mid = (l + r) / 2;
    Build(c*2, l, mid);
    Build(c*2+1, mid + 1, r);
    t[c].s = t[c*2].s + t[c*2+1].s;
}

void Push(long long c) {
    if(!t[c].a) return;
    t[c*2].s += (t[c*2].r-t[c*2].l+1)*t[c].a, t[c*2].a += t[c].a;
    t[c*2+1].s += (t[c*2+1].r-t[c*2+1].l+1)*t[c].a, t[c*2+1].a += t[c].a;
    t[c].a = 0;
}

void Add(long long c, long long l, long long r, long long k) {
    if(t[c].l >= l && t[c].r <= r) {
        t[c].s += (t[c].r - t[c].l + 1) * k;
        t[c].a += k;
        return ;
    }
    Push(c);

    long long mid = (t[c].l + t[c].r) / 2;
    if(l <= mid) Add(c*2, l, r, k);
    if(r > mid) Add(c*2+1, l, r, k);
    t[c].s = t[c*2].s + t[c*2+1].s;
}

long long Query(long long c, long long l, long long r) {
    if(t[c].l >= l && t[c].r <= r) {
        return t[c].s;
    }
    Push(c);

    long long mid = (t[c].l + t[c].r) / 2, ret = 0;
    if(l <= mid) ret += Query(c*2, l, r);
    if(r > mid) ret += Query(c*2+1, l, r);
    return ret;
}

int main() {
    long long m;
    cin >> n >> m;
    for(long long i = 1; i <= n; i++) cin >> a[i];
    Build(1, 1, n);
    while(m--) {
        long long x, y, z, d;
        cin >> x >> y >> z;
        if(x == 1) {
            cin >> d;
            Add(1,y, z, d);
        } else cout << Query(1, y, z) << endl;
    }
    return 0;
}
```

## 进阶版乘法线段树

如果我们要将 $[l,r]$乘上 $k$，应该怎么办呢。如果只考虑乘法的话，问题会非常简单，只需要将区间和乘上 $k$即可;但是，如果乘法和加法同时进行应该怎么办呢？

首先，懒标记要从加法的一个懒标记变为两个（加法一个，乘法一个）。

<!--例如对于如下的区间：
$$
\{1,4,2,3\}
$$
1.先加后乘：
   - 我们先加上 $2$，变为： $\{3,6,4,5\}$;
   - 我们再乘上 $3$，变为： $\{9,18,12,15}$。
  
2.先乘后加：
   - 我们先乘上 $3$，变为： $\{3,12,6,9}$;
   - 我们再加上 $2$，变为： $\{5,14,8,11\}$。
可以发现结果截然不同，即： -->

加和乘的顺序会影响到值。那么，我们该怎样处理加法操作和乘法操作呢？显然，我们要先乘后加：

- 当不需要进行乘法时，直接行程区间加法，此时相当于乘了 $1$再行程加法;

- 当需要进行乘法时，如果乘法在加法前，我们显然应该乘上 $k$再行程加法;如果乘法在加法后，加法已经行程完了，显然应该直接乘上 $k$，仍然是先乘后加。

```c++
void Push(int c) {
    int add = t[c].add, mul = t[c].mul;
    t[c<<1].sum = (t[c<<1].sum * mul +(tree[c<<1].r - tree[c<<1].l + 1) * add) % MOD;//先乘后加
    t[c<<1| 1].sum = (t[c<<1| 1].sum * mul +(tree[c<<1| 1].r - tree[c<<1| 1].l + 1) * add) % MOD;//先乘后加
    //...
}
```

那么懒标记呢？同样地，懒标记也需要先乘后加：子区间的 $add$应当相等 $add$与当前区间的 $mul$的乘积与当前区间的 $mul$的和，子区间的 $mul$要乘上当前区间的 $mul$

```c++
void Push(int c) {
    //...
    t[c<<1].add = (t[c<<1].add * mul + mul) % MOD;//先乘后加
    t[c<<1| 1].add = (t[c<<1| 1].add * mul + mul) % MOD;//先乘后加
    t[c<<1].mul = (t[c<<1].mul * mul) % MOD;
    t[c<<1| 1].mul = (t[c<<1| 1].mul * mul) % MOD;
    //...
}
```

最后将当前区间的懒标记清空：
注意：乘法的懒标记应当置为 $1$，因为 $1$ 是乘法的单位元。

```c++
void Push(int c) {
    //...
    t[c].add = 0, t[c].mul = 1;
}
``` 

最后的完整代码：

```c++
#include <bits/stdc++.h>
using namespace std;

const long long N = 100001;
long long MOD;
struct Node {
    long long l, r, s, a, m;
} t[N << 4];
long long a[N], n, q;

void Build(long long c, long long l, long long r) {
    t[c] = {l, r, 0, 0, 1};
    if(l == r) {
        t[c].s = a[l] % MOD;
        return;
    }
    long long mid = (l + r) / 2;
    Build(c*2, l, mid);
    Build(c*2+1, mid + 1, r);
    t[c].s = (t[c*2].s + t[c*2+1].s) % MOD;
}


void Push(long long c) {
    long long add = t[c].a, mul = t[c].m;
    // 更新直属区间和
    t[c << 1].s = ((t[c << 1].s * mul + (t[c << 1].r - t[c << 1].l + 1) * add) % MOD + MOD) % MOD; // 先乘后加
    t[c << 1 | 1].s = ((t[c << 1 | 1].s * mul + (t[c << 1 | 1].r - t[c << 1 | 1].l + 1) * add) % MOD + MOD) % MOD; // 先乘后加
    // 更新懒标记
    t[c << 1].a = (t[c << 1].a * mul + add) % MOD; // 先乘后加
    t[c << 1 | 1].a = (t[c << 1 | 1].a * mul + add) % MOD; // 先乘后加
    t[c << 1].m = (t[c << 1].m * mul) % MOD; // 更新乘法懒标记
    t[c << 1 | 1].m = (t[c << 1 | 1].m * mul) % MOD; // 更新乘法懒标记
    // 懒标记置空
    t[c].a = 0; 
    t[c].m = 1; // 重置懒标记
}

void Add(long long c, long long l, long long r, long long k) {
    if(t[c].l >= l && t[c].r <= r) {
        t[c].s = (t[c].s + (t[c].r - t[c].l + 1) * k) % MOD;
        t[c].a = (t[c].a + k) % MOD;
        return ;
    }
    Push(c);

    long long mid = (t[c].l + t[c].r) / 2;
    if(l <= mid) Add(c*2, l, r, k);
    if(r > mid) Add(c*2+1, l, r, k);
    t[c].s = (t[c*2].s + t[c*2+1].s) % MOD;
}

void Mul(long long c, long long l, long long r, long long k) {
    if(t[c].l >= l && t[c].r <= r) {
        t[c].s = (t[c].s * k) % MOD;
        t[c].m = (t[c].m * k) % MOD;
        t[c].a = (t[c].a * k) % MOD;
        return ;
    }
    Push(c);

    long long mid = (t[c].l + t[c].r) / 2;
    if(l <= mid) Mul(c*2, l, r, k);
    if(r > mid) Mul(c*2+1, l, r, k);
    t[c].s = (t[c*2].s + t[c*2+1].s) % MOD;
}

long long Query(long long c, long long l, long long r) {
    if(t[c].l >= l && t[c].r <= r) {
        return t[c].s % MOD;
    }
    Push(c);

    long long mid = (t[c].l + t[c].r) / 2, ret = 0;
    if(l <= mid) ret = (ret + Query(c*2, l, r)) % MOD;
    if(r > mid) ret = (ret + Query(c*2+1, l, r)) % MOD;
    return ret % MOD;
}

int main() {
    cin >> n >> q >> MOD;
    for(long long i = 1; i <= n; i++) cin >> a[i];
    Build(1, 1, n);
    while(q--) {
        long long x, y, z, d;
        cin >> x >> y >> z;
        if(x == 1) {
            cin >> d;
            Mul(1, y, z, d);
        } else if(x == 2) {
            cin >> d;
            Add(1, y, z, d);
        } else if(x == 3) cout << Query(1, y, z) << endl;
    }
    return 0;
}
```

## 一阶段总结

写完了带有加法和乘法的线段树，相信你一定对线段树的拓展有一定的认识：

- 对于区间修改操作，我们可以按照新定义 `Mul()` 函数搭配新的懒标记来实现；
- 对于区间查询操作，我们可以新定义 `Query()` 函数来实现。

区间修改板子：

```c++
void /*某修改*/(int c, int l, int r, /*修改的值*/) {
    if(l <= t[c].l && t[c].r <= r) {
        /*维护t[c]的sum等区间属性*/
        /*维护t[c]的add、mul等懒标记*/
    }
    Push(c);
    ll mid = (l + r) / 2;
    if(l <= mid) /*某修改*/(c<<1, l, r, /*修改的值*/);
    if(r > mid) /*某修改*/(c<<1|1, l, r, /*修改的值*/);
    /*维护t[c]的sum等区间属性*/
}
```

区间查询的板子：

```c++
ll /*某查询*/(int c, int l, int r) {
    if(l <= t[c].l && t[c].r <= r) {
        return t[c]./*查询的区间属性*/
    }
    Push(c);
    ll mid = (l + r) / 2, ret = /*某初始值*/;
    if(l <= mid) ret = ret /*某种操作*/ /*某查询*/(c<<1, l, r);
    if(r > mid) ret = ret /*某种操作*/ /*某查询*/(c<<1|1, l, r);
    return ret;
}
```

例如我们要加入区间最大值和最小值的维护和查询，套用上面的板子：

```c++
// something you wrote
struct {
    /*...*/
    ll maxv, minv;
} t[N<<4];

void Push(int c) {
    //...
    t[c<<1].maxv = ((t[c<<1].maxv * mul) % MOD + add);
    t[c<<1].minv = ((t[c<<1].minv * mul) % MOD + add);
    t[c<<1|1].maxv = ((t[c<<1|1].maxv * mul) % MOD + add);
    t[c<<1|1].minv = ((t[c<<1|1].minv * mul) % MOD + add);
    //...
}

void Add(int c, int l, int r, int k) {
    if(/*...*/) {
        //...
        t[c].maxv = (t[c].maxv + k) % MOD;
        t[c].minv = (t[c].minv + k) % MOD;
        //...
    }
    //...
    t[c].maxv = max(t[c<<1].maxv, t[c<<1|1].maxv);
    t[c].minv = min(t[c<<1].minv, t[c<<1|1].minv);
    //更新t[c].sum...
}

void Mul(int c, int l, int r, int k) {
    if(/*...*/) {
        //...
        t[c].maxv = (t[c].maxv * k) % MOD;
        t[c].minv = (t[c].minv * k) % MOD;
        //...
    }
    //...
    t[c].maxv = max(t[c<<1].maxv, t[c<<1|1].maxv);
    t[c].minv = min(t[c<<1].minv, t[c<<1|1].minv);
    //更新t[c].sum...
}

ll QueryMaxValue(int c, int l, int r) {
    if(l <= t[c].l && t[c].r <= r) {
        return t[c].maxv;
    }
    Push(c);
    ll mid = (l + r) / 2, ret = 0;
    if(l <= mid) ret = max(ret, QueryMaxValue(c<<1, l, r));
    if(r > mid) ret = max(ret, QueryMaxValue(c<<1|1, l, r));
    return ret;
}

ll QueryMinValue(int c, int l, int r) {
    if(l <= t[c].l && t[c].r <= r) {
        return t[c].minv;
    }
    Push(c);
    ll mid = (l + r) / 2, ret = 0;
    if(l <= mid) ret = min(ret, QueryMinValue(c<<1, l, r));
    if(r > mid) ret = min(ret, QueryMinValue(c<<1|1, l, r));
    return ret;
}
```

现在应该有经验了吧。

如果我们嫌每个修改函数中维护 `t[c]` 属性的操作非常繁琐，我们可以加入一个 `Update()` 函数来处理这些：

```c++
void Update(int c, int add, int mul) {
    t[c].maxv = ((t[c].maxv * mul) % MOD + add);
    t[c].minv = ((t[c].minv * mul) % MOD + add);
    t[c].sum = ((t[c].sum * mul) % MOD + (t[c].r - t[c].l + 1) * mul) % MOD;
}
```

还可以加入 `PushUp()` 来将 `t[c]` 子节点的属性整合到 `t[c]` 上：

```c++
void PushUp(int c) {
    t[c].sum = (t[c<<1].sum + t[c<<1|1].sum) % MOD;
    t[c].maxv = max(t[c<<1].maxv, t[c<<1|1].maxv);
    t[c].minv = min(t[c<<1].minv, t[c<<1|1].minv);
}
```

{% notel red fa-book 总结 %}
线段树的大多数修改操作都可以通过改写后序遍历的函数结构的方式实现。
{% endnotel %}

## 后记

可持久化线段树、线段树的分裂与合并请见 [这篇](https://xingchen8800.github.io/2024/12/03/线段树2-0/)。
