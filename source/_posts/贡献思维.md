---
title: 贡献思维
date: 2024-11-02 10:41:27
tags:
---

# 枚举顺序和枚举贡献

## 枚举顺序

对于一个枚举：
$$\sum_{i=1}^{n}\sum_{j=1}^{m}{f(i,j)}$$

把关于 $i$ 的循环放到关于 $j$ 的循环内部，__结果不变__。

## 枚举贡献

对于一个枚举：
$$\sum_{i=1}^{n}\sum_{j=1}^{m}{f(i,j)g(i)h(j)}$$

像 $f, g, h$ 这种影响枚举的最终结果的因素都是这个枚举的 __贡献__。

像 $f$ 这种和 $i,j$ 都有关的贡献叫做 __复杂贡献__，我们要尽量将 __复杂贡献__

## 例题-简单的有限网格问题

对于一个 $n \times m$ 的网格，有 $k$ 颗星星，给定起点 $(x,y)$， 从起点开始的所有两折路径经过这 $k$ 颗星星多少次？

根据题意列出枚举：
$$
\sum_{所有两折路径} \sum_{某个两折路径经过的星星数}{1}
$$

根据 __枚举顺序__ 的法则，我们把两个循环的位置调换：
$$
\sum_{每个星星} \sum_{经过某个星星的所有两折路径}{1}
$$

{% note red fa-lightbulb %}
此处的 $1$ 就是每个路径对答案的 __枚举贡献__。
{% endnote %}

现在，我们只需要计算经过某个星星的所有两折路径数即可。

考虑如何计算经过某个星星的所有两折路径：

```c++
#include<iostream>
#include<cstring>
#include<cstdio>
using namespace std;

typedef long long ll;

namespace FastIO{
    const ll L=(1<<20);
    char buf[L],*S,*T;
    #ifdef ONLINE_JUDGE
    inline char getchar(){
        if(S==T){T=(S=buf)+fread(buf,1,L,stdin);if(S==T)return EOF;}
        return *S++;
    }
    #endif
    inline ll read(){
        ll s=0,f=1;char t=getchar();
        while('0'>t||t>'9') {if(t=='-')f=-1;t=getchar();}
        while('0'<=t&&t<='9') {s=(s<<1)+(s<<3)+t-'0';t=getchar();}
        return s*f;
    }
}
using FastIO::read;

const ll Mod=1e9+7;
ll n,m,k,x,y;

ll FastMul(ll a,ll b){
    ll ans=0;
    while(b){
        if(b&1)ans=(ans+a)%Mod;
        b>>=1;a=(a+a)%Mod;
    }
    return ans;
}

ll Count(ll a,ll b){
    ll ans=0;
    if(a<x&&b<y){
        ans=a+b;
    }
    if(a<x&&b>y){
        ans=a+(m-b+1);
    }
    if(a>x&&b<y){
        ans=(n-a+1)+b;
    }
    if(a>x&&b>y){
        ans=(n-a+1)+(m-b+1);
    }
    if(a<x&&b==y){
        ans=FastMul(n-a-1,a)+FastMul(a,n+m-2);
    }
    if(a>x&&b==y){
        ans=FastMul(a-2,n-a+1)+FastMul(n-a+1,n+m-2);
    }
    if(a==x&&b<y){
        ans=FastMul(m-b-1,b)+FastMul(b,n+m-2);
    }
    if(a==x&&b>y){
        ans=FastMul(b-2,m-b+1)+FastMul(m-b+1,n+m-2);
    }
    return ans%Mod;
}

int main(){
    n=read();m=read();k=read();
    x=read();y=read();

    ll ans=0;
    for(ll i=1;i<=k;i++){
        ll p=read();
        ll q=read();
        ans=(ans+Count(p,q))%Mod;
    }
    cout<<ans;
    return 0;
}
```

## 真题-[项链(necklace)](https://www.luogu.com.cn/problem/P10185)

```c++
#include <bits/stdc++.h>
using namespace std;

int n, a[100001], v[100001];
int sum = 0;

const int MOD = 1e9 + 7;

int fastPow(int a, int b) {
    int res = 1;
    while(b) {
        if(b & 1) res = (res * a) % MOD;
        a = (a * a) % MOD;
        b >>= 1;
    }
    return res;
}

int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) {
        cin >> a[i];
        sum += a[i];
    }
    for(int i = 1; i <= n; i++) cin >> v[i];

    int ans = 0;
    for(int i = 1; i <= n; i++) {
        long long val = fastPow(2, sum - a[i]) * (fastPow(v[i] + 1, a[i] - 1 + MOD) % MOD);
        ans = (ans + val) % MOD;
    }    
    cout << ans << endl;
    return 0;
}
```

## 真题-[括号(parentheses)](https://www.luogu.com.cn/problem/P7044)

```c++
#include <iostream>

using namespace std;

typedef long long ll;

const ll Mod = 1e9 + 7;
const ll N = 1000005;
ll n;
ll a[N], b[N];
ll L[N], R[N];
ll sm0[N], sm1[N];
ll sta[N], top;

void BruteForce() {
    ll ans = 0;
    for (ll l = 1; l <= n; l++) {
        for (ll r = l; r <= n; r++) {
            ll mn = 1e12;
            ll sm = 0;
            for (ll k = l; k <= r; k++) {
                mn = min(mn, a[k]);
                sm = (sm + b[k]) % Mod;
            }
            ans = (ans + mn * sm % Mod) % Mod;
        }
    }
    printf("%lld\n", ans);
}

void Solve() {
    ll ans = 0;
    top = 0;
    for (ll i = 1; i <= n; i++) {
        while (top && a[sta[top]] > a[i]) top--;
        L[i] = top ? sta[top] + 1 : 1;
        sta[++top] = i;
    }
    top = 0;
    for (ll i = n; i >= 1; i--) {
        while (top && a[sta[top]] >= a[i]) top--;
        R[i] = top ? sta[top] - 1 : n;
        sta[++top] = i;
    }
    for (ll i = 1; i <= n; i++) {
        sm0[i] = (sm0[i - 1] + b[i]) % Mod;
        sm1[i] = (sm1[i - 1] + b[i] * i % Mod) % Mod;
    }
    for (int i = 1; i <= n; i++) {
        ll ml0 = a[i] * (R[i] - i + 1) % Mod * (sm0[i - 1] - sm0[L[i] - 1]) % Mod * (-L[i] + 1) % Mod;
        ll ml1 = a[i] * (R[i] - i + 1) % Mod * (sm1[i - 1] - sm1[L[i] - 1]) % Mod;
        ll mr0 = a[i] * (i - L[i] + 1) % Mod * (sm0[R[i]] - sm0[i]) % Mod * (R[i] + 1) % Mod;
        ll mr1 = a[i] * (i - L[i] + 1) % Mod * (sm1[R[i]] - sm1[i]) % Mod * (-1);
        ans = (ans + ml0 + ml1 + mr0 + mr1) % Mod;
        ans = (ans + a[i] * b[i] % Mod * (R[i] - i + 1) % Mod * (i - L[i] + 1) % Mod) % Mod;
    }
    ans = (ans % Mod + Mod) % Mod;
    printf("%lld\n", ans);
}

int main() {
    scanf("%lld", &n);
    for (ll i = 1; i <= n; i++) scanf("%lld", &a[i]);
    for (ll i = 1; i <= n; i++) scanf("%lld", &b[i]);
    // BruteForce();
    Solve();
    return 0;
}
```