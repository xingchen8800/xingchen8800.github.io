---
title: 信奥集训测试241123
date: 2024-11-23 10:35:19
tags:
    - C++
    - 信奥集训
---

## [油滴扩散](https://www.luogu.com.cn/problem/P1378)

### 题目描述

在一个长方形框子里，最多有 $N$ 个相异的点，在其中任何一个点上放一个很小的油滴，那么这个油滴会一直扩展，直到接触到其他油滴或者框子的边界。必须等一个油滴扩展完毕才能放置下一个油滴。那么应该按照怎样的顺序在这 $N$ 个点上放置油滴，才能使放置完毕后所有油滴占据的总面积最大呢？（不同的油滴不会相互融合）

注：圆的面积公式 $S = \pi r^2$，其中 $r$ 为圆的半径。

### 输入格式

第一行，一个整数 $N$。

第二行，四个整数 $x, y, x', y'$，表示长方形边框一个顶点及其对角顶点的坐标。

接下来 $N$ 行，第 $i$ 行两个整数 $x_i, y_i$，表示盒子内第 $i$ 个点的坐标。

### 输出格式

一行，一个整数，长方形盒子剩余的最小空间（结果四舍五入输出）。

### 样例 #1

#### 样例输入 #1

```
2
20 0 10 10
13 3
17 7
```

#### 样例输出 #1

```
50
```

### 提示

对于 $100\%$ 的数据，$1 \le N \le 6$，坐标范围在 $[-1000, 1000]$ 内。

### 题解

由于题目中：

> 对于 $100\%$ 的数据，$1 \le N \le 6$，坐标范围在 $[-1000, 1000]$ 内。

$N$ 非常的小，所以考虑使用搜索来验证每一种方案，枚举方案的事件复杂度为 $\bf{O}(N!)$。

验证的过程就是单纯的模拟，对于每一个油滴：

- 取其各个方向的约束的最小值，即其距离上、下、左、右四个边界和其他扩散完的油滴的最小距离。

我们来考虑如何计算油滴与已扩散油滴的距离：

![](https://cdn.luogu.com.cn/upload/image_hosting/vhc2p3t0.png)

如图所示，有已经扩散的油滴 $U(x',y')$（扩散半径为 $r_U$） 和当前待扩散的油滴 $I(x,y)$，由勾股定理易得：线段 $IU$ 的长度为 $\sqrt{|x'-x|^2+|y'-y|^2}$。由圆的定义，易得：$UV=r_U$，所以 $IV=IU-UV=\sqrt{|x'-x|^2+|y'-y|^2}-r_U$。

现在，我们可以计算一个油滴的最大扩散半径了：

```c++
double minn = INT_MAX;
//向四边距离的最小值
minn = min(minn, abs(x[in[i]]-rx1));
minn = min(minn, abs(x[in[i]]-rx2));
minn = min(minn, abs(y[in[i]]-ry1));
minn = min(minn, abs(y[in[i]]-ry2));
//与其他油滴距离的最小值
for(int j = 1; j <= i; j++) {
    double IJ = sqrt(abs(x[in[j]] - x[in[i]]) * abs(x[in[j]] - x[in[i]]) + abs(y[in[j]] - y[in[i]]) * abs(y[in[j]] - y[in[i]]));
    double dis = IJ - r[in[j]];
    minn = min(minn, dis);
}
//记录
r[in[i]] = minn;
```

搜索的代码如下：

```c++
double maxS = -1;
bool vis[N] = {};
int in[N] = {};     //索引数组，in[i]表示再当前顺序下第i个元素的真实下标
void dfs(int i) {
    if(i == n + 1) {
        maxS = max(maxS, CalcS());
        return;
    }
    for(int j = 1; j <= n; j++) {
        if(vis[j]) continue;
        in[i] = j;
        vis[j] = true;
        dfs(i+1);
        vis[j] = false;
    }
}
```

完整代码：
```c++
//稍后再写
```

## [VUDU](https://www.luogu.com.cn/problem/P7868)

### 题目描述

年轻的 Mirko 最近一直在买 Voodoo 娃娃。因为他对最便宜的东西很感兴趣，所以他每天都在追踪 Voodoo 娃娃的价格。他已经得知了最近 $N$ 天的娃娃价格，第 $i$ 天的娃娃价格记为 $a_i$。

Mirko 认为，连续几天的娃娃平均价格与下一天的娃娃价格之间存在某种联系。他想验证自己的观点，却被一个问题难倒了：“对于一个给定的 $P$，在这 $N$ 天内有多少个不同的连续子序列令娃娃的平均价格大于或等于 $P$ ？”

两个连续子序列不同当且仅它们的开始位置或结束位置不同。

### 输入格式

第一行一个整数 $N$。

接下来一行有 $N$ 个整数，第 $i$ 个整数表示 $a_i$。

最后一行有一个整数 $P$。

### 输出格式

一行一个整数，表示在这 $N$ 天内有多少个不同的连续子序列令娃娃的平均价格大于或等于 $P$。

### 样例 #1

#### 样例输入 #1

```
3
1 2 3
3
```

#### 样例输出 #1

```
1
```

### 样例 #2

#### 样例输入 #2

```
3
1 3 2
2
```

#### 样例输出 #2

```
5
```

### 样例 #3

#### 样例输入 #3

```
3
1 3 2
3
```

#### 样例输出 #3

```
1
```

### 提示

**【样例 1 解释】**

平均数大于等于 `3` 的子序列只有 `3`。

**【样例 2 解释】**

平均数大于等于 `2` 的子序列有 `5` 个，它们是：

`1 3`

`1 3 2`

`3`

`3 2`

`2`

**【数据范围】**

对于 $30\%$ 的数据，$1\le N\le 10^4$；

对于 $100\%$ 的数据，$1\le N\le 10^6，1\le a_i\le 10^9，1\le P\le 10^9$。

**【说明】**

**本题数据点得分依原题，满分 140**。

题目译自 [COCI 2015-2016](https://hsin.hr/coci/archive/2015_2016/) [CONTEST #2](https://hsin.hr/coci/archive/2015_2016/contest2_tasks.pdf) **T5 VUDU**。

### 题解

题目翻译：有 $n$ 个整数 $a_1 \sim a_n$，求其中为多少个子序列的平均值 $\ge P$。

> 对于 $30\%$ 的数据，$1\le N\le 10^4$；

我们考虑先对价格数据做前缀和，这样就可以 $\bf{O}$$(1)$ 的时间复杂度计算区间价格和。

```c++
p[0] = 0;
for(int i = 1; i <= n; i++) {
    cin >> p[i];
    p[i] += p[i - 1];
}
```

我们考虑枚举每个区间的左端点 $l$ 和右端点 $r$，区间和为 $p_r - p_{l-1}$，区间元素数为 $r-l+1$，平均值为 $\frac{p_r-p_{l-1}}{r-l+1}$。即：当  $\frac{p_r-p_{l-1}}{r-l+1} \ge P$ 时，$[l,r]$ 是一个符合条件的子序列。

```c++
int cnt = 0;
for(int l = 1; l <= n; l++) 
    for(int r = l; r <= n; r++) 
        if((p[r] - p[l - 1]) / (r - l + 1) >= P) cnt++;
```

> 对于 $100\%$ 的数据，$1\le N\le 10^6，1\le a_i\le 10^9，1\le P\le 10^9$。

由于求子序列平均值的时间复杂度已经最低，考虑把双重循环优化成单层循环。

我们考虑对 $\frac{p_r-p_{l-1}}{r-l+1} \ge P$ 进行变形，将 $r$ 和 $l$ 分到不等式的两边：

$$
p_r-p_{l-1} \ge rP - (l -  1)P
$$

将所有带 $r$ 的移到左边，带 $l$ 的移到右边

$$
p_r - rP \ge p_{l-1} - (l-1)P
$$

神奇的是：左边和右边都是 $p_x - xP$ 的形式，我们不妨设 $b_x = p_x - xP$，将 $b_0 \sim b_n$ 进行预处理。由于 $n \ge r \ge l \ge 1$，所以问题转化成求 $b_0 \sim b_n$ 中的 **顺序对** 数。

顺序对的求法其实和 **逆序对** 的求法差不多，都可以使用 **树状数组** + **离散化** 的方法进行求解，详情见 [这篇](https://xingchen8800.github.io/2024/10/18/速通信息学奥赛一本通2) 中的逆序对求法。其中，树状数组中存的每个数对应比其下标靠前，值大的元素个数。求顺序对则相反，树状数组中存的每个数对应比其下标靠前，值小的元素个数，所以需要按照升序排序。

```c++
#include <bits/stdc++.h>
using namespace std;

const int N = 1e6 + 2;
long long p[N], n, P, b[N], t[N];

//维护树状数组
int lowbit(int i) { return i & (-i); }

long long query(int x) {
    long long ret = 0;
    while(x >= 1) {
        ret += t[x];
        x -= lowbit(x);
    }
    return ret;
}

void add(int i) {
    while(i <= n + 1) {
        t[i]++;
        i += lowbit(i);
    }
}

//离散化排序
long long rk[N];
bool cmp(int x, int y) {
    if(b[x] == b[y]) return x < y;  //相同元素按下标靠左
    return b[x] < b[y];             //升序排序
}

int main() {
    //输入部分
    cin >> n;
    p[0] = 0;
    for(int i = 1; i <= n; i++) {
        cin >> p[i];
        p[i] += p[i-1];
        rk[i] = i;
    }
    cin >> P;
    //处理b数组（注意，下标从0开始，因为l<=1，l-1<=0）
    b[0] = 0;
    for(int i = 1; i <= n; i++) {
        b[i] = p[i] - i * P;
    }
    //离散化（注意，下标从0开始，因为l<=1，l-1<=0）
    rk[0] = 0;
    sort(rk, rk + n + 1, cmp);
    
    long long ans = 0;
    for(int i = 0; i <= n; i++) {
        //P.S. 此处的下标偏移一位，不能为0
        //先求左侧已经标记的比b[rk[i]]小的数的个数，就是顺序对数
        ans += query(rk[i] + 1);
        //标记b[rk[i]]已经出现
        add(rk[i] + 1);
    }
    cout << ans << endl;
    return 0;
}
```
