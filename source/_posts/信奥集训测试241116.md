---
title: 信奥集训测试241116
date: 2024-11-16 10:42:15
tags:
    - C++
    - CSP
---

{% notel red fa-book 注意事项 %}

`double` 使用时的注意事项：尽量不要使用`x==0`来判断其是否为 $0$。

我们可以定义一个`eps`作为误差，一般为`1e-7`，写一个判断函数：
```c++
const double eps = 1e-7;
int dcmp(double x) {
    if(x > eps) return 1;
    else return (x < -eps ? -1: 0);
}
```
{% endnotel %}

# T1. [结算日](https://www.luogu.com.cn/problem/P1599)

## $30pts$

对于 $30\%$ 的数据：$N \leq 6$

我们只需要搜索即可：走到每个奶牛，我们可以

- __收钱__
  - 向前
  - 向后
- __还钱__
  - 向前
  - 向后

时间复杂度：$O(2^n)$

## $100pts$

使用贪心算法，对于能收钱的牛就收，能还的就还；还不了的记上，以后能还了立刻还。

```c++
#include <iostream>
using namespace std;

const int N = 100001;
int n, d[N];
int main() {
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> d[i];

    int money = 0, pos = 0, dis = 0;    //有money元钱，最早在pos处负债，走了dis步
    for(int i = 1; i <= n; i++) {
        money += d[i];                  //先收钱/还钱
        if(money >= 0 && pos > 0) {     //当当前的钱不负债，就相当于还清了
            dis += (i - pos) * 2;      //从i走到pos再走回来
            pos = 0;
        } else if(money < 0 && pos == 0) {  //负债了
            pos = i;                        //标记在i处负债(不一定在还不起的那一刻标记)
                                            //因为回去还更前面的可以顺便还
        }
        dis++;                          //向前走
    }
    cout << dis << endl;
    return 0;
}
```

# T2. [进行一个拆的解](https://www.luogu.com.cn/problem/P9492)

## $10pts$

$a_i = 0$，全是 $NO$

## $30pts$

暴力检验

## $100pts$

我们考虑如何判断两个子序列 $A,B$ 是否为对方的子序列。显然：

- 若 $A$ 是 $B$ 的子序列，若将拆分点前移（$A$ 缩短、$B$ 增长），$A'$ 仍然是 $B$ 的子序列
- 若 $B$ 是 $A$ 的子序列，若将拆分点后移（$A$ 缩长、$B$ 缩短），$B'$ 仍然是 $A$ 的子序列

题目中给了提示：
> Subtask 2（30 points）：$n$ 为偶数。

自然地想到取中点 $\frac{n}{2}$。如果前一半和后一半相等，那么根据前面的推论，无论拆分点怎样移动，总有一个子序列 __是__ 另一个子序列的 __子序列__ 。

我们只需要判断 $[1,\frac{n}{2}]$ 和 $[\frac{n}{2} + 1, n]$ 是否相等就行了。如果相等就输出 $NO$，否则输出 $YES$。

当 $n$ 为奇数时：

我们分别判断 $\frac{n}{2}$ 向下取整时左区间是否是右区间的子区间和向上取整时右区间是否是左区间的子区间，如果都成立，就输出 $NO$，否则为 $YES$。

```c++
#include <iostream>
using namespace std;

const int N = 1e5 + 1;
int n, a[N];

//两步判断 [1, mid] 是否是 [mid+1, n] 的子序列
bool check(int offset = 0) {
    int mid = (n - 1) / 2;
    bool flag = true; 
    for(int i = 1; i <= mid; i++) {
        if(a[i] != a[i + mid + offset]) flag = false;
    }
    return flag;
} 

//两步判断 [mid + 1, n] 是否是 [1, mid] 的子序列
bool check1(int offset = 0) {
    bool flag = true;
    int mid = (n + 1) / 2;
    for(int i = mid + 1; i <= n; i++) { 
        if(a[i] != a[i - mid + offset]) flag = false;
    }
    return flag;
}

void Solve() {
    cin >> n;
    for(int i = 1; i <= n; i++) cin >> a[i];
    
    if(n % 2) {
        bool f1 = check(0) || check(1);         //左区间是右区间的子区间（向下取整）
        bool f2 = check1(0) || check1(1);       //右区间是左区间的子区间（向上取整）
        bool flag = f1 && f2;
        if(!flag) cout << "YES\n";
        else cout << "NO\n";
    } else {
        int mid = n / 2;
        bool flag = true;
        for(int i = 1; i <= mid; i++) {
            if(a[i] != a[i + mid]) flag = false;
        }
        if(!flag) cout << "YES\n";
        else cout << "NO\n";
    }
}

int main() {
    int t;
    cin >> t;
    while(t--) Solve();
    return 0;
}
```

# T3. [$n$ 元一次方程组](https://www.luogu.com.cn/problem/P2455)

## $80pts$

我们考虑使用 __高斯消元__ 来解决。

## $100pts$

我们需要在 __高斯消元__ 之前做一些特判。

```c++

#include <iostream>
#include <cstring>
#include <cstdio>
#include <map>
using namespace std;

// 快速读入
namespace FastIO {
    inline int read() {
        int s = 0, f = 1; // s为读取的数字，f为符号（1或-1）
        char t = getchar(); // 读取字符
        // 跳过非数字字符
        while ('0' > t || t > '9') {
            if (t == '-') f = -1; // 处理负号
            t = getchar(); // 继续读取
        }
        // 读取数字
        while ('0' <= t && t <= '9') {
            s = (s << 1) + (s << 3) + t - '0'; // 将字符转换为数字
            t = getchar(); // 继续读取
        }
        return s * f; // 返回最终的数字
    }
}
using FastIO::read;

const int N = 105; // 最大方程个数
const double eps = 1e-7; // 浮点数比较的精度
double A[N][N], X[N];  // A为增广矩阵，X为解
int n;  // 方程个数

// 判断浮点数与0的关系
double dcmp(double x) {
    if (x > eps) return 1; // x大于eps，返回1
    return x < -eps ? -1 : 0; // x小于-eps，返回-1，否则返回0
}

// 判断两个浮点数是否相等
bool equal(double a, double b) {
    return dcmp(a - b) == 0; // 如果a与b的差值接近于0，则认为相等
}

// 判断方程组是否无解
/*
如果某一行都是0，且等号右边不为0，则无解
*/
bool noSolution() {
    for (int i = 1; i <= n; i++) { // 遍历每个方程
        bool allZero = true; // 假设当前行全为0
        for (int j = 1; j <= n; j++) { // 检查当前行的系数
            if (dcmp(A[i][j]) != 0) { // 如果有非零系数
                allZero = false; // 当前行不是全零
                break; // 退出内层循环
            }
        }
        // 如果当前行全为0且等号右边不为0，则无解
        if (allZero && dcmp(A[i][n + 1])) return true;
    }
    return false; // 否则有解
}

// 高斯消元
void Gauss() {
    int r = 0; // 当前行数
    for (int i = 1; i <= n; i++) { // 遍历每一列
        int pos = -1; // 找到非零元素的行
        for (int j = r + 1; j <= n; j++) { // 从当前行的下一行开始查找
            if (dcmp(A[j][i]) != 0) { // 找到非零元素
                pos = j; // 记录该行
                break; // 退出循环
            }
        }

        if (pos == -1) continue; // 如果该列全为零，继续下一列
        swap(A[pos], A[++r]);  // 将找到的非零行与当前行交换，保证第r个方程的第i列系数是非0的
        
        // 用第r个方程对第r+1~n个方程做消元
        for (int j = r + 1; j <= n; j++) {
            double c = A[j][i] / A[r][i]; // 计算消元系数
            for (int k = i; k <= n + 1; k++) { // 更新当前行
                A[j][k] -= A[r][k] * c; // 消去第j行的第i列
            }
        }
    }

    // 检查是否为非标准阶梯
    if (r < n) {  
        if (noSolution()) cout << "-1\n"; // 无解
        else cout << "0\n"; // 有无穷多解
        return;
    }
    
    // 标准倒三角阶梯，从后往前回代
    for (int i = n; i >= 1; i--) {
        for (int j = i + 1; j <= n; j++) {
            A[i][n + 1] -= X[j] * A[i][j]; // 更新增广矩阵
        }
        X[i] = A[i][n + 1] / A[i][i]; // 计算当前变量的值
    }
    
    // 输出结果
    for (int i = 1; i <= n; i++) {
        printf("x%d=%.2lf\n", i, X[i]); // 输出每个变量的值
    }
}

int main() {
    n = read(); // 读取方程个数
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= n + 1; j++) {
            A[i][j] = read(); // 读取增广矩阵
        }
    }
    Gauss(); // 调用高斯消元函数
    return 0;
}
```
