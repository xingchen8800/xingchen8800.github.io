---
title: 蓝桥青少2024中级组模拟-1
date: 2024-08-24 20:24:09
categories:
    - [蓝桥杯,蓝桥青少]
    - [数据结构,C++语言基础,指针]
tags: 
    - C++
    - 蓝桥杯省赛
---

# 第一部分、[子卷]选择题

1. 下列C++语句执行以后结果是`true`的是( )。
    1. `3&&false`
    2. `5&&2`
    3. `101&&000`
    4. `4&true`

{% folding green::答案 %}
**B**

在C++中，除了$0$为`false`外其他都是`true`，B选项中$5$等价于`true`，$2$也等价于`true`，`true && true = true`。
{% endfolding %}

2. $n$是一个三位数，那n的十位数为（ ）
    1. `(n%10)/10`
    2. `(n/100)%10`
    3. `(n/100)%100`
    4. `(n%100)/10`

{% folding green::答案 %}
**D**

设$n=100x+10y+z$，则$10y+z=n \mod 100$，$10y = n \mod 100 - z$，因为$z<10$，所以编译器会将$z$忽略，$10y = n \mod 100$，$y = n \mod 100 \div 10$。
{% endfolding %}

3. 如果$n$为`int`类型的变量，一个指针变量定义为`int *p=&n;`，则下列说法正确的是( )。
    1. 指针变量`p`的值与变量$n$是相同的。
    2. 指针变量`p`的值与变量$n$的地址是相同的。
    3. 指针变量`p`指向的值为$n$。
    4. 指针变量`p`指向的值与变量$n$的地址是相同的。

{% folding green::答案 %}
**B**
{% endfolding %}

4. 一个字长为8位的整数的补码是$(11111001)_2$，则它的原码是( )。
    1. $(00000111)_2$
    2. $(01111001)_2$
    3. $(11111001)_2$
    4. $(10000111)_2$

{% folding green::答案 %}
**D**

负数的`补码=反码+1`，则`反码=补码-1`，$(11111001)_2-(1)_2=(11111000)_2$，`原码=反码取反`$=(10000111)_2$
{% endfolding %}

# 第二部分、[子卷]编程题

## 1. 拉线开关

### 【问题描述】
小蓝家的灯是拉线式开关的，拉一次灯开，再拉一次灯关，未拉之前灯是熄灭状态。输入一个正整数$M(1 < M < 100)$，作为小蓝拉动开关的次数，判断拉动$M$次后，灯是点亮状态还是熄灭状态。

### 【输入描述】
输入一个正整数$M$作为拉动开关的次数 $(1<M<100)$

### 【输出描述】
如果灯是点亮状态输出整数“1”，如果灯是熄灭状态输出整数“0”。

{% folding green::答案 %}
```c++
#include <iostream>
using namespace std;

int main() {
    int M;
    cin >> M;
    cout << M % 2;
    return 0;
}
```
{% endfolding %}

## 2.推算

### 【问题描述】
小蓝是一名计算机极客，他在记录一些重要的日子时从不注明年月日，而是用一个整
数替代，比如$4532$，后来人们知道，那个整数就是日期，这个整数表示的日期就是
他出生后的第几天。

他出生于：1999-04-30。

例如他的日记里记录着获得蓝桥杯国赛总冠军的日子为`7856`这个整数，可以推断出
这一天是 2020-10-31，现在需要请你计算出小蓝日记中其他整数对应的日期。
注意：输出的日期格式：`yyyy-mm-dd`，如：2020-03-21（月和日小于$10$的需要在
月和日前补$0$）。

### 【输入描述】
输入一个整数 $n(5<n<30000)$ 作为日记中记录的整数，输出这个整数对应的日期
（注：按日期格式输出）。

例如：1999-04-30 为第$1$天，1999-05-01 为第$2$天。

### 【输出描述】
输出这个整数对应的日期

### 【样例输入】
```
10
```

### 【样例输出】
```
1999-05-09
```

{% folding green::答案 %}
```c++
#include <bits/stdc++.h>
using namespace std;

const int months[] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};

bool RunYear(int x, int m) {
    if(m != 2) return 0;
    return x % 400 == 0 || (x % 4 == 0 && x % 100 != 0);
}

int main() {
    int n;
    cin >> n;
    n--;
    int nowYear = 1999, nowMonth = 5;       //n>5
    while(true) {
        if(n < months[nowMonth] + RunYear(nowYear, nowMonth)) { //n是天
            break;
        }
        n -= months[nowMonth] + RunYear(nowYear, nowMonth++);   //过了一个月
        if(nowMonth == 13) {        //过了一年
            nowMonth = 1;
            nowYear++;
        }
    }
    cout << nowYear << '-' << (nowMonth < 10 ? "0" : "") << nowMonth << '-' << (n < 10 ? "0" : "") << n << endl;
}
```
{% endfolding %}

## 3. 后缀表达式加强版

### 【问题描述】
给定$N$个加号、$M$个减号以及$N+M+1$个整数$A_1,A_2,\dots,A_{N+M+1}$，小明想知道在所有由这$N$个加号、$M$个减号以及$N+M+1$个整数凑出的合法的后缀表达式中，结果最大的哪一个？请你输出最大的结果。

例如使用 1 2 3 + -，则“2 3 + 1 -”这个后缀表达式结果是$4$，是最大的。

### 【输入描述】
第一行包含两个整数$N$和$M$。$1≤N,M≤100000$

第二行包含$N+M+1$个整数 $A_1，A_2, \dots, A_{N+M+1}(-10^9 \leq A_N \leq 10^9$

### 【输出描述】
输出一个整数，代表答案。

### 【样例输入】
```
1 1
1 2 3
```

### 【样例输出】
```
4
```

{% folding green::答案 %}
```c++
#include <bits/stdc++.h>
using namespace std;

int n, m;
int a[2000010];

int main() {
    cin >> n >> m;
    for(int i = 1; i <= n + m + 1; i++) {
        cin >> a[i];
    }
    sort(a + 1, a + n + m + 2);

    unsigned long long sum = a[n + m + 1] - a[1];
    for(int i = 2; i <= n + m; i++) {
        sum += abs(a[i]);
    }
    cout << sum;
    return 0;
}
```
{% endfolding %}

## 4. 旋转

### 【问题描述】
图片旋转是对图片的处理方式之一，在本题中你需要对图片顺时针旋转 90 度。我们用一个 n×m 的二维数组来表示一个图片，例如下面给出一个 3×4 的图片的例子：
```
1 3 5 7
9 8 7 6
3 5 9 7
```
这个图片顺时针旋转 90 度后的图片如下：
```
3 9 1
5 8 3
9 7 5
7 6 7
```
给定初始图片，请计算旋转后的图片

### 【输入描述】
输入的第一行包含两个整数 n 和 m，分别表示行数和列数。

接下来 n 行，每行 m 个整数，表示给定的图片。图片中的每个元素（像素）为一个值为 0~255 之间的整数（包含 0 和 255）。

### 【输出描述】
输出 m 行 n 列，表示旋转后的图片。

### 【样例输入】
```
3 4
1 3 5 7
9 8 7 6
3 5 9 7
```

### 【样例输出】
```
3 9 1
5 8 3
9 7 5
7 6 7
```

### 【测评用例规模与约定】

对于 30%的测评用例，1≤n,m≤10。

对于 60%的测评用例，1≤n,m≤30。

对于所有测评用例，1≤n,m≤100。

{% folding green::答案 %}
```c++
#include <iostream>
using namespace std;

int n, m;
int a[101][101], b[101][101];

int main() {
    cin >> n >> m;
    for(int i = 1; i <= n; i++) {
        for(int j = 1; j <= m; j++) cin >> a[i][j];
    }

    for(int i = n; i >= 1; i--) {
        for(int j = 1; j <= m; j++) {
            b[j][n - i + 1] = a[i][j];
        }
    }

    for(int i = 1; i <= m; i++) {
        for(int j = 1; j <= n; j++) cout << b[i][j] << " ";
        cout << endl;
    }
    return 0;
}
```
{% endfolding %}


## 5.城市交通

### 【问题描述】
有 n 个城市，编号 1~n，有些城市之间有路相连，有些则没有，有路则会有一个距离。例如下图所示为一个含有 11 个城市的交通图，连线上的数表示距离。现在规定只能从编号小的城市到编号大的城市。请问从编号为 1 的城市到编号为 n 的城市之间的最短距离是多少？
![图例](/images/lanqiaoqs-3.png)

### 【输入描述】
第一行为整数 n，表示城市数，（1<n≤100）

接下来 n 行是一个 n×n 的邻接矩阵 map[i,j]，其中 map[i,j]=0，表示城市 i 和 j 之间

没有路相连，否则为两者之间的距离，1≤两个城市之间的距离≤1000000。

### 【输出描述】
一行一个数，表示最短距离。数据保证一定可以从城市 1 到城市 n。

### 【样例输入 1】
```
11
0 5 3 0 0 0 0 0 0 0 0
5 0 0 1 6 3 0 0 0 0 0
3 0 0 0 8 0 4 0 0 0 0
0 1 0 0 0 0 0 5 6 0 0
0 6 8 0 0 0 0 5 0 0 0
0 3 0 0 0 0 0 0 0 8 0
0 0 4 0 0 0 0 0 0 3 0
0 0 0 5 5 0 0 0 0 0 3
0 0 0 6 0 0 0 0 0 0 4
0 0 0 0 0 8 3 0 0 0 3
0 0 0 0 0 0 0 3 4 3 0
```
### 【样例输出 1】
```
13
```

{% folding green::答案 %}
```c++
#include <bits/stdc++.h>
using namespace std;

int n;
int g[101][101];
int dp[101], vis[101];
int inf;

int dfs(int x) {    //1-x最短路径，记忆化搜索
    if(dp[x] != inf) return dp[x];

    int ans = inf;
    for(int i = 1; i <= n; i++) {
        if(g[x][i] != 0 && !vis[i]) {
            vis[i] = true;
            ans = min(ans, dfs(i) + g[x][i]);
            vis[i] = false;
        }
    }
    return dp[x] = ans;
}

int main() {
    memset(dp, 0x3f, sizeof(dp));
    inf = dp[0];
    dp[1] = 0;
    cin >> n;
    for(int i = 1; i <= n ;i++) {
        for(int j = 1; j <= n; j++) {
            cin >> g[i][j];
        }
    }
    vis[n] = true;
    memset(vis, 0, sizeof(vis));
    cout << dfs(n) << endl;

    for(int i = 1; i <= n; i++) {
        cout << vis[i] << " ";
    }
}
```
{% endfolding %}

## 6. 评选最佳品牌

### 【问题描述】
n 个评委投票，在 m 个商品中评选一个最佳品牌。评选采用多轮淘汰制，即：每轮投票，淘汰掉得票最少的候选品牌（得票并列最少的品牌一起淘汰）。

如此一轮轮淘汰下去，如果最后只剩下一个品牌当选，即告评选成功。但如果在某轮投票中，当时未被淘汰的所有候选品牌（大于等于两个品牌）都并列得票最少，即告评选失败。

如果评选成功就输出当选品牌号。否则输出最后一轮评选时唯一选票数的相反数。在评选流程中，每个评委的态度都可用一个序列来表示；例如当 m=5 时，某评委的评选态度序列为：3、5、1、2、4，则表示该评委：优先投 3 号，当 3 号被淘汰时投5 号，当 3 和 5 都被淘汰时投 1，当 3、5、1 都被淘汰时投 2，仅剩 4 号时才投 4 号品牌的票。

选票的序列中可以表示弃权，用 0 来表示，例如当 m=5 时，某评委的评选态度序列为：3、5、0，则表示该评委：优先投 3 号，当 3 号被淘汰时投 5 号，其它情况下不投任何品牌的票。

请你编一个程序，模拟各轮投票的过程，得到评选结果。

### 【输入描述】
第一行：m(0<m<10，表示参加评选的品牌数)和 N(1<n<1000，表示参加投票的评
委数)，之间以空格分隔。

接下来的 n 行：每行都是长度不超 m 的数字字符串，每个字符串表示一个评委的评
选态度。

### 【输出描述】
评选结果。

### 【样例输入 1】
```
3 4
123
213
132
10
```
### 【样例输出 1】
```
1
```

### 【样例输入 2】
```
3 4
321
213
231
312
```

### 【样例输出 2】
```
-2
```

### 【样例数据说明】
样例 1

第一行 3,4 代表 3 个品牌：

第一轮投票 3 个评委优先选择 1 号品牌，1 个评委选择 2 号品牌，品牌 3 得票最少，淘汰掉。

第二轮投票 3 个评委优先 1 号品牌，1 个评委选择 2 号品牌，品牌 2 得票最少，淘汰掉，淘汰 2 号品牌后，只剩下一个品牌，1 号品牌胜出，最终结果 1。

样例 2

第一行 34 代表 3 个品牌 4 个评委。

第一轮投票，2 个评委选择 2 号品牌，两个评委选择 3 号品牌，1 号得票最少，淘汰掉。

第二轮投票，2 个评委选择 2 号品牌，两个评委选择 3 号品牌，由于只剩下两个品牌，且并列最少，都是 2 票代表评选失败需要输出最后一轮票数 2 的相反数-2。最终结果-2。